From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Subject: [RFC PATCH v4 5/5] server: Replace redundant recv_socket status fields with force_async boolean field.
Message-Id: <fabd9981-3661-c708-564d-5bf64f69cba6@gmail.com>
Date: Sat, 29 Jan 2022 16:47:24 +0900
In-Reply-To: <f58594d9-b43b-2c96-802c-1ee275430dd9@gmail.com>
References: <f58594d9-b43b-2c96-802c-1ee275430dd9@gmail.com>

The 'status' field of recv_socket_request is always either
STATUS_PENDING or STATUS_DEVICE_NOT_READY, and the 'total' field is
always zero.

Replace the 'status' field with 'force_async' boolean field, and get rid
of the 'total' field entirely.

Also, clean up the recv_socket handler code a bit.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---

Notes:
    v3 -> v4: unchanged

 dlls/ntdll/unix/socket.c |  7 ++-----
 server/protocol.def      |  3 +--
 server/sock.c            | 23 +++++++++--------------
 3 files changed, 12 insertions(+), 21 deletions(-)

diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index a4a25960836..49e2748d8ae 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -737,13 +737,9 @@ static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
         }
     }
 
-    status = force_async ? STATUS_PENDING : STATUS_DEVICE_NOT_READY;
-    information = 0;
-
     SERVER_START_REQ( recv_socket )
     {
-        req->status = status;
-        req->total  = information;
+        req->force_async = force_async;
         req->async  = server_async( handle, &async->io, event, apc, apc_user, iosb_client_ptr(io) );
         req->oob    = !!(unix_flags & MSG_OOB);
         status = wine_server_call( req );
@@ -753,6 +749,7 @@ static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
     }
     SERVER_END_REQ;
 
+    information = 0;
     alerted = status == STATUS_ALERTED;
     if (alerted)
     {
diff --git a/server/protocol.def b/server/protocol.def
index 84a910bcd57..a73ab34c82b 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1509,8 +1509,7 @@ enum server_fd_type
 @REQ(recv_socket)
     int          oob;           /* are we receiving OOB data? */
     async_data_t async;         /* async I/O parameters */
-    unsigned int status;        /* status of initial call */
-    unsigned int total;         /* number of bytes already read */
+    int          force_async;   /* Force asynchronous mode? */
 @REPLY
     obj_handle_t wait;          /* handle to wait on for blocking recv */
     unsigned int options;       /* device open options */
diff --git a/server/sock.c b/server/sock.c
index db3e1b0f9fd..a7ef3020d9e 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -3437,8 +3437,8 @@ struct object *create_socket_device( struct object *root, const struct unicode_s
 DECL_HANDLER(recv_socket)
 {
     struct sock *sock = (struct sock *)get_handle_obj( current->process, req->async.handle, 0, &sock_ops );
-    unsigned int status = req->status;
-    int pending = 0;
+    unsigned int status = STATUS_PENDING;
+    int pending = req->force_async;
     timeout_t timeout = 0;
     struct async *async;
     struct fd *fd;
@@ -3446,8 +3446,8 @@ DECL_HANDLER(recv_socket)
     if (!sock) return;
     fd = sock->fd;
 
-    /* recv() returned EWOULDBLOCK, i.e. no data available yet */
-    if (status == STATUS_DEVICE_NOT_READY && !sock->nonblocking)
+    /* Synchronous, *blocking* I/O requested? */
+    if (!req->force_async && !sock->nonblocking)
     {
         /* Set a timeout on the async if necessary.
          *
@@ -3458,16 +3458,16 @@ DECL_HANDLER(recv_socket)
         if (is_fd_overlapped( fd ))
             timeout = (timeout_t)sock->rcvtimeo * -10000;
 
-        status = STATUS_PENDING;
+        pending = 1;
     }
 
-    if ((status == STATUS_PENDING || status == STATUS_DEVICE_NOT_READY) && sock->rd_shutdown)
+    if (status == STATUS_PENDING && sock->rd_shutdown)
         status = STATUS_PIPE_DISCONNECTED;
 
     /* NOTE: If read_q is not empty, we cannot really tell if the already queued asyncs
      * NOTE: will not consume all available data; if there's no data available,
      * NOTE: the current request won't be immediately satiable. */
-    if ((status == STATUS_PENDING || status == STATUS_DEVICE_NOT_READY) && !async_queued( &sock->read_q ))
+    if (status == STATUS_PENDING && !async_queued( &sock->read_q ))
     {
         struct pollfd pollfd;
         pollfd.fd = get_unix_fd( sock->fd );
@@ -3478,22 +3478,17 @@ DECL_HANDLER(recv_socket)
             /* Give the client opportunity to complete synchronously.
              * If it turns out that the I/O request is not actually immediately satiable,
              * the client may then choose to re-queue the async (with STATUS_PENDING). */
-            pending = status == STATUS_PENDING;
             status = STATUS_ALERTED;
         }
     }
 
+    if (!pending && status == STATUS_PENDING) status = STATUS_DEVICE_NOT_READY;
+
     sock->pending_events &= ~(req->oob ? AFD_POLL_OOB : AFD_POLL_READ);
     sock->reported_events &= ~(req->oob ? AFD_POLL_OOB : AFD_POLL_READ);
 
     if ((async = create_request_async( fd, get_fd_comp_flags( fd ), &req->async )))
     {
-        if (status == STATUS_SUCCESS)
-        {
-            struct iosb *iosb = async_get_iosb( async );
-            iosb->result = req->total;
-            release_object( iosb );
-        }
         set_error( status );
 
         if (timeout)

-- 
2.35.1

