From 8868a7eb937ec4cfb14956257a553f4829960c9d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 19 Sep 2019 15:42:09 +0200
Subject: [PATCH 5/8] winex11.drv: Wait for pointer grab on
 FocusIn/WM_TAKE_FOCUS events.

The FocusIn/WM_TAKE_FOCUS events are received as soon as a window is
clicked, but when some modifier key is pressed or when the click is on
the window frame, the WM may still be controlling the window size or
position. It usually grabs the cursor while doing so - and if not then
there's apparently nothing we can do.

When using undecorated mode we handle this case "correctly" by going
through the corresponding Windows non-client message loop until mouse
buttons are released, but when using decorated windows the window
decoration is empty from the Wine perspective and any window event is
considered as happening in the client area.

This leads to some issues when the window is moved or resized, with
applications applying clipping rectangles immediately and not updating
it on subsequent window move/resize messages. Delaying the WM_ACTIVATE
until the WM releases its grab and the window move is complete helps
solving this situation.

This delay is implemented here by resending the FocusIn/WM_TAKE_FOCUS
events to the window until the cursor can be grabbed and then processing
them normally.
---
 dlls/winex11.drv/event.c  | 42 +++++++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/window.c |  2 ++
 dlls/winex11.drv/x11drv.h |  3 ++-
 3 files changed, 44 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 5c139af3f19..157a4ee2635 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -322,6 +322,24 @@ static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawE
 }
 #endif
 
+static int try_grab_pointer( Display *display )
+{
+    if (!grab_pointer)
+        return 1;
+
+    /* if we are already clipping the cursor in the current thread, we should not
+     * call XGrabPointer here or it would change the confine-to window. */
+    if (clipping_cursor)
+        return 1;
+
+    if (XGrabPointer( display, root_window, False, 0, GrabModeAsync, GrabModeAsync,
+                      None, None, CurrentTime ) != GrabSuccess)
+        return 0;
+
+    XUngrabPointer( display, CurrentTime );
+    return 1;
+}
+
 /***********************************************************************
  *           merge_events
  *
@@ -678,8 +696,18 @@ static void set_focus( XEvent *xev, HWND hwnd, Time time )
     /* prevent recursion */
     x11drv_thread_data()->active_window = hwnd;
 
-    TRACE( "setting foreground window to %p\n", hwnd );
-    SetForegroundWindow( hwnd );
+    if (!try_grab_pointer( xev->xany.display ))
+    {
+        /* ask the desktop window to release its grab before trying to get ours */
+        SendMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_RELEASE_CURSOR, 0, 0 );
+        XSendEvent( xev->xany.display, xev->xany.window, False, 0, xev );
+        return;
+    }
+    else
+    {
+        TRACE( "setting foreground window to %p\n", hwnd );
+        SetForegroundWindow( hwnd );
+    }
 
     /* Some applications expect that a being deactivated topmost window
      * receives the WM_WINDOWPOSCHANGING/WM_WINDOWPOSCHANGED messages,
@@ -867,6 +895,14 @@ BOOL x11drv_handle_focus_in_event( HWND hwnd, XEvent *xev, Time time )
         x11drv_global_focus_in( event->display );
     if (hwnd == GetDesktopWindow()) return FALSE;
 
+    if (!try_grab_pointer( event->display ))
+    {
+        /* ask the desktop window to release its grab before trying to get ours */
+        SendMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_RELEASE_CURSOR, 0, 0 );
+        XSendEvent( event->display, event->window, False, 0, xev );
+        return FALSE;
+    }
+
     switch (event->mode)
     {
     case NotifyGrab:
@@ -992,6 +1028,8 @@ BOOL x11drv_handle_focus_out_event( HWND hwnd, XEvent *xev, Time time )
         break;
     }
 
+    if (hwnd == GetForegroundWindow()) SendNotifyMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_RELEASE_CURSOR, 0, 0 );
+
     /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
     if (event->mode == NotifyGrab || event->mode == NotifyUngrab) return FALSE;
 
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index d8f56768a65..fb1aaa49727 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2927,6 +2927,8 @@ LRESULT CDECL X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
         return 0;
     case WM_X11DRV_ADD_TAB:
         taskbar_add_tab( hwnd );
+    case WM_X11DRV_DESKTOP_RELEASE_CURSOR:
+        ungrab_clipping_window();
         return 0;
     default:
         FIXME( "got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 214a1b6d0f6..7a4bdb49699 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -608,6 +608,7 @@ enum x11drv_window_messages
     WM_X11DRV_DELETE_TAB,
     WM_X11DRV_ADD_TAB,
     WM_X11DRV_DROPEVENT,
+    WM_X11DRV_DESKTOP_RELEASE_CURSOR,
 };
 
 /* _NET_WM_STATE properties that we keep track of */
-- 
2.34.1

