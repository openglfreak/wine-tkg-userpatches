From 8d67c0460e0911e59cf2b67f421ee712738b0760 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 3 Mar 2022 01:17:09 +0100
Subject: [PATCH 09/20] winegstreamer: Reply with the custom buffer pool to
 ALLOCATION query.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/unix_private.h |  1 +
 dlls/winegstreamer/wg_pool.c      | 64 +++++++++++++++++++++++++++++--
 dlls/winegstreamer/wg_transform.c | 53 +++++++++++++++++++++++++
 3 files changed, 115 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -40,6 +40,7 @@ extern NTSTATUS wg_transform_push_data(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_read_data(void *args) DECLSPEC_HIDDEN;
 
 extern GstBufferPool *wg_pool_create(void) DECLSPEC_HIDDEN;
+extern void wg_pool_configure(GstBufferPool *gst_pool, GstCaps *caps, gsize *buffer_size) DECLSPEC_HIDDEN;
 extern void wg_pool_destroy(GstBufferPool *gst_pool) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/wg_pool.c b/dlls/winegstreamer/wg_pool.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_pool.c
+++ b/dlls/winegstreamer/wg_pool.c
@@ -29,6 +29,7 @@
 
 #include <gst/gst.h>
 #include <gst/video/video.h>
+#include <gst/audio/audio.h>
 
 #include "unix_private.h"
 
@@ -38,6 +39,13 @@ GST_DEBUG_CATEGORY_EXTERN(wine);
 typedef struct
 {
     GstBufferPool parent;
+    gsize buffer_size;
+    bool is_video;
+    union
+    {
+        GstVideoInfo video_info;
+        GstAudioInfo audio_info;
+    } u;
 } WgBufferPool;
 
 typedef struct
@@ -50,18 +58,38 @@ G_DEFINE_TYPE(WgBufferPool, wg_pool, GST_TYPE_BUFFER_POOL);
 static GstFlowReturn wg_pool_acquire_buffer(GstBufferPool *gst_pool, GstBuffer **buffer,
         GstBufferPoolAcquireParams *params)
 {
+    GstBufferPoolClass *parent = GST_BUFFER_POOL_CLASS(wg_pool_parent_class);
     WgBufferPool *pool = (WgBufferPool *)gst_pool;
+    GstVideoInfo *video_info = pool->is_video ? &pool->u.video_info : NULL;
+    GstFlowReturn ret;
 
-    GST_FIXME("pool %p, buffer %p, params %p, stub!", pool, buffer, params);
+    GST_LOG("pool %p, buffer %p, params %p", pool, buffer, params);
 
-    return GST_FLOW_ERROR;
+    if ((ret = parent->acquire_buffer(gst_pool, buffer, params)))
+        return ret;
+
+    if (video_info)
+    {
+        gst_buffer_add_video_meta_full(*buffer, GST_VIDEO_FRAME_FLAG_NONE,
+                GST_VIDEO_INFO_FORMAT(video_info), GST_VIDEO_INFO_WIDTH(video_info),
+                GST_VIDEO_INFO_HEIGHT(video_info), GST_VIDEO_INFO_N_PLANES(video_info),
+                video_info->offset, video_info->stride);
+    }
+
+    GST_INFO("Acquired buffer %p", *buffer);
+    return *buffer ? GST_FLOW_OK : GST_FLOW_ERROR;
 }
 
 static void wg_pool_free_buffer(GstBufferPool *gst_pool, GstBuffer *buffer)
 {
     WgBufferPool *pool = (WgBufferPool *)gst_pool;
 
-    GST_FIXME("pool %p, buffer %p, stub!", pool, buffer);
+    GST_LOG("pool %p, buffer %p", pool, buffer);
+
+    /* release the last ref on the buffer */
+    gst_buffer_unref(buffer);
+
+    GST_INFO("Freed buffer %p", buffer);
 }
 
 static void wg_pool_init(WgBufferPool *pool)
@@ -103,6 +131,36 @@ GstBufferPool *wg_pool_create(void)
     return gst_pool;
 }
 
+void wg_pool_configure(GstBufferPool *gst_pool, GstCaps *caps, gsize *buffer_size)
+{
+    const gchar *media_type = gst_structure_get_name(gst_caps_get_structure(caps, 0));
+    WgBufferPool *pool = (WgBufferPool *)gst_pool;
+    GstStructure *config;
+
+    GST_LOG("pool %p, caps %p", pool, caps);
+
+    pool->is_video = g_str_has_prefix(media_type, "video/");
+    if (pool->is_video)
+        gst_video_info_from_caps(&pool->u.video_info, caps);
+    else
+        gst_audio_info_from_caps(&pool->u.audio_info, caps);
+
+    if (!pool->is_video)
+        pool->buffer_size = 16384 * pool->u.audio_info.bpf;
+    else
+        pool->buffer_size = pool->u.video_info.size;
+    pool->buffer_size = max(pool->buffer_size, *buffer_size);
+
+    if ((config = gst_buffer_pool_get_config(gst_pool)))
+    {
+        gst_buffer_pool_config_set_params(config, gst_caps_copy(caps),
+                pool->buffer_size, 0, 0);
+        gst_buffer_pool_set_config(gst_pool, config);
+    }
+
+    *buffer_size = pool->buffer_size;
+}
+
 void wg_pool_destroy(GstBufferPool *gst_pool)
 {
     WgBufferPool *pool = (WgBufferPool *)gst_pool;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -51,6 +51,7 @@ struct wg_transform
     GstSegment segment;
     GstBufferList *input;
     guint input_max_length;
+    bool enable_pool;
 
     pthread_mutex_t mutex;
     GstCaps *sink_caps, *output_caps;
@@ -109,6 +110,56 @@ static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent
     return TRUE;
 }
 
+static gboolean transform_sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_LOG("transform %p, type \"%s\".", transform, gst_query_type_get_name(query->type));
+
+    switch (query->type)
+    {
+    case GST_QUERY_ALLOCATION:
+    {
+        guint size, min, max, min_buffers = 0, max_buffers = 0;
+        gsize buffer_size = 0;
+        GstBufferPool *pool;
+        gboolean need_pool;
+        GstCaps *caps;
+        int i;
+
+        gst_query_parse_allocation(query, &caps, &need_pool);
+        GST_INFO("Parsed allocation query, caps %p, need_pool %u", caps, need_pool);
+        if (!need_pool || !caps)
+            break;
+
+        for (i = gst_query_get_n_allocation_pools(query) - 1; i >= 0; i--)
+        {
+            gst_query_parse_nth_allocation_pool(query, i - 1, &pool, &size, &min, &max);
+            if (pool == transform->pool) need_pool = false;
+            buffer_size = max(size, buffer_size);
+            min_buffers = max(min, min_buffers);
+            max_buffers = max(max, max_buffers);
+        }
+
+        pthread_mutex_lock(&transform->mutex);
+        if (need_pool && (pool = wg_pool_create()))
+        {
+            wg_pool_destroy(transform->pool);
+            transform->pool = pool;
+        }
+        wg_pool_configure(transform->pool, caps, &buffer_size);
+        gst_query_add_allocation_pool(query, pool, buffer_size, min_buffers, max_buffers);
+        pthread_mutex_unlock(&transform->mutex);
+        return TRUE;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" query.", gst_query_type_get_name(query->type));
+        break;
+    }
+
+    return gst_pad_query_default(pad, parent, query);
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
@@ -254,6 +305,7 @@ NTSTATUS wg_transform_create(void *args)
         goto out;
 
     gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_query_function(transform->my_sink, transform_sink_query_cb);
     gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
 
@@ -318,6 +370,7 @@ NTSTATUS wg_transform_create(void *args)
             break;
 
         case WG_MAJOR_TYPE_VIDEO:
+            transform->enable_pool = true;
             if (!(element = create_element("videoconvert", "base"))
                     || !transform_append_element(transform, element, &first, &last))
                 goto out;
-- 
2.35.1

