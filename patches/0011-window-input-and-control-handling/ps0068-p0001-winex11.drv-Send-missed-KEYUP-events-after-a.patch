From 7c84e2c9efaf3614b530d25443a1222852fc13c7 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 8 Jun 2021 16:01:54 +0300
Subject: [PATCH 1/2] winex11.drv: Send missed KEYUP events after a keyboard grab
 is released.

Full focus lost / focus gained events on the Windows side are not
feasible for X11's keyboard grabs (see XGrabKeyboard()), and using them
would degrade user experience, especially with our full screen hack, by
causing the window to minimize or flash multiple times depending on a
game/window manager combo.

There's nothing else we could map X11's keyboard grab to force the
program to resync its key state.

This change attempts to improve user experience by syncing any missed
key release events that happened during the grab so the user won't end
up with stuck keys.

There's no syncing of key presses as those are more problematic because
of window manager quirks, e.g. on KDE it may end up syncing the Tab
press portion of Alt+Tab. Luckily missing key events for keys that were
pressed and not released while the WM had the keyboard grab is not
nearly as confusing as stuck keys.

For Warhammer: Chaosbane and Far Cry Primal keyboard state after focus
loss.

CW-Bug-ID: #17046
CW-Bug-ID: #18904
---
 dlls/winex11.drv/event.c    |  1 +
 dlls/winex11.drv/keyboard.c | 43 +++++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/x11drv.h   |  1 +
 3 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index bc10df77863..bed20cc4a00 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -827,6 +827,7 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     case NotifyUngrab:
         keyboard_grabbed = FALSE;
         SendNotifyMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_CLIP_CURSOR, FALSE, FALSE );
+        x11drv_thread_data()->kbd_grab_release_hwnd = hwnd;
         return TRUE; /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
     }
 
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 34de443881c..c7b3c1682e1 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1210,11 +1210,19 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     int i, j;
     BYTE keystate[256];
     WORD vkey;
+    DWORD flags;
+    KeyCode keycode;
+    HWND kbd_grab_release_hwnd;
     BOOL changed = FALSE;
     struct {
         WORD vkey;
+        WORD scan;
         WORD pressed;
     } keys[256];
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    kbd_grab_release_hwnd = thread_data->kbd_grab_release_hwnd;
+    thread_data->kbd_grab_release_hwnd = NULL;
 
     if (!get_async_key_state( keystate )) return FALSE;
 
@@ -1229,11 +1237,17 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     {
         for (j = 0; j < 8; j++)
         {
-            vkey = keyc2vkey[(i * 8) + j];
+            keycode = (i * 8) + j;
+            vkey = keyc2vkey[keycode];
 
             /* If multiple keys map to the same vkey, we want to report it as
              * pressed iff any of them are pressed. */
-            if (!keys[vkey & 0xff].vkey) keys[vkey & 0xff].vkey = vkey;
+            if (!keys[vkey & 0xff].vkey)
+            {
+                keys[vkey & 0xff].vkey = vkey;
+                keys[vkey & 0xff].scan = keyc2scan[keycode] & 0xff;
+            }
+
             if (event->xkeymap.key_vector[i] & (1<<j)) keys[vkey & 0xff].pressed = TRUE;
         }
     }
@@ -1245,6 +1259,31 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
             TRACE( "Adjusting state for vkey %#.2x. State before %#.2x\n",
                    keys[vkey].vkey, keystate[vkey]);
 
+            /* This KeymapNotify follows a FocusIn(mode=NotifyUngrab) event,
+             * which is caused by a keyboard grab being released.
+             * See XGrabKeyboard().
+             *
+             * We might have missed some key press/release events while the
+             * keyboard was grabbed, but keyboard grab doesn't generate focus
+             * lost / focus gained events on the Windows side, so the affected
+             * program is not aware that it needs to resync the keyboard state.
+             *
+             * This, for example, may cause Alt being stuck after using Alt+Tab.
+             *
+             * To work around that problem we sync any possible key releases.
+             *
+             * Syncing key presses is not feasible as window managers differ in
+             * event sequences, e.g. KDE performs two keyboard grabs for
+             * Alt+Tab, which would sync the Tab press.
+             */
+            if (kbd_grab_release_hwnd && !keys[vkey].pressed)
+            {
+                TRACE( "Sending KEYUP for a modifier %#.2x\n", vkey);
+                flags = KEYEVENTF_KEYUP;
+                if (keys[vkey].vkey & 0x1000) flags |= KEYEVENTF_EXTENDEDKEY;
+                X11DRV_send_keyboard_input( kbd_grab_release_hwnd, vkey, keys[vkey].scan, flags, GetTickCount() );
+            }
+
             update_key_state( keystate, vkey, keys[vkey].pressed );
             changed = TRUE;
         }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 322944656a5..f77dfc9e812 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -390,6 +390,7 @@ struct x11drv_thread_data
     HWND     grab_hwnd;            /* window that currently grabs the mouse */
     HWND     active_window;        /* active window */
     HWND     last_focus;           /* last window that had focus */
+    HWND     kbd_grab_release_hwnd;/* window that should receive modifier release events */
     XIM      xim;                  /* input method */
     HWND     last_xic_hwnd;        /* last xic window */
     XFontSet font_set;             /* international text drawing font set */
