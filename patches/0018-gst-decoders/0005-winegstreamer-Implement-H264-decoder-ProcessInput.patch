From 2cf488a45d7d254b34bd1930c8dac34f28d39988 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 8 Mar 2022 23:31:24 +0100
Subject: [PATCH 05/20] winegstreamer: Implement H264 decoder ProcessInput.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/mf/tests/mf.c                |  1 -
 dlls/winegstreamer/h264_decoder.c | 22 +++++++++++++++++++--
 dlls/winegstreamer/wg_transform.c | 33 ++++++++++++++++++++++---------
 3 files changed, 44 insertions(+), 12 deletions(-)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 11111111111..11111111111 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -6856,7 +6856,6 @@ static void test_h264_decoder(void)
         sample = next_h264_sample(&h264_encoded_data, &h264_encoded_data_len);
 
         hr = IMFTransform_ProcessInput(transform, 0, sample, 0);
-        todo_wine
         ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
         ret = IMFSample_Release(sample);
         ok(ret <= 1, "Release returned %lu\n", ret);
diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -497,8 +497,26 @@ static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_
 
 static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("iface %p, id %#lx, sample %p, flags %#lx stub!\n", iface, id, sample, flags);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample *wg_sample;
+    MFT_INPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = mf_create_wg_sample(sample, &wg_sample)))
+        return hr;
+
+    hr = wg_transform_push_data(decoder->wg_transform, wg_sample);
+
+    mf_destroy_wg_sample(wg_sample);
+    return hr;
 }
 
 static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -48,7 +48,8 @@ struct wg_transform
     GstPad *my_src, *my_sink;
     GstPad *their_sink, *their_src;
     GstSegment segment;
-    GstBuffer *input;
+    GstBufferList *input;
+    guint input_max_length;
 
     pthread_mutex_t mutex;
     GstBuffer *output;
@@ -75,7 +76,7 @@ NTSTATUS wg_transform_destroy(void *args)
     struct wg_transform *transform = args;
 
     if (transform->input)
-        gst_buffer_unref(transform->input);
+        gst_buffer_list_unref(transform->input);
     if (transform->output)
         gst_buffer_unref(transform->output);
 
@@ -179,6 +180,9 @@ NTSTATUS wg_transform_create(void *args)
         return STATUS_NO_MEMORY;
     if (!(transform->container = gst_bin_new("wg_transform")))
         goto out;
+    if (!(transform->input = gst_buffer_list_new()))
+        goto out;
+    transform->input_max_length = 1;
 
     if (!(src_caps = wg_format_to_caps(&input_format)))
         goto out;
@@ -212,6 +216,8 @@ NTSTATUS wg_transform_create(void *args)
     switch (input_format.major_type)
     {
         case WG_MAJOR_TYPE_H264:
+            transform->input_max_length = 16;
+            /* fallthrough */
         case WG_MAJOR_TYPE_WMA:
             if (!(element = transform_find_element(GST_ELEMENT_FACTORY_TYPE_DECODER, src_caps, raw_caps))
                     || !transform_append_element(transform, element, &first, &last))
@@ -316,6 +322,8 @@ out:
         gst_object_unref(transform->my_src);
     if (src_caps)
         gst_caps_unref(src_caps);
+    if (transform->input)
+        gst_buffer_list_unref(transform->input);
     if (transform->container)
     {
         gst_element_set_state(transform->container, GST_STATE_NULL);
@@ -332,10 +340,12 @@ NTSTATUS wg_transform_push_data(void *args)
     struct wg_transform *transform = params->transform;
     struct wg_sample *sample = params->sample;
     GstBuffer *buffer;
+    guint length;
 
-    if (transform->input)
+    length = gst_buffer_list_length(transform->input);
+    if (length >= transform->input_max_length)
     {
-        GST_INFO("Refusing %u bytes, a buffer is already queued", sample->size);
+        GST_INFO("Refusing %u bytes, %u buffers already queued", sample->size, length);
         params->result = MF_E_NOTACCEPTING;
         return STATUS_SUCCESS;
     }
@@ -346,9 +356,9 @@ NTSTATUS wg_transform_push_data(void *args)
         return STATUS_NO_MEMORY;
     }
     gst_buffer_fill(buffer, 0, sample->data, sample->size);
-    transform->input = buffer;
+    gst_buffer_list_insert(transform->input, -1, buffer);
 
-    GST_INFO("Copied %u bytes from sample %p to input buffer", sample->size, sample);
+    GST_INFO("Copied %u bytes from sample %p to input buffer list", sample->size, sample);
     params->result = S_OK;
     return STATUS_SUCCESS;
 }
@@ -392,17 +402,22 @@ NTSTATUS wg_transform_read_data(void *args)
     struct wg_transform_read_data_params *params = args;
     struct wg_transform *transform = params->transform;
     struct wg_sample *sample = params->sample;
+    GstBufferList *input = transform->input;
     GstFlowReturn ret;
     NTSTATUS status;
 
-    if (!transform->input)
+    if (!gst_buffer_list_length(transform->input))
         GST_DEBUG("Not input buffer queued");
-    else if ((ret = gst_pad_push(transform->my_src, transform->input)))
+    else if (!(transform->input = gst_buffer_list_new()))
+    {
+        GST_ERROR("Failed to allocate new input queue");
+        return STATUS_NO_MEMORY;
+    }
+    else if ((ret = gst_pad_push_list(transform->my_src, input)))
     {
         GST_ERROR("Failed to push transform input, error %d", ret);
         return STATUS_UNSUCCESSFUL;
     }
-    transform->input = NULL;
 
     sample->size = 0;
     pthread_mutex_lock(&transform->mutex);
-- 
2.35.1

