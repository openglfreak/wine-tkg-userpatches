From: Giovanni Mascellani <gmascellani@codeweavers.com>
Subject: [RFC PATCH] ntdll: Swallow crashes once pthread_exit() has been called.
Message-Id: <20211217111031.1976356-1-gmascellani@codeweavers.com>
Date: Fri, 17 Dec 2021 12:10:31 +0100

When pthread_exit() is called, it tries to rewind the stack, which includes
calling cleanup routines registered with pthread_cleanup_push() or similar
procedures. But we also unwind the stack in signal_exit_thread(). This means
that if any cleanup routine was registered between the exit frame and where
control was when the thread was interrupted, then pthread will try to
call functions from frames that do not exist anymore and might have been
overwritten, which easily results in segmentation faults or similar
accidents.

Since until PE separation is finished it is not easy to fix the real
problem, this patch logs and swallows crashes occurring after
pthread_exit() is called, so that at least damages are minimized and
developers are not confused by irrelevant messages.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52213
---
 dlls/ntdll/unix/signal_arm.c    | 6 ++++++
 dlls/ntdll/unix/signal_arm64.c  | 6 ++++++
 dlls/ntdll/unix/signal_i386.c   | 6 ++++++
 dlls/ntdll/unix/signal_x86_64.c | 6 ++++++
 dlls/ntdll/unix/thread.c        | 2 ++
 dlls/ntdll/unix/unix_private.h  | 1 +
 6 files changed, 27 insertions(+)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 35cda277411..575c6277264 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -864,6 +864,12 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     EXCEPTION_RECORD rec = { 0 };
     ucontext_t *context = sigcontext;
 
+    if (ntdll_get_thread_data()->exiting_pthread)
+    {
+        WARN("Swallowing crash after pthread is exiting\n");
+        _exit(0);
+    }
+
     switch (get_trap_code(signal, context))
     {
     case TRAP_ARM_PRIVINFLT:   /* Invalid opcode exception */
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index e1159693706..28ecaf862d8 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -908,6 +908,12 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     EXCEPTION_RECORD rec = { 0 };
     ucontext_t *context = sigcontext;
 
+    if (ntdll_get_thread_data()->exiting_pthread)
+    {
+        WARN("Swallowing crash after pthread is exiting\n");
+        _exit(0);
+    }
+
     rec.NumberParameters = 2;
     rec.ExceptionInformation[0] = (get_fault_esr( context ) & 0x40) != 0;
     rec.ExceptionInformation[1] = (ULONG_PTR)siginfo->si_addr;
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index cd075b0c959..9f445e76b31 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1836,6 +1836,12 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     ucontext_t *ucontext = sigcontext;
     void *stack = setup_exception_record( sigcontext, &rec, &xcontext );
 
+    if (ntdll_get_thread_data()->exiting_pthread)
+    {
+        WARN("Swallowing crash after pthread is exiting\n");
+        _exit(0);
+    }
+
     switch (TRAP_sig(ucontext))
     {
     case TRAP_x86_OFLOW:   /* Overflow exception */
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index cd5b0ea018e..7bec8c418f9 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -2865,6 +2865,12 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     struct xcontext context;
     ucontext_t *ucontext = sigcontext;
 
+    if (ntdll_get_thread_data()->exiting_pthread)
+    {
+        WARN("Swallowing crash after pthread is exiting\n");
+        _exit(0);
+    }
+
     rec.ExceptionAddress = (void *)RIP_sig(ucontext);
     save_context( &context, sigcontext );
 
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 0eee1367a5e..2191709dcb3 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1056,6 +1056,7 @@ static void pthread_exit_wrapper( int status )
     close( ntdll_get_thread_data()->wait_fd[1] );
     close( ntdll_get_thread_data()->reply_fd );
     close( ntdll_get_thread_data()->request_fd );
+    ntdll_get_thread_data()->exiting_pthread = TRUE;
     pthread_exit( UIntToPtr(status) );
 }
 
@@ -1345,6 +1346,7 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle, ACCESS_MASK access, OBJECT_ATT
     thread_data->request_fd  = request_pipe[1];
     thread_data->start = start;
     thread_data->param = param;
+    thread_data->exiting_pthread = FALSE;
 
     pthread_attr_init( &pthread_attr );
     pthread_attr_setstack( &pthread_attr, teb->DeallocationStack,
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 1c2640e4c80..23666b84e2d 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -64,6 +64,7 @@ struct ntdll_thread_data
     void              *param;         /* thread entry point parameter */
     void              *jmp_buf;       /* setjmp buffer for exception handling */
     void              *heap;          /* thread local heap data */
+    BOOL               exiting_pthread;
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );

-- 
2.35.1

