From: "Bernhard Kölbl" <besentv@gmail.com>
Subject: [PATCH 3/3] gdiplus: Add simple test for bitmap clone from 32bit to indexed.
Message-Id: <20211118141940.73313-3-besentv@gmail.com>
Date: Thu, 18 Nov 2021 15:19:40 +0100
In-Reply-To: <20211118141940.73313-1-besentv@gmail.com>
References: <20211118141940.73313-1-besentv@gmail.com>

Signed-off-by: Bernhard Kölbl <besentv@gmail.com>
---
 dlls/gdiplus/tests/image.c | 42 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/dlls/gdiplus/tests/image.c b/dlls/gdiplus/tests/image.c
index 2175c1748e0..01fda84f44b 100644
--- a/dlls/gdiplus/tests/image.c
+++ b/dlls/gdiplus/tests/image.c
@@ -5102,9 +5102,17 @@ static void test_PARGB_conversion(void)
 
 static void test_CloneBitmapArea(void)
 {
+    /* 3x3 pixeldata in format 32bpp RGB: red, green, blue, yellow, turquoise, pink, black, gray, white */
+    static const unsigned char bmp_3x3_data[100] = {
+    0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00,
+    0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x80, 0x80, 0x80, 0x00,
+    0x00, 0x00, 0x00, 0x00
+    };
     GpStatus status;
     GpBitmap *bitmap, *copy;
     BitmapData data, data2;
+    BYTE buf[sizeof(bmp_3x3_data)];
+    INT x, y;
 
     status = GdipCreateBitmapFromScan0(1, 1, 0, PixelFormat24bppRGB, NULL, &bitmap);
     expect(Ok, status);
@@ -5123,6 +5131,40 @@ static void test_CloneBitmapArea(void)
 
     GdipDisposeImage((GpImage *)copy);
     GdipDisposeImage((GpImage *)bitmap);
+
+    memcpy(buf, bmp_3x3_data, sizeof(bmp_3x3_data));
+    
+    status = GdipCreateBitmapFromScan0(3, 3, 4*3, PixelFormat32bppRGB, buf, &bitmap);
+    expect(Ok, status);
+
+#define check_clone_to_indexed(pixel_format) do { \
+    status = GdipCloneBitmapAreaI(0, 0, 3, 3, pixel_format, bitmap, &copy); \
+    expect(Ok, status); \
+    for (y=0; y<3; y++) \
+        for (x=0; x<3; x++) \
+        { \
+            BOOL match; \
+            ARGB color_orig; \
+            ARGB color_copy; \
+             \
+            status = GdipBitmapGetPixel(bitmap, x, y, &color_orig); \
+            expect(Ok, status); \
+            status = GdipBitmapGetPixel(copy, x, y, &color_copy); \
+            expect(Ok, status); \
+            if(pixel_format == PixelFormat1bppIndexed) \
+                color_orig = (color_orig >> 16 & 0xff) + (color_orig >> 8 & 0xff) + (color_orig & 0xff) \
+                  > 0x17d ? 0xffffffff : 0xff000000; \
+            match = color_match(color_orig, color_copy, 0x00); \
+            ok(match == TRUE, "Colors 0x%x and 0x%x do not match!\n", color_orig, color_copy); \
+        } \
+    GdipDisposeImage((GpImage *)copy); \
+}while(0) \
+
+    check_clone_to_indexed(PixelFormat1bppIndexed);
+    check_clone_to_indexed(PixelFormat4bppIndexed);
+    check_clone_to_indexed(PixelFormat8bppIndexed);
+
+    GdipDisposeImage((GpImage *)bitmap);
 }
 
 static void test_supported_encoders(void)

-- 
2.33.0

