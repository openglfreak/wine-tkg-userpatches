From 9f47b15511f4b857a569a5f3712c24d7d7c0f392 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 16 Feb 2022 12:01:15 +0100
Subject: [PATCH 08/35] winegstreamer: Support XMAudio2 input format in WMA
 decoder.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/mfplat.c      | 12 +++++++++++-
 dlls/winegstreamer/unixlib.h     |  1 +
 dlls/winegstreamer/wg_format.c   | 22 ++++++++++++++++------
 dlls/winegstreamer/wma_decoder.c |  3 +++
 4 files changed, 31 insertions(+), 7 deletions(-)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -29,6 +29,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 struct video_processor
 {
     IMFTransform IMFTransform_iface;
@@ -737,6 +739,7 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
 {
     UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
     BYTE codec_data[64];
+    bool is_xma = false;
     UINT32 version;
 
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
@@ -778,6 +781,11 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
         version = 3;
     else if (IsEqualGUID(subtype, &MFAudioFormat_WMAudio_Lossless))
         version = 4;
+    else if (IsEqualGUID(subtype, &MFAudioFormat_XMAudio2))
+    {
+        version = 2;
+        is_xma = true;
+    }
     else
     {
         assert(0);
@@ -793,6 +801,7 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
     format->u.wma.block_align = block_align;
     format->u.wma.codec_data_len = codec_data_len;
     memcpy(format->u.wma.codec_data, codec_data, codec_data_len);
+    format->u.wma.is_xma = is_xma;
 }
 
 void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
@@ -817,7 +826,8 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
         if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9) ||
-                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
+                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless) ||
+                IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
             mf_media_type_to_wg_format_wma(type, &subtype, format);
         else
             mf_media_type_to_wg_format_audio(type, &subtype, format);
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -99,6 +99,7 @@ struct wg_format
             uint32_t block_align;
             uint32_t codec_data_len;
             unsigned char codec_data[64];
+            bool is_xma;
         } wma;
     } u;
 };
diff --git a/dlls/winegstreamer/wg_format.c b/dlls/winegstreamer/wg_format.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_format.c
+++ b/dlls/winegstreamer/wg_format.c
@@ -394,15 +394,25 @@ static GstCaps *wg_format_to_caps_video(const struct wg_format *format)
     return caps;
 }
 
-static GstCaps *wg_format_to_caps_wma(const struct wg_format *format)
+static GstCaps *wg_format_to_caps_xwma(const struct wg_format *format)
 {
     GstBuffer *buffer;
     GstCaps *caps;
 
-    if (!(caps = gst_caps_new_empty_simple("audio/x-wma")))
-        return NULL;
-    if (format->u.wma.version)
-        gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.wma.version, NULL);
+    if (format->u.wma.is_xma)
+    {
+        if (!(caps = gst_caps_new_empty_simple("audio/x-xma")))
+            return NULL;
+        if (format->u.wma.version)
+            gst_caps_set_simple(caps, "xmaversion", G_TYPE_INT, format->u.wma.version, NULL);
+    }
+    else
+    {
+        if (!(caps = gst_caps_new_empty_simple("audio/x-wma")))
+            return NULL;
+        if (format->u.wma.version)
+            gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.wma.version, NULL);
+    }
 
     if (format->u.wma.bitrate)
         gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.wma.bitrate, NULL);
@@ -438,7 +448,7 @@ GstCaps *wg_format_to_caps(const struct wg_format *format)
         case WG_MAJOR_TYPE_UNKNOWN:
             return NULL;
         case WG_MAJOR_TYPE_WMA:
-            return wg_format_to_caps_wma(format);
+            return wg_format_to_caps_xwma(format);
         case WG_MAJOR_TYPE_AUDIO:
             return wg_format_to_caps_audio(format);
         case WG_MAJOR_TYPE_VIDEO:
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -30,12 +30,15 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(wmadec);
 
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 static const GUID *const wma_decoder_input_types[] =
 {
     &MEDIASUBTYPE_MSAUDIO1,
     &MFAudioFormat_WMAudioV8,
     &MFAudioFormat_WMAudioV9,
     &MFAudioFormat_WMAudio_Lossless,
+    &MFAudioFormat_XMAudio2,
 };
 static const GUID *const wma_decoder_output_types[] =
 {

