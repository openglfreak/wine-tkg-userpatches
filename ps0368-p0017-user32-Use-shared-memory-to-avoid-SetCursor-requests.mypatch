From ed217445cb57c3a5ba42967b7c9269539eb0dd43 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 3 Mar 2021 12:07:46 +0100
Subject: [PATCH 17/18] user32: Use shared memory to avoid SetCursor requests.

---
 dlls/user32/cursoricon.c | 32 +++++++++++++++++++++++++-------
 server/protocol.def      |  1 +
 server/queue.c           |  9 ++++++---
 server/user.h            |  1 -
 4 files changed, 32 insertions(+), 11 deletions(-)

diff --git a/dlls/user32/cursoricon.c b/dlls/user32/cursoricon.c
index b7e68c02280..b95208756ff 100644
--- a/dlls/user32/cursoricon.c
+++ b/dlls/user32/cursoricon.c
@@ -2040,31 +2040,49 @@ BOOL WINAPI DrawIcon( HDC hdc, INT x, INT y, HICON hIcon )
  */
 HCURSOR WINAPI DECLSPEC_HOTPATCH SetCursor( HCURSOR hCursor /* [in] Handle of cursor to show */ )
 {
+    volatile struct desktop_shared_memory *desktop = get_desktop_shared_memory();
+    volatile struct input_shared_memory *shared = get_input_shared_memory();
     struct cursoricon_object *obj;
-    HCURSOR hOldCursor;
+    HCURSOR old_cursor, new_cursor;
     int show_count;
-    BOOL ret;
+    BOOL ret, need_request;
 
     TRACE("%p\n", hCursor);
 
-    SERVER_START_REQ( set_cursor )
+    if (!shared || !desktop) return 0;
+
+    SHARED_READ_BEGIN( &shared->seq )
+    {
+        SHARED_READ_BEGIN( &desktop->seq )
+        {
+            old_cursor = wine_server_ptr_handle( shared->cursor );
+            show_count = shared->cursor_count;
+            new_cursor = show_count >= 0 ? hCursor : 0;
+            need_request = wine_server_ptr_handle( desktop->cursor.handle ) != new_cursor;
+        }
+        SHARED_READ_END( &desktop->seq );
+    }
+    SHARED_READ_END( &shared->seq );
+
+    if (!need_request) ret = TRUE;
+    else SERVER_START_REQ( set_cursor )
     {
         req->flags = SET_CURSOR_HANDLE;
         req->handle = wine_server_user_handle( hCursor );
         if ((ret = !wine_server_call_err( req )))
         {
-            hOldCursor = wine_server_ptr_handle( reply->prev_handle );
+            old_cursor = wine_server_ptr_handle( reply->prev_handle );
             show_count = reply->prev_count;
         }
     }
     SERVER_END_REQ;
 
     if (!ret) return 0;
-    USER_Driver->pSetCursor( show_count >= 0 ? hCursor : 0 );
+    USER_Driver->pSetCursor( new_cursor );
 
-    if (!(obj = get_icon_ptr( hOldCursor ))) return 0;
+    if (!(obj = get_icon_ptr( old_cursor ))) return 0;
     release_user_handle_ptr( obj );
-    return hOldCursor;
+    return old_cursor;
 }
 
 /***********************************************************************
diff --git a/server/protocol.def b/server/protocol.def
index f998cfdd1fc..bb0cf8954d4 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -824,6 +824,7 @@ struct shared_cursor
     int                  y;
     unsigned int         last_change;      /* time of last position change */
     rectangle_t          clip;             /* cursor clip rectangle */
+    user_handle_t        handle;           /* current cursor handle */
 };
 
 struct desktop_shared_memory
diff --git a/server/queue.c b/server/queue.c
index c4f00877b19..eba71cb5849 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -477,7 +477,7 @@ static int update_desktop_cursor_pos( struct desktop *desktop, user_handle_t win
 
     if (win != desktop->cursor_win)
     {
-        post_desktop_message( desktop, desktop->cursor_change_msg, win, desktop->cursor_handle );
+        post_desktop_message( desktop, desktop->cursor_change_msg, win, desktop->shared->cursor.handle );
         updated = 1;
     }
     desktop->cursor_win = win;
@@ -487,9 +487,12 @@ static int update_desktop_cursor_pos( struct desktop *desktop, user_handle_t win
 
 static void update_desktop_cursor_handle( struct desktop *desktop, user_handle_t handle )
 {
-    if (desktop->cursor_change_msg && desktop->cursor_handle != handle)
+    if (desktop->cursor_change_msg && desktop->shared->cursor.handle != handle)
         post_desktop_message( desktop, desktop->cursor_change_msg, desktop->cursor_win, handle );
-    desktop->cursor_handle = handle;
+
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->cursor.handle = handle;
+    SHARED_WRITE_END( &desktop->shared->seq );
 }
 
 /* set the cursor position and queue the corresponding mouse message */
diff --git a/server/user.h b/server/user.h
index 1c0b70f8ce9..15661ff6631 100644
--- a/server/user.h
+++ b/server/user.h
@@ -68,7 +68,6 @@ struct desktop
     unsigned int                           cursor_clip_msg;  /* message to post for cursor clip changes */
     unsigned int                           cursor_change_msg;/* message to post for cursor win / handle changes */
     user_handle_t                          cursor_win;       /* window that contains the cursor */
-    user_handle_t                          cursor_handle;    /* current cursor handle */
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
     unsigned int                           last_press_alt:1; /* last key press was Alt (used to determine msg on Alt release) */

