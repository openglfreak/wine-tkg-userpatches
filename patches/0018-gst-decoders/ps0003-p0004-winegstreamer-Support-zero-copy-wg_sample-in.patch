From 02bb2a31fdacbde65240e70c24053a4ecd84b849 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 8 Jun 2022 11:01:26 +0200
Subject: [PATCH 04/30] winegstreamer: Support zero-copy wg_sample in
 wg_parser_push_data.

---
 dlls/winegstreamer/gst_private.h    |  6 +++++-
 dlls/winegstreamer/main.c           | 11 ++++++++--
 dlls/winegstreamer/media_source.c   | 12 +++++++++--
 dlls/winegstreamer/quartz_parser.c  | 31 +++++++++++++++++++++++++++--
 dlls/winegstreamer/wg_parser.c      | 22 +++++++++++++-------
 dlls/winegstreamer/wg_sample.c      |  4 ++--
 dlls/winegstreamer/wm_asyncreader.c |  7 +++++++
 dlls/winegstreamer/wm_reader.c      |  4 ++--
 dlls/winegstreamer/wm_syncreader.c  |  7 +++++++
 9 files changed, 86 insertions(+), 18 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -77,7 +77,8 @@ HRESULT wg_parser_connect(struct wg_parser *parser, uint64_t file_size);
 void wg_parser_disconnect(struct wg_parser *parser);
 
 bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset, uint32_t *size);
-void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample);
+void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample,
+        struct wg_sample_queue *queue);
 
 uint32_t wg_parser_get_stream_count(struct wg_parser *parser);
 struct wg_parser_stream *wg_parser_get_stream(struct wg_parser *parser, uint32_t index);
@@ -130,6 +131,8 @@ HRESULT wg_sample_create_raw(UINT32 size, struct wg_sample **out);
 HRESULT wg_sample_create_mf(IMFSample *sample, struct wg_sample **out);
 HRESULT wg_sample_create_quartz(IMediaSample *sample, struct wg_sample **out);
 void wg_sample_release(struct wg_sample *wg_sample);
+void wg_sample_queue_begin_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample);
+void wg_sample_queue_end_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample);
 
 HRESULT wg_transform_push_mf(struct wg_transform *transform, struct wg_sample *sample,
         struct wg_sample_queue *queue);
@@ -178,6 +181,7 @@ struct wm_reader
     HANDLE read_thread;
     bool read_thread_shutdown;
     struct wg_parser *wg_parser;
+    struct wg_sample_queue *wg_sample_queue;
 
     struct wm_stream *streams;
     WORD stream_count;
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -123,7 +123,8 @@ bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset,
     return true;
 }
 
-void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample)
+void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample,
+        struct wg_sample_queue *queue)
 {
     struct wg_parser_push_data_params params =
     {
@@ -131,9 +132,15 @@ void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample)
         .sample = sample,
     };
 
-    TRACE("parser %p, sample %p.\n", parser, sample);
+    TRACE("parser %p, sample %p, queue %p.\n", parser, sample, queue);
+
+    if (sample)
+        wg_sample_queue_begin_append(queue, sample);
 
     __wine_unix_call(unix_handle, unix_wg_parser_push_data, &params);
+
+    if (sample)
+        wg_sample_queue_end_append(queue, sample);
 }
 
 uint32_t wg_parser_get_stream_count(struct wg_parser *parser)
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -93,6 +93,7 @@ struct media_source
     IMFByteStream *byte_stream;
 
     struct wg_parser *wg_parser;
+    struct wg_sample_queue *wg_sample_queue;
 
     struct media_stream **streams;
     ULONG stream_count;
@@ -575,6 +576,8 @@ static HRESULT WINAPI source_async_commands_Invoke(IMFAsyncCallback *iface, IMFA
                 enqueue_token(command->u.request_sample.stream, command->u.request_sample.token);
             else
                 wait_on_sample(command->u.request_sample.stream, command->u.request_sample.token);
+
+            wg_sample_queue_flush(source->wg_sample_queue, false);
             break;
     }
 
@@ -641,8 +644,7 @@ static DWORD CALLBACK read_thread(void *arg)
         }
 
         wg_sample->size = size;
-        wg_parser_push_data(source->wg_parser, wg_sample);
-        wg_sample_release(wg_sample);
+        wg_parser_push_data(source->wg_parser, wg_sample, source->wg_sample_queue);
     }
 
     TRACE("Media source is shutting down; exiting.\n");
@@ -1349,6 +1351,7 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
     }
 
     wg_parser_destroy(source->wg_parser);
+    wg_sample_queue_destroy(source->wg_sample_queue);
 
     free(source->streams);
 
@@ -1403,6 +1406,11 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
     object->IMFGetService_iface.lpVtbl = &media_source_get_service_vtbl;
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -51,6 +51,7 @@ struct parser
     BOOL enum_sink_first;
 
     struct wg_parser *wg_parser;
+    struct wg_sample_queue *wg_sample_queue;
 
     /* FIXME: It would be nice to avoid duplicating these with strmbase.
      * However, synchronization is tricky; we need access to be protected by a
@@ -859,6 +860,8 @@ static DWORD CALLBACK stream_thread(void *arg)
         }
 
         LeaveCriticalSection(&pin->flushing_cs);
+
+        wg_sample_queue_flush(filter->wg_sample_queue, false);
     }
 
     TRACE("Streaming stopped; exiting.\n");
@@ -900,8 +903,7 @@ static DWORD CALLBACK read_thread(void *arg)
         }
 
         wg_sample->size = size;
-        wg_parser_push_data(filter->wg_parser, wg_sample);
-        wg_sample_release(wg_sample);
+        wg_parser_push_data(filter->wg_parser, wg_sample, filter->wg_sample_queue);
     }
 
     TRACE("Streaming stopped; exiting.\n");
@@ -953,6 +955,7 @@ static void parser_destroy(struct strmbase_filter *iface)
     filter->reader = NULL;
 
     wg_parser_destroy(filter->wg_parser);
+    wg_sample_queue_destroy(filter->wg_sample_queue);
 
     strmbase_sink_cleanup(&filter->sink);
     strmbase_filter_cleanup(&filter->filter);
@@ -1212,12 +1215,18 @@ static BOOL parser_init_gstreamer(void)
 HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out)
 {
     struct parser *object;
+    HRESULT hr;
 
     if (!parser_init_gstreamer())
         return E_FAIL;
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     if (!(object->wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, false)))
     {
@@ -1732,12 +1741,18 @@ static HRESULT wave_parser_source_get_media_type(struct parser_source *pin,
 HRESULT wave_parser_create(IUnknown *outer, IUnknown **out)
 {
     struct parser *object;
+    HRESULT hr;
 
     if (!parser_init_gstreamer())
         return E_FAIL;
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     if (!(object->wg_parser = wg_parser_create(WG_PARSER_WAVPARSE, false)))
     {
@@ -1818,12 +1833,18 @@ static HRESULT avi_splitter_source_get_media_type(struct parser_source *pin,
 HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out)
 {
     struct parser *object;
+    HRESULT hr;
 
     if (!parser_init_gstreamer())
         return E_FAIL;
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     if (!(object->wg_parser = wg_parser_create(WG_PARSER_AVIDEMUX, false)))
     {
@@ -1925,12 +1946,18 @@ static const struct strmbase_filter_ops mpeg_splitter_ops =
 HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out)
 {
     struct parser *object;
+    HRESULT hr;
 
     if (!parser_init_gstreamer())
         return E_FAIL;
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     if (!(object->wg_parser = wg_parser_create(WG_PARSER_MPEGAUDIOPARSE, false)))
     {
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -149,6 +149,13 @@ static NTSTATUS wg_parser_get_next_read_offset(void *args)
     return S_OK;
 }
 
+static void wg_sample_free_notify(void *arg)
+{
+    struct wg_sample *sample = arg;
+    GST_DEBUG("Releasing wg_sample %p", sample);
+    InterlockedDecrement(&sample->refcount);
+}
+
 static NTSTATUS wg_parser_push_data(void *args)
 {
     const struct wg_parser_push_data_params *params = args;
@@ -161,15 +168,16 @@ static NTSTATUS wg_parser_push_data(void *args)
         result = GST_FLOW_ERROR;
     else if (!sample->size)
         result = GST_FLOW_EOS;
+    else if (!(buffer = gst_buffer_new_wrapped_full(GST_MEMORY_FLAG_READONLY, sample->data, sample->max_size,
+            0, sample->size, sample, wg_sample_free_notify)))
+    {
+        GST_ERROR("Failed to allocate input buffer");
+        return E_OUTOFMEMORY;
+    }
     else
     {
-        if (!(buffer = gst_buffer_new_and_alloc(sample->size)))
-        {
-            GST_ERROR("Failed to allocate input buffer");
-            return STATUS_NO_MEMORY;
-        }
-        gst_buffer_fill(buffer, 0, sample->data, sample->size);
-        GST_INFO("Copied %u bytes from sample %p to buffer %p", sample->size, sample, buffer);
+        InterlockedIncrement(&sample->refcount);
+        GST_INFO("Wrapped %u/%u bytes from sample %p to buffer %p", sample->size, sample->max_size, sample, buffer);
     }
 
     pthread_mutex_lock(&parser->mutex);
diff --git a/dlls/winegstreamer/wg_sample.c b/dlls/winegstreamer/wg_sample.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_sample.c
+++ b/dlls/winegstreamer/wg_sample.c
@@ -215,7 +215,7 @@ void wg_sample_release(struct wg_sample *wg_sample)
     free(sample);
 }
 
-static void wg_sample_queue_begin_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample)
+void wg_sample_queue_begin_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample)
 {
     struct sample *sample = CONTAINING_RECORD(wg_sample, struct sample, wg_sample);
 
@@ -227,7 +227,7 @@ static void wg_sample_queue_begin_append(struct wg_sample_queue *queue, struct w
     LeaveCriticalSection(&queue->cs);
 }
 
-static void wg_sample_queue_end_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample)
+void wg_sample_queue_end_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample)
 {
     /* release temporary ref taken in wg_sample_queue_begin_append */
     InterlockedDecrement(&wg_sample->refcount);
diff --git a/dlls/winegstreamer/wm_asyncreader.c b/dlls/winegstreamer/wm_asyncreader.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wm_asyncreader.c
+++ b/dlls/winegstreamer/wm_asyncreader.c
@@ -1600,6 +1600,7 @@ static void async_reader_destroy(struct wm_reader *iface)
         IWMReaderCallback_Release(reader->callback);
 
     wm_reader_cleanup(&reader->reader);
+    wg_sample_queue_destroy(reader->reader.wg_sample_queue);
     free(reader);
 }
 
@@ -1612,11 +1613,17 @@ static const struct wm_reader_ops async_reader_ops =
 HRESULT WINAPI winegstreamer_create_wm_async_reader(IWMReader **reader)
 {
     struct async_reader *object;
+    HRESULT hr;
 
     TRACE("reader %p.\n", reader);
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->reader.wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     wm_reader_init(&object->reader, &async_reader_ops);
 
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -599,8 +599,7 @@ static DWORD CALLBACK read_thread(void *arg)
         }
 
         wg_sample->size = size;
-        wg_parser_push_data(reader->wg_parser, wg_sample);
-        wg_sample_release(wg_sample);
+        wg_parser_push_data(reader->wg_parser, wg_sample, reader->wg_sample_queue);
     }
 
     TRACE("Reader is shutting down; exiting.\n");
@@ -1970,6 +1969,7 @@ HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number
             ERR("Failed to set size %u, hr %#lx.\n", wg_buffer.size, hr);
 
         wg_parser_stream_release_buffer(wg_stream);
+        wg_sample_queue_flush(reader->wg_sample_queue, false);
 
         if (!wg_buffer.has_pts)
             FIXME("Missing PTS.\n");
diff --git a/dlls/winegstreamer/wm_syncreader.c b/dlls/winegstreamer/wm_syncreader.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wm_syncreader.c
+++ b/dlls/winegstreamer/wm_syncreader.c
@@ -389,6 +389,7 @@ static void sync_reader_destroy(struct wm_reader *iface)
 
     wm_reader_close(&reader->reader);
     wm_reader_cleanup(&reader->reader);
+    wg_sample_queue_destroy(reader->reader.wg_sample_queue);
     free(reader);
 }
 
@@ -401,11 +402,17 @@ static const struct wm_reader_ops sync_reader_ops =
 HRESULT WINAPI winegstreamer_create_wm_sync_reader(IWMSyncReader **reader)
 {
     struct sync_reader *object;
+    HRESULT hr;
 
     TRACE("reader %p.\n", reader);
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
+    if (FAILED(hr = wg_sample_queue_create(&object->reader.wg_sample_queue)))
+    {
+        free(object);
+        return hr;
+    }
 
     wm_reader_init(&object->reader, &sync_reader_ops);
 
-- 
2.37.1

