From: Jacek Caban <jacek@codeweavers.com>
Subject: [PATCH 1/3] ntdll: Introduce syscall_exit_full_restore and use it when x86_64 syscall frame is modified.
Message-Id: <77bce83b-99a7-e760-bcfd-8af50524b720@codeweavers.com>
Date: Thu, 3 Jun 2021 15:01:43 +0200

Signed-off-by: Jacek Caban <jacek@codeweavers.com>
---
This patch series makes syscall dispatcher overhead over 2.5 smaller in 
my testing. It will matter more than now when we will use syscall 
interface for other modules like winepulse does.

The last patch is may be a bit controversial because is makes us less 
compatible with Windows (through I'm not aware of an application 
depending on that). If we don't want that, we could potentially 
introduce 'fast path' only for __wine_unix_call syscall. Such 
specialized fast path could probably also skip xsave, but I'm not sure 
that's worth it (and having proper ntdll syscalls faster is nice anyway).

  dlls/ntdll/unix/signal_x86_64.c | 124 ++++++++++++++++++++------------
  tools/winebuild/import.c        |   6 +-
  2 files changed, 84 insertions(+), 46 deletions(-)

diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 59c030ae6a4..c67618163bf 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -281,34 +281,35 @@ C_ASSERT( sizeof(struct syscall_xsave) == 0x340 );
 
 struct syscall_frame
 {
-    ULONG64               rax;     /* 0000 */
-    ULONG64               rbx;     /* 0008 */
-    ULONG64               rcx;     /* 0010 */
-    ULONG64               rdx;     /* 0018 */
-    ULONG64               rsi;     /* 0020 */
-    ULONG64               rdi;     /* 0028 */
-    ULONG64               r8;      /* 0030 */
-    ULONG64               r9;      /* 0038 */
-    ULONG64               r10;     /* 0040 */
-    ULONG64               r11;     /* 0048 */
-    ULONG64               r12;     /* 0050 */
-    ULONG64               r13;     /* 0058 */
-    ULONG64               r14;     /* 0060 */
-    ULONG64               r15;     /* 0068 */
-    ULONG64               rip;     /* 0070 */
-    WORD                  cs;      /* 0078 */
-    WORD                  ds;      /* 007a */
-    WORD                  es;      /* 007c */
-    WORD                  fs;      /* 007e */
-    ULONG64               eflags;  /* 0080 */
-    ULONG64               rsp;     /* 0088 */
-    WORD                  ss;      /* 0090 */
-    WORD                  gs;      /* 0092 */
-    WORD                  pad[2];  /* 0094 */
-    ULONG64               rbp;     /* 0098 */
+    void                **ret_addr;  /* 0000 */
+    ULONG64               rax;       /* 0008 */
+    ULONG64               rbx;       /* 0010 */
+    ULONG64               rcx;       /* 0018 */
+    ULONG64               rdx;       /* 0020 */
+    ULONG64               rsi;       /* 0028 */
+    ULONG64               rdi;       /* 0030 */
+    ULONG64               r8;        /* 0038 */
+    ULONG64               r9;        /* 0040 */
+    ULONG64               r10;       /* 0048 */
+    ULONG64               r11;       /* 0050 */
+    ULONG64               r12;       /* 0058 */
+    ULONG64               r13;       /* 0060 */
+    ULONG64               r14;       /* 0068 */
+    ULONG64               r15;       /* 0070 */
+    ULONG64               rip;       /* 0078 */
+    WORD                  cs;        /* 0080 */
+    WORD                  ds;        /* 0082 */
+    WORD                  es;        /* 0084 */
+    WORD                  fs;        /* 0086 */
+    ULONG64               eflags;    /* 0088 */
+    ULONG64               rsp;       /* 0090 */
+    WORD                  ss;        /* 0098 */
+    WORD                  gs;        /* 009a */
+    WORD                  pad[2];    /* 009c */
+    ULONG64               rbp;       /* 00a0 */
 };
 
-C_ASSERT( sizeof( struct syscall_frame ) == 0xa0);
+C_ASSERT( sizeof( struct syscall_frame ) == 0xa8);
 
 struct amd64_thread_data
 {
@@ -1568,22 +1569,22 @@ __ASM_GLOBAL_FUNC( set_full_cpu_context,
                    "movq %gs:0x30,%rdx\n\t"
                    "movq 0x328(%rdx),%rsp\n\t"      /* amd64_thread_data()->syscall_frame */
                    "movq $0,0x328(%rdx)\n\t"
-                   "movq 0x00(%rsp),%rax\n\t"
-                   "movq 0x08(%rsp),%rbx\n\t"
-                   "movq 0x10(%rsp),%rcx\n\t"
-                   "movq 0x18(%rsp),%rdx\n\t"
-                   "movq 0x20(%rsp),%rsi\n\t"
-                   "movq 0x28(%rsp),%rdi\n\t"
-                   "movq 0x30(%rsp),%r8\n\t"
-                   "movq 0x38(%rsp),%r9\n\t"
-                   "movq 0x40(%rsp),%r10\n\t"
-                   "movq 0x48(%rsp),%r11\n\t"
-                   "movq 0x50(%rsp),%r12\n\t"
-                   "movq 0x58(%rsp),%r13\n\t"
-                   "movq 0x60(%rsp),%r14\n\t"
-                   "movq 0x68(%rsp),%r15\n\t"
-                   "movq 0x98(%rsp),%rbp\n\t"
-                   "leaq 0x70(%rsp),%rsp\n\t"
+                   "movq 0x08(%rsp),%rax\n\t"
+                   "movq 0x10(%rsp),%rbx\n\t"
+                   "movq 0x18(%rsp),%rcx\n\t"
+                   "movq 0x20(%rsp),%rdx\n\t"
+                   "movq 0x28(%rsp),%rsi\n\t"
+                   "movq 0x30(%rsp),%rdi\n\t"
+                   "movq 0x38(%rsp),%r8\n\t"
+                   "movq 0x40(%rsp),%r9\n\t"
+                   "movq 0x48(%rsp),%r10\n\t"
+                   "movq 0x50(%rsp),%r11\n\t"
+                   "movq 0x58(%rsp),%r12\n\t"
+                   "movq 0x60(%rsp),%r13\n\t"
+                   "movq 0x68(%rsp),%r14\n\t"
+                   "movq 0x70(%rsp),%r15\n\t"
+                   "movq 0xa0(%rsp),%rbp\n\t"
+                   "leaq 0x78(%rsp),%rsp\n\t"
                    "iretq" )
 
 /***********************************************************************
@@ -1607,6 +1608,33 @@ void signal_restore_full_cpu_context(void)
 }
 
 
+/***********************************************************************
+ *              syscall_exit_full_restore
+ *
+ * Set syscall result in frame and initiate full restore
+ */
+extern void syscall_exit_full_restore(void) DECLSPEC_HIDDEN;
+__ASM_GLOBAL_FUNC( syscall_exit_full_restore,
+                   "movq %gs:0x30,%rcx\n\t"
+                   "movq 0x328(%rcx),%rcx\n\t" /* amd64_thread_data()->syscall_frame */
+                   "movq %rax,0x08(%rcx)\n\t"  /* set frame->rax */
+                   "xorq %rax,%rax\n\t"        /* reset volatile registers */
+                   "movq %rax,0x18(%rcx)\n\t"
+                   "movq %rax,0x20(%rcx)\n\t"
+                   "movq %rax,0x38(%rcx)\n\t"
+                   "movq %rax,0x40(%rcx)\n\t"
+                   "movq %rax,0x48(%rcx)\n\t"
+                   "movq %rax,0x50(%rcx)\n\t"
+                   "call " __ASM_NAME("signal_restore_full_cpu_context") "\n\t" )
+
+
+/* replace syscall handler return address with syscall_exit_full_restore */
+static void setup_syscall_exit_full_restore( struct syscall_frame *frame )
+{
+    *frame->ret_addr = syscall_exit_full_restore;
+}
+
+
 /***********************************************************************
  *              NtSetContextThread  (NTDLL.@)
  *              ZwSetContextThread  (NTDLL.@)
@@ -1616,6 +1644,7 @@ NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
     NTSTATUS ret = STATUS_SUCCESS;
     DWORD flags = context->ContextFlags & ~CONTEXT_AMD64;
     BOOL self = (handle == GetCurrentThread());
+    BOOL full_restore = FALSE;
     struct syscall_frame *frame;
     struct syscall_xsave *xsave;
     XSTATE *xs;
@@ -1671,6 +1700,7 @@ NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
         frame->eflags = context->EFlags;
         frame->cs     = context->SegCs;
         frame->ss     = context->SegSs;
+        full_restore  = TRUE;
     }
     if (flags & CONTEXT_SEGMENTS)
     {
@@ -1683,6 +1713,7 @@ NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
     {
         xsave->xsave = context->u.FltSave;
         xsave->xstate.Mask |= XSTATE_MASK_LEGACY;
+        full_restore = TRUE;
     }
     if ((cpu_info.ProcessorFeatureBits & CPU_FEATURE_AVX) && (xs = xstate_from_context( context )))
     {
@@ -1702,7 +1733,10 @@ NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
         }
         else
             xsave->xstate.Mask &= ~XSTATE_MASK_GSSE;
+        full_restore = TRUE;
     }
+
+    if (full_restore) setup_syscall_exit_full_restore( frame );
     return STATUS_SUCCESS;
 }
 
@@ -1992,7 +2026,7 @@ __ASM_GLOBAL_FUNC( call_user_apc_dispatcher,
                    "movq 0x98(%rcx),%rdx\n\t"        /* context->Rsp */
                    "jmp 2f\n\t"
                    "1:\tmovq 0x328(%rbx),%rax\n\t"   /* amd64_thread_data()->syscall_frame */
-                   "movq 0x88(%rax),%rdx\n\t"        /* frame->rsp */
+                   "movq 0x90(%rax),%rdx\n\t"        /* frame->rsp */
                    "2:\tsubq $0x510,%rdx\n\t"        /* sizeof(struct apc_stack_layout) */
                    "andq $~0xf,%rdx\n\t"
                    "addq $8,%rsp\n\t"                /* pop return address */
@@ -2036,7 +2070,9 @@ __ASM_GLOBAL_FUNC( call_user_apc_dispatcher,
  */
 void WINAPI call_raise_user_exception_dispatcher( NTSTATUS (WINAPI *dispatcher)(void) )
 {
-    amd64_thread_data()->syscall_frame->rip = (UINT64)dispatcher;
+    struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
+    frame->rip = (UINT64)dispatcher;
+    setup_syscall_exit_full_restore( frame );
 }
 
 
diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
index 3acf720e1c6..472eeba0491 100644
--- a/tools/winebuild/import.c
+++ b/tools/winebuild/import.c
@@ -1588,7 +1588,7 @@ static void output_syscall_dispatcher(void)
         output_cfi( ".cfi_def_cfa_register %%rbp" );
         output( "\tleaq -0x10(%%rbp),%%rsp\n" );
         output( "\tpushfq\n" );
-        output( "\tsubq $0x3c0,%%rsp\n" );
+        output( "\tsubq $0x3c8,%%rsp\n" );
         output( "\tandq $~63,%%rsp\n" );
         output( "\tmovq %%rbx,-0x90(%%rbp)\n" );
         output_cfi( ".cfi_rel_offset %%rbx,-144" );
@@ -1640,7 +1640,7 @@ static void output_syscall_dispatcher(void)
         output( "\tjmp 3f\n" );
         output( "2:\tfxsave64 (%%r12)\n" );
         output( "3:\tmovq %%gs:0x30,%%rcx\n" );
-        output( "\tleaq -0x98(%%rbp),%%rbx\n" );
+        output( "\tleaq -0xa0(%%rbp),%%rbx\n" );
         output( "\tmovq %%rbx,0x328(%%rcx)\n" );  /* amd64_thread_data()->syscall_frame */
         output( "\tmovq %%r13,%%rbx\n" );
         output( "\tshrl $8,%%ebx\n" );
@@ -1663,6 +1663,8 @@ static void output_syscall_dispatcher(void)
         output( "\trep; movsq\n" );
         output( "1:\tmovq %%r10,%%rcx\n" );
         output( "\tsubq $0x20,%%rsp\n" );
+        output( "\tleaq -8(%%rsp),%%rax\n" );
+        output( "\tmovq %%rax,-0xa0(%%rbp)\n" ); /* frame->ret_addr */
         output( "\tmovq (%%rbx),%%r10\n" );      /* table->ServiceTable */
         output( "\tcallq *(%%r10,%%r13,8)\n" );
         output( "2:\tmovq %%gs:0x30,%%rcx\n" );

