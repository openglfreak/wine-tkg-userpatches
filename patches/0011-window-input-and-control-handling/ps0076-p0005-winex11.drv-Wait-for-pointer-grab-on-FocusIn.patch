From 8868a7eb937ec4cfb14956257a553f4829960c9d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 19 Sep 2019 15:42:09 +0200
Subject: [PATCH 5/8] winex11.drv: Wait for pointer grab on
 FocusIn/WM_TAKE_FOCUS events.

The FocusIn/WM_TAKE_FOCUS events are received as soon as a window is
clicked, but when some modifier key is pressed or when the click is on
the window frame, the WM may still be controlling the window size or
position. It usually grabs the cursor while doing so - and if not then
there's apparently nothing we can do.

When using undecorated mode we handle this case "correctly" by going
through the corresponding Windows non-client message loop until mouse
buttons are released, but when using decorated windows the window
decoration is empty from the Wine perspective and any window event is
considered as happening in the client area.

This leads to some issues when the window is moved or resized, with
applications applying clipping rectangles immediately and not updating
it on subsequent window move/resize messages. Delaying the WM_ACTIVATE
until the WM releases its grab and the window move is complete helps
solving this situation.

This delay is implemented here by resending the FocusIn/WM_TAKE_FOCUS
events to the window until the cursor can be grabbed and then processing
them normally.
---
 dlls/winex11.drv/event.c  | 42 +++++++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/window.c |  2 ++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 110c3342696..256a22c5f0a 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -316,6 +316,24 @@ static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawE
 }
 #endif
 
+static int try_grab_pointer( Display *display )
+{
+    if (!grab_pointer)
+        return 1;
+
+    /* if we are already clipping the cursor in the current thread, we should not
+     * call XGrabPointer here or it would change the confine-to window. */
+    if (clipping_cursor)
+        return 1;
+
+    if (XGrabPointer( display, root_window, False, 0, GrabModeAsync, GrabModeAsync,
+                      None, None, CurrentTime ) != GrabSuccess)
+        return 0;
+
+    XUngrabPointer( display, CurrentTime );
+    return 1;
+}
+
 /***********************************************************************
  *           merge_events
  *
@@ -616,8 +634,18 @@ static void set_focus( XEvent *xev, HWND hwnd, Time time )
     /* prevent recursion */
     x11drv_thread_data()->active_window = hwnd;
 
-    TRACE( "setting foreground window to %p\n", hwnd );
-    SetForegroundWindow( hwnd );
+    if (!try_grab_pointer( xev->xany.display ))
+    {
+        /* ask the desktop window to release its grab before trying to get ours */
+        SendMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_RELEASE_CURSOR, 0, 0 );
+        XSendEvent( xev->xany.display, xev->xany.window, False, 0, xev );
+        return;
+    }
+    else
+    {
+        TRACE( "setting foreground window to %p\n", hwnd );
+        SetForegroundWindow( hwnd );
+    }
 
     /* Some applications expect that a being deactivated topmost window
      * receives the WM_WINDOWPOSCHANGING/WM_WINDOWPOSCHANGED messages,
@@ -817,6 +845,14 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
 
     x11drv_thread_data()->keymapnotify_hwnd = hwnd;
 
+    if (!try_grab_pointer( event->display ))
+    {
+        /* ask the desktop window to release its grab before trying to get ours */
+        SendMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_RELEASE_CURSOR, 0, 0 );
+        XSendEvent( event->display, event->window, False, 0, xev );
+        return FALSE;
+    }
+
     switch (event->mode)
     {
     case NotifyGrab:
@@ -948,6 +984,8 @@ static BOOL X11DRV_FocusOut( HWND hwnd, XEvent *xev )
         break;
     }
 
+    if (hwnd == GetForegroundWindow()) SendNotifyMessageW( GetDesktopWindow(), WM_X11DRV_DESKTOP_RELEASE_CURSOR, 0, 0 );
+
     /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
     if (event->mode == NotifyGrab || event->mode == NotifyUngrab) return FALSE;
 
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index c0d48b35f95..49bc7919a7e 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -3246,6 +3246,8 @@ LRESULT CDECL X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
         return 0;
     case WM_X11DRV_ADD_TAB:
         taskbar_add_tab( hwnd );
+    case WM_X11DRV_DESKTOP_RELEASE_CURSOR:
+        ungrab_clipping_window();
         return 0;
     case WM_X11DRV_DROPEVENT:
         X11DRV_XDND_DropEventProcess( hwnd );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index d666033b961..43a948ca7a8 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -614,6 +614,7 @@ enum x11drv_window_messages
     WM_X11DRV_DELETE_TAB,
     WM_X11DRV_ADD_TAB,
     WM_X11DRV_DROPEVENT,
+    WM_X11DRV_DESKTOP_RELEASE_CURSOR,
 };
 
 /* _NET_WM_STATE properties that we keep track of */
-- 
2.35.1

