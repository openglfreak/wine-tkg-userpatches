From 6548a0e18a0358a0f4d0ffe60cd480c84d608c1f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 6 Jun 2022 20:53:57 +0200
Subject: [PATCH 06/30] winegstreamer: Use a GstAtomicQueue to keep parser
 requests.

---
 dlls/winegstreamer/wg_parser.c | 94 ++++++++++++++++++++++------------
 1 file changed, 61 insertions(+), 33 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -56,6 +56,14 @@ GST_DEBUG_CATEGORY(wine);
 
 typedef BOOL (*init_gst_cb)(struct wg_parser *parser);
 
+struct request_entry
+{
+    struct wg_request request;
+    GstFlowReturn result;
+    GstBuffer *buffer;
+    bool done;
+};
+
 struct wg_parser
 {
     init_gst_cb init_gst;
@@ -77,15 +85,9 @@ struct wg_parser
     pthread_cond_t init_cond;
     bool no_more_pads, has_duration, error;
 
-    pthread_cond_t request_cond, read_done_cond;
-    struct
-    {
-        GstBuffer *buffer;
-        uint64_t offset;
-        uint32_t size;
-        bool done;
-        GstFlowReturn ret;
-    } read_request;
+    GstAtomicQueue *request_queue;
+    struct request_entry *request;
+    pthread_cond_t request_cond, request_done_cond;
 
     bool sink_connected;
 
@@ -130,21 +132,29 @@ static NTSTATUS wg_parser_wait_request(void *args)
 {
     struct wg_parser_wait_request_params *params = args;
     struct wg_parser *parser = params->parser;
+    struct request_entry *entry;
 
     pthread_mutex_lock(&parser->mutex);
+    assert(!parser->request);
 
-    while (parser->sink_connected && !parser->read_request.size)
+    while (!(entry = gst_atomic_queue_pop(parser->request_queue)) && parser->sink_connected)
         pthread_cond_wait(&parser->request_cond, &parser->mutex);
 
-    if (!parser->sink_connected)
+    if (!(parser->request = entry))
     {
         pthread_mutex_unlock(&parser->mutex);
         return VFW_E_WRONG_STATE;
     }
 
-    params->request.type = WG_REQUEST_READ;
-    params->request.u.read.offset = parser->read_request.offset;
-    params->request.u.read.size = parser->read_request.size;
+    switch ((params->request.type = entry->request.type))
+    {
+        case WG_REQUEST_NONE:
+            GST_ERROR("Unexpected request type!");
+            break;
+        case WG_REQUEST_READ:
+            params->request.u.read = entry->request.u.read;
+            break;
+    }
 
     pthread_mutex_unlock(&parser->mutex);
     return S_OK;
@@ -183,13 +193,13 @@ static NTSTATUS wg_parser_push_data(void *args)
 
     pthread_mutex_lock(&parser->mutex);
 
-    parser->read_request.buffer = buffer;
-    parser->read_request.ret = result;
-    parser->read_request.done = true;
-    parser->read_request.size = 0;
+    parser->request->result = result;
+    parser->request->buffer = buffer;
+    parser->request->done = true;
+    parser->request = NULL;
 
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->read_done_cond);
+    pthread_cond_signal(&parser->request_done_cond);
 
     return S_OK;
 }
@@ -875,7 +885,8 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
         guint64 offset, guint size, GstBuffer **buffer)
 {
     struct wg_parser *parser = gst_pad_get_element_private(pad);
-    GstFlowReturn ret;
+    struct request_entry *entry;
+    GstFlowReturn result;
 
     GST_LOG("pad %p, offset %" G_GINT64_MODIFIER "u, size %u, buffer %p.", pad, offset, size, *buffer);
 
@@ -894,30 +905,34 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
         return GST_FLOW_OK;
     }
 
+    if (!(entry = calloc(1, sizeof(struct request_entry))))
+        return GST_FLOW_ERROR;
+
     pthread_mutex_lock(&parser->mutex);
 
-    assert(!parser->read_request.size);
-    parser->read_request.offset = offset;
-    parser->read_request.size = size;
-    parser->read_request.done = false;
+    entry->request.type = WG_REQUEST_READ;
+    entry->request.u.read.offset = offset;
+    entry->request.u.read.size = size;
+    gst_atomic_queue_push(parser->request_queue, entry);
     pthread_cond_signal(&parser->request_cond);
 
     /* Note that we don't unblock this wait on GST_EVENT_FLUSH_START. We expect
      * the upstream pin to flush if necessary. We should never be blocked on
      * read_thread() not running. */
 
-    while (!parser->read_request.done)
-        pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
+    while (!entry->done)
+        pthread_cond_wait(&parser->request_done_cond, &parser->mutex);
 
-    *buffer = parser->read_request.buffer;
-    parser->read_request.buffer = NULL;
-    ret = parser->read_request.ret;
+    *buffer = entry->buffer;
+    result = entry->result;
 
     pthread_mutex_unlock(&parser->mutex);
 
-    GST_LOG("Request returned %s.", gst_flow_get_name(ret));
+    free(entry);
 
-    return ret;
+    GST_LOG("Request returned %s.", gst_flow_get_name(result));
+
+    return result;
 }
 
 static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
@@ -1347,6 +1362,7 @@ out:
 static NTSTATUS wg_parser_disconnect(void *args)
 {
     struct wg_parser *parser = args;
+    struct request_entry *entry;
     unsigned int i;
 
     /* Unblock all of our streams. */
@@ -1356,6 +1372,12 @@ static NTSTATUS wg_parser_disconnect(void *args)
         parser->streams[i]->flushing = true;
         pthread_cond_signal(&parser->streams[i]->event_empty_cond);
     }
+    while ((entry = gst_atomic_queue_pop(parser->request_queue)))
+    {
+        entry->result = GST_FLOW_ERROR;
+        entry->done = true;
+    }
+    pthread_cond_signal(&parser->request_done_cond);
     pthread_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
@@ -1565,11 +1587,16 @@ static NTSTATUS wg_parser_create(void *args)
 
     if (!(parser = calloc(1, sizeof(*parser))))
         return E_OUTOFMEMORY;
+    if (!(parser->request_queue = gst_atomic_queue_new(8)))
+    {
+        free(parser);
+        return E_OUTOFMEMORY;
+    }
 
     pthread_mutex_init(&parser->mutex, NULL);
     pthread_cond_init(&parser->init_cond, NULL);
     pthread_cond_init(&parser->request_cond, NULL);
-    pthread_cond_init(&parser->read_done_cond, NULL);
+    pthread_cond_init(&parser->request_done_cond, NULL);
     parser->init_gst = init_funcs[params->type];
     parser->unlimited_buffering = params->unlimited_buffering;
 
@@ -1591,7 +1618,8 @@ static NTSTATUS wg_parser_destroy(void *args)
     pthread_mutex_destroy(&parser->mutex);
     pthread_cond_destroy(&parser->init_cond);
     pthread_cond_destroy(&parser->request_cond);
-    pthread_cond_destroy(&parser->read_done_cond);
+    pthread_cond_destroy(&parser->request_done_cond);
+    gst_atomic_queue_unref(parser->request_queue);
 
     free(parser);
     return S_OK;
-- 
2.37.1

