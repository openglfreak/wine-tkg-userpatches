From e8cccf634211844613c96b622a3ad826c19d92e9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:11:03 +0100
Subject: [PATCH 15/26] server: Add cursor handle and count to desktop shared
 memory.

---
 include/wine/server_protocol.h |  4 +++-
 server/protocol.def            |  2 ++
 server/queue.c                 | 44 ++++++++++++++++++++--------------
 3 files changed, 31 insertions(+), 19 deletions(-)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 9c63800121b..9e898968dc6 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -836,7 +836,9 @@ struct input_shared_memory
     user_handle_t        menu_owner;
     user_handle_t        move_size;
     user_handle_t        caret;
+    user_handle_t        cursor;
     rectangle_t          caret_rect;
+    int                  cursor_count;
 };
 
 
@@ -6782,7 +6784,7 @@ union generic_reply
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 705
+#define SERVER_PROTOCOL_VERSION 706
 
 /* ### protocol_version end ### */
 
diff --git a/server/protocol.def b/server/protocol.def
index e9be7472910..fbfdf25b2de 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -852,7 +852,9 @@ struct input_shared_memory
     user_handle_t        menu_owner;       /* handle to the menu owner */
     user_handle_t        move_size;        /* handle to the moving/resizing window */
     user_handle_t        caret;            /* handle to the caret window */
+    user_handle_t        cursor;           /* handle to the cursor */
     rectangle_t          caret_rect;       /* caret rectangle */
+    int                  cursor_count;     /* cursor show count */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 8be052ae93a..e47db3b0407 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -105,8 +105,6 @@ struct thread_input
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
     int                    caret_hide;    /* caret hide count */
     int                    caret_state;   /* caret on/off state */
-    user_handle_t          cursor;        /* current cursor */
-    int                    cursor_count;  /* cursor show count */
     struct list            msg_list;      /* list of hardware messages */
     unsigned char          keystate[256]; /* state of each key */
     struct object         *shared_mapping; /* thread input shared memory mapping */
@@ -311,8 +309,8 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->shared->active       = 0;
         input->shared->menu_owner   = 0;
         input->shared->move_size    = 0;
-        input->cursor       = 0;
-        input->cursor_count = 0;
+        input->shared->cursor       = 0;
+        input->shared->cursor_count = 0;
         input->lock_count   = 0;
         SHARED_WRITE_END( &input->shared->seq );
         list_init( &input->msg_list );
@@ -407,12 +405,16 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
     if (queue->input)
     {
         if (queue->keystate_locked) queue->input->lock_count--;
-        queue->input->cursor_count -= queue->cursor_count;
+        SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+        queue->input->shared->cursor_count -= queue->cursor_count;
+        SHARED_WRITE_END( &queue->input->shared->seq );
         release_object( queue->input );
         queue->keystate_locked = 0;
     }
     queue->input = (struct thread_input *)grab_object( new_input );
-    new_input->cursor_count += queue->cursor_count;
+    SHARED_WRITE_BEGIN( &new_input->shared->seq );
+    new_input->shared->cursor_count += queue->cursor_count;
+    SHARED_WRITE_END( &new_input->shared->seq );
 
     SHARED_WRITE_BEGIN( &queue->shared->seq );
     queue->shared->input_tid = queue->input->shared->tid;
@@ -1156,7 +1158,9 @@ static void msg_queue_destroy( struct object *obj )
     }
     if (queue->timeout) remove_timeout_user( queue->timeout );
     if (queue->keystate_locked) queue->input->lock_count--;
-    queue->input->cursor_count -= queue->cursor_count;
+    SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+    queue->input->shared->cursor_count -= queue->cursor_count;
+    SHARED_WRITE_END( &queue->input->shared->seq );
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
@@ -3201,8 +3205,8 @@ DECL_HANDLER(get_thread_input)
         reply->menu_owner = input->shared->menu_owner;
         reply->move_size  = input->shared->move_size;
         reply->caret      = input->shared->caret;
-        reply->cursor     = input->cursor;
-        reply->show_count = input->cursor_count;
+        reply->cursor     = input->shared->cursor;
+        reply->show_count = input->shared->cursor_count;
         reply->rect       = input->shared->caret_rect;
     }
 
@@ -3465,25 +3469,29 @@ DECL_HANDLER(set_cursor)
     if (!queue) return;
     input = queue->input;
 
-    reply->prev_handle = input->cursor;
-    reply->prev_count  = input->cursor_count;
+    reply->prev_handle = input->shared->cursor;
+    reply->prev_count  = input->shared->cursor_count;
     reply->prev_x      = input->desktop->shared->cursor.x;
     reply->prev_y      = input->desktop->shared->cursor.y;
 
+    if ((req->flags & SET_CURSOR_HANDLE) && req->handle &&
+        !get_user_object( req->handle, USER_CLIENT ))
+    {
+        set_win32_error( ERROR_INVALID_CURSOR_HANDLE );
+        return;
+    }
+
+    SHARED_WRITE_BEGIN( &input->shared->seq );
     if (req->flags & SET_CURSOR_HANDLE)
     {
-        if (req->handle && !get_user_object( req->handle, USER_CLIENT ))
-        {
-            set_win32_error( ERROR_INVALID_CURSOR_HANDLE );
-            return;
-        }
-        input->cursor = req->handle;
+        input->shared->cursor = req->handle;
     }
     if (req->flags & SET_CURSOR_COUNT)
     {
         queue->cursor_count += req->show_count;
-        input->cursor_count += req->show_count;
+        input->shared->cursor_count += req->show_count;
     }
+    SHARED_WRITE_END( &input->shared->seq );
     if (req->flags & SET_CURSOR_POS)
     {
         set_cursor_pos( input->desktop, req->x, req->y );

