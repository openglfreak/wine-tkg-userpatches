From d4b1060a8c51dabf2f7cb8284ab4046a42c49834 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 7 Mar 2021 16:58:10 +0100
Subject: [PATCH 16/17] fixup ntdll: Implement Low Fragmentation Heap.

---
 dlls/ntdll/heap_lfh.c | 97 +++++++++++++++++++++++--------------------
 1 file changed, 51 insertions(+), 46 deletions(-)

diff --git a/dlls/ntdll/heap_lfh.c b/dlls/ntdll/heap_lfh.c
index 3b7cf76f4ed..8f95b92561e 100644
--- a/dlls/ntdll/heap_lfh.c
+++ b/dlls/ntdll/heap_lfh.c
@@ -24,6 +24,14 @@
 #include "wine/list.h"
 #include "wine/debug.h"
 
+#if defined(__GNUC__) || defined(__clang__)
+#define likely(x) __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+#else
+#define likely(x) x
+#define unlikely(x) x
+#endif
+
 WINE_DEFAULT_DEBUG_CHANNEL(heap);
 
 typedef struct LFH_ptr LFH_ptr;
@@ -638,40 +646,37 @@ static void LFH_dump_heap(LFH_heap *heap)
         LFH_dump_class(heap, &heap->large_class[i]);
 }
 
-static BOOLEAN LFH_validate_block(ULONG flags, const LFH_block *block);
 static BOOLEAN LFH_validate_arena(ULONG flags, const LFH_arena *arena);
 static BOOLEAN LFH_validate_heap(ULONG flags, const LFH_heap *heap);
 
-static BOOLEAN LFH_validate_block(ULONG flags, const LFH_block *block)
+static inline BOOLEAN LFH_validate_block(ULONG flags, const LFH_block *block)
 {
     const LFH_arena *arena = LFH_arena_from_block(block);
     const LFH_arena *large_arena = LFH_large_arena_from_block(block);
     const LFH_arena *block_arena = LFH_block_arena_from_block(block);
+    const LFH_arena *arena_arena = LFH_large_arena_from_block(arena);
     const char *err = NULL;
 
-    if (flags & HEAP_VALIDATE)
+    if (unlikely(flags & HEAP_VALIDATE))
         return LFH_validate_arena(flags, arena);
 
-    if (!arena)
+    if (unlikely(!arena))
         err = "invalid arena";
-    else if (arena != LFH_large_arena_from_block(arena) &&
-             arena != (LFH_large_arena_from_block(arena) + 1))
+    else if (unlikely(arena != arena_arena && arena != (arena_arena + 1)))
         err = "invalid arena alignment";
-    else if (arena == block_arena)
+    else if (likely(arena == block_arena))
     {
-        if ((UINT_PTR)block < (UINT_PTR)block_arena + ARENA_HEADER_SIZE ||
-            ((UINT_PTR)block & (sizeof(*block) - 1)) != 0)
+        if (unlikely((UINT_PTR)block < (UINT_PTR)block_arena + ARENA_HEADER_SIZE))
+            err = "invalid block alignment";
+        if (unlikely(((UINT_PTR)block & (sizeof(*block) - 1))))
             err = "invalid block alignment";
     }
-    else
-    {
-        if (arena != large_arena)
-            err = "large/huge arena mismatch";
-        else if ((UINT_PTR)block != (UINT_PTR)block_arena)
-            err = "invalid block for large/huge arena";
-    }
+    else if (unlikely(arena != large_arena))
+        err = "large/huge arena mismatch";
+    else if (unlikely((UINT_PTR)block != (UINT_PTR)block_arena))
+        err = "invalid block for large/huge arena";
 
-    if (err) WARN("%08x %p: %s\n", flags, block, err);
+    if (unlikely(err)) WARN("%08x %p: %s\n", flags, block, err);
     return err == NULL;
 }
 
@@ -679,12 +684,12 @@ static BOOLEAN LFH_validate_free_block(ULONG flags, const LFH_block *block)
 {
     const char *err = NULL;
 
-    if (!LFH_validate_block(flags, block))
+    if (unlikely(!LFH_validate_block(flags, block)))
         return FALSE;
-    if (block->type != LFH_block_type_free)
+    if (unlikely(block->type != LFH_block_type_free))
         err = "invalid free block type";
 
-    if (err) WARN("%08x %p: %s\n", flags, block, err);
+    if (unlikely(err)) WARN("%08x %p: %s\n", flags, block, err);
     return err == NULL;
 }
 
@@ -692,31 +697,31 @@ static BOOLEAN LFH_validate_defer_block(ULONG flags, const LFH_block *block)
 {
     const char *err = NULL;
 
-    if (!LFH_validate_block(flags, block))
+    if (unlikely(!LFH_validate_block(flags, block)))
         return FALSE;
-    if (block->type != LFH_block_type_free)
+    if (unlikely(block->type != LFH_block_type_free))
         err = "invalid defer block type";
-    else if (flags & HEAP_FREE_CHECKING_ENABLED)
+    else if (unlikely(flags & HEAP_FREE_CHECKING_ENABLED))
     {
         const unsigned int *data = (const unsigned int *)LFH_ptr_from_block(block);
         size_t class_size = LFH_block_get_class_size(block);
         for (size_t i = 0; i < class_size / 4 - (data - (const unsigned int *)block) && !err; ++i)
-            if (data[i] != 0xfeeefeee) err = "invalid free filler";
+            if (unlikely(data[i] != 0xfeeefeee)) err = "invalid free filler";
     }
 
-    if (err) WARN("%08x %p: %s\n", flags, block, err);
+    if (unlikely(err)) WARN("%08x %p: %s\n", flags, block, err);
     return err == NULL;
 }
 
-static BOOLEAN LFH_validate_used_block(ULONG flags, const LFH_block *block)
+static inline BOOLEAN LFH_validate_used_block(ULONG flags, const LFH_block *block)
 {
     const char *err = NULL;
 
-    if (!LFH_validate_block(flags, block))
+    if (unlikely(!LFH_validate_block(flags, block)))
         return FALSE;
-    if (block->type != LFH_block_type_used)
+    if (unlikely(block->type != LFH_block_type_used))
         err = "invalid used block type";
-    else if (0 && (flags & HEAP_TAIL_CHECKING_ENABLED))
+    else if (unlikely(0 && (flags & HEAP_TAIL_CHECKING_ENABLED)))
     {
         const unsigned char *data = (const unsigned char *)LFH_ptr_from_block(block);
         size_t alloc_size = LFH_block_get_alloc_size(block, flags);
@@ -725,7 +730,7 @@ static BOOLEAN LFH_validate_used_block(ULONG flags, const LFH_block *block)
             if (data[i] != 0xab) err = "invalid tail filler";
     }
 
-    if (err) WARN("%08x %p: %s\n", flags, block, err);
+    if (unlikely(err)) WARN("%08x %p: %s\n", flags, block, err);
     return err == NULL;
 }
 
@@ -747,38 +752,38 @@ static BOOLEAN LFH_validate_arena(ULONG flags, const LFH_arena *arena)
 {
     const char *err = NULL;
     const LFH_arena *parent;
+    const LFH_arena *block_arena = LFH_block_arena_from_block(arena);
+    const LFH_arena *large_arena = LFH_large_arena_from_block(arena);
 
-    if (flags & HEAP_VALIDATE)
+    if (unlikely(flags & HEAP_VALIDATE))
         return LFH_validate_heap(flags, LFH_heap_from_arena(arena));
 
-    if (arena != LFH_large_arena_from_block(arena) &&
-        arena != (LFH_large_arena_from_block(arena) + 1))
+    if (unlikely(arena != large_arena && arena != block_arena))
         err = "invalid arena alignment";
-    else if (arena == LFH_block_arena_from_block(arena))
+    else if (unlikely(arena == block_arena))
     {
-        if (!LFH_validate_block(flags, (LFH_block *)arena))
+        if (unlikely(!LFH_validate_block(flags, (LFH_block *)arena)))
             err = "invalid block arena";
-        else if (!LFH_validate_arena_free_blocks(flags, arena))
+        else if (unlikely(!LFH_validate_arena_free_blocks(flags, arena)))
             err = "invalid block arena free list";
     }
-    else if (arena == LFH_large_arena_from_block(arena) && !LFH_class_from_arena(arena))
+    else if (unlikely(arena == large_arena && !LFH_class_from_arena(arena)))
     {
-        if (arena->huge_size <= LARGE_CLASS_MAX_SIZE)
+        if (unlikely(arena->huge_size <= LARGE_CLASS_MAX_SIZE))
             err = "invalid huge arena size";
     }
-    else if (arena == LFH_large_arena_from_block(arena) &&
-             (parent = LFH_parent_from_arena(arena)) != arena)
+    else if (unlikely(arena == large_arena && (parent = LFH_parent_from_arena(arena)) != arena))
     {
-        if (arena > parent || LFH_large_arena_from_block(parent) != parent)
+        if (unlikely(arena > parent || LFH_large_arena_from_block(parent) != parent))
             err = "invalid child arena parent";
     }
     else
     {
-        if (!LFH_validate_arena_free_blocks(flags, arena))
+        if (unlikely(!LFH_validate_arena_free_blocks(flags, arena)))
             err = "invalid large arena free list";
     }
 
-    if (err) WARN("%08x %p: %s\n", flags, arena, err);
+    if (unlikely(err)) WARN("%08x %p: %s\n", flags, arena, err);
     return err == NULL;
 }
 
@@ -837,7 +842,7 @@ static BOOLEAN LFH_validate_heap(ULONG flags, const LFH_heap *heap)
         }
     }
 
-    if (err) WARN("%08x %p: %s\n", flags, heap, err);
+    if (unlikely(err)) WARN("%08x %p: %s\n", flags, heap, err);
     return err == NULL;
 }
 
@@ -967,13 +972,13 @@ static size_t LFH_get_allocated_size(ULONG flags, const LFH_ptr *ptr)
     return LFH_block_get_alloc_size(block, flags);
 }
 
-static BOOLEAN LFH_validate(ULONG flags, const LFH_ptr *ptr)
+static inline BOOLEAN LFH_validate(ULONG flags, const LFH_ptr *ptr)
 {
     const LFH_block *block = LFH_block_from_ptr(ptr);
     const LFH_heap *heap;
 
     /* clear HEAP_VALIDATE so we only validate block */
-    if (ptr) return LFH_validate_used_block(flags & ~HEAP_VALIDATE, block);
+    if (likely(ptr)) return LFH_validate_used_block(flags & ~HEAP_VALIDATE, block);
 
     if (!(heap = LFH_thread_heap(FALSE)))
         return TRUE;
-- 
2.30.2

