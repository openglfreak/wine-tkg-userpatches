From 096d35ebda5c995589b59ca4f3ed066b9df7bce1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 6 Jul 2022 16:28:44 +0200
Subject: [PATCH 1/3] wmvcore/tests: Add more IWMReader_(Open|Start|Stop|Close)
 async checks.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: RÃ©mi Bernon <rbernon@codeweavers.com>
---
 dlls/wmvcore/tests/wmvcore.c | 142 ++++++++++++++++++++++++++++++-----
 1 file changed, 122 insertions(+), 20 deletions(-)

diff --git a/dlls/wmvcore/tests/wmvcore.c b/dlls/wmvcore/tests/wmvcore.c
index 11111111111..11111111111 100644
--- a/dlls/wmvcore/tests/wmvcore.c
+++ b/dlls/wmvcore/tests/wmvcore.c
@@ -1422,8 +1422,11 @@ struct callback
     IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced_iface;
     IWMReaderAllocatorEx IWMReaderAllocatorEx_iface;
     LONG refcount;
-    HANDLE got_opened, got_stopped, eof_event;
-    unsigned int got_closed, got_started, got_sample, got_end_of_streaming, got_eof;
+    HANDLE expect_opened, got_opened;
+    HANDLE expect_started, got_started;
+    HANDLE expect_stopped, got_stopped;
+    HANDLE eof_event;
+    unsigned int got_closed, started_count, got_sample, got_end_of_streaming, got_eof;
     bool all_streams_off;
     bool allocated_samples;
 
@@ -1480,6 +1483,7 @@ static HRESULT WINAPI callback_OnStatus(IWMReaderCallback *iface, WMT_STATUS sta
         HRESULT hr, WMT_ATTR_DATATYPE type, BYTE *value, void *context)
 {
     struct callback *callback = impl_from_IWMReaderCallback(iface);
+    DWORD ret;
 
     if (winetest_debug > 1)
         trace("%lu: %04lx: IWMReaderCallback::OnStatus(status %u, hr %#lx, type %#x, value %p)\n",
@@ -1491,6 +1495,9 @@ static HRESULT WINAPI callback_OnStatus(IWMReaderCallback *iface, WMT_STATUS sta
             ok(type == WMT_TYPE_DWORD, "Got type %#x.\n", type);
             ok(!*(DWORD *)value, "Got value %#lx.\n", *(DWORD *)value);
             ok(context == (void *)0xdeadbeef, "Got unexpected context %p.\n", context);
+            ret = WaitForSingleObject(callback->expect_opened, 100);
+            todo_wine
+            ok(!ret, "Wait timed out.\n");
             SetEvent(callback->got_opened);
             break;
 
@@ -1498,14 +1505,21 @@ static HRESULT WINAPI callback_OnStatus(IWMReaderCallback *iface, WMT_STATUS sta
             ok(type == WMT_TYPE_DWORD, "Got type %#x.\n", type);
             ok(!*(DWORD *)value, "Got value %#lx.\n", *(DWORD *)value);
             ok(context == (void *)0xfacade, "Got unexpected context %p.\n", context);
+            ret = WaitForSingleObject(callback->expect_started, 100);
+            todo_wine
+            ok(!ret, "Wait timed out.\n");
             callback->got_end_of_streaming = callback->got_eof = callback->got_sample = 0;
-            ++callback->got_started;
+            SetEvent(callback->got_started);
+            ++callback->started_count;
             break;
 
         case WMT_STOPPED:
             ok(type == WMT_TYPE_DWORD, "Got type %#x.\n", type);
             ok(!*(DWORD *)value, "Got value %#lx.\n", *(DWORD *)value);
             ok(context == (void *)0xfacade, "Got unexpected context %p.\n", context);
+            ret = WaitForSingleObject(callback->expect_stopped, 100);
+            todo_wine
+            ok(!ret, "Wait timed out.\n");
             SetEvent(callback->got_stopped);
             break;
 
@@ -1613,7 +1627,7 @@ static HRESULT WINAPI callback_OnSample(IWMReaderCallback *iface, DWORD output,
     check_async_sample(callback, sample);
 
     ok(!callback->read_compressed, "OnSample() should not be called when reading compressed samples.\n");
-    ok(callback->got_started > 0, "Got %u WMT_STARTED callbacks.\n", callback->got_started);
+    ok(callback->started_count > 0, "Got %u WMT_STARTED callbacks.\n", callback->started_count);
     ok(!callback->got_eof, "Got %u WMT_EOF callbacks.\n", callback->got_eof);
     ++callback->got_sample;
 
@@ -1666,7 +1680,7 @@ static HRESULT WINAPI callback_advanced_OnStreamSample(IWMReaderCallbackAdvanced
     check_async_sample(callback, sample);
 
     ok(callback->read_compressed, "OnStreamSample() should not be called unless reading compressed samples.\n");
-    ok(callback->got_started > 0, "Got %u WMT_STARTED callbacks.\n", callback->got_started);
+    ok(callback->started_count > 0, "Got %u WMT_STARTED callbacks.\n", callback->started_count);
     ok(!callback->got_eof, "Got %u WMT_EOF callbacks.\n", callback->got_eof);
     ++callback->got_sample;
 
@@ -1840,7 +1854,11 @@ static void callback_init(struct callback *callback)
     callback->IWMReaderCallbackAdvanced_iface.lpVtbl = &callback_advanced_vtbl;
     callback->IWMReaderAllocatorEx_iface.lpVtbl = &callback_allocator_vtbl;
     callback->refcount = 1;
+    callback->expect_opened = CreateEventW(NULL, FALSE, FALSE, NULL);
     callback->got_opened = CreateEventW(NULL, FALSE, FALSE, NULL);
+    callback->expect_started = CreateEventW(NULL, FALSE, FALSE, NULL);
+    callback->got_started = CreateEventW(NULL, FALSE, FALSE, NULL);
+    callback->expect_stopped = CreateEventW(NULL, FALSE, FALSE, NULL);
     callback->got_stopped = CreateEventW(NULL, FALSE, FALSE, NULL);
     callback->eof_event = CreateEventW(NULL, FALSE, FALSE, NULL);
     callback->ontime_event = CreateEventW(NULL, FALSE, FALSE, NULL);
@@ -1849,7 +1867,11 @@ static void callback_init(struct callback *callback)
 static void callback_cleanup(struct callback *callback)
 {
     CloseHandle(callback->got_opened);
+    CloseHandle(callback->expect_opened);
+    CloseHandle(callback->got_started);
+    CloseHandle(callback->expect_started);
     CloseHandle(callback->got_stopped);
+    CloseHandle(callback->expect_stopped);
     CloseHandle(callback->eof_event);
     CloseHandle(callback->ontime_event);
 }
@@ -1860,13 +1882,22 @@ static void run_async_reader(IWMReader *reader, IWMReaderAdvanced2 *advanced, st
     DWORD ret;
 
     callback->got_closed = 0;
-    callback->got_started = 0;
+    callback->started_count = 0;
     callback->got_sample = 0;
     callback->got_end_of_streaming = 0;
     callback->got_eof = 0;
 
     hr = IWMReader_Start(reader, 0, 0, 1.0f, (void *)0xfacade);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ret = WaitForSingleObject(callback->got_started, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STARTED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback->expect_started);
+        ret = WaitForSingleObject(callback->got_started, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     hr = IWMReaderAdvanced2_SetUserProvidedClock(advanced, TRUE);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
@@ -1879,8 +1910,15 @@ static void run_async_reader(IWMReader *reader, IWMReaderAdvanced2 *advanced, st
 
     hr = IWMReader_Stop(reader);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ret = WaitForSingleObject(callback->got_stopped, 1000);
-    ok(!ret, "Wait timed out.\n");
+    ret = WaitForSingleObject(callback->got_stopped, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STOPPED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback->expect_stopped);
+        ret = WaitForSingleObject(callback->got_stopped, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     ok(!outstanding_buffers, "Got %ld outstanding buffers.\n", outstanding_buffers);
 }
@@ -2178,8 +2216,15 @@ static void test_async_reader_streaming(void)
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
     ok(stream.refcount > 1, "Got refcount %ld.\n", stream.refcount);
     ok(callback.refcount > 1, "Got refcount %ld.\n", callback.refcount);
-    ret = WaitForSingleObject(callback.got_opened, 1000);
-    ok(!ret, "Wait timed out.\n");
+    ret = WaitForSingleObject(callback.got_opened, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_OPENED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_opened);
+        ret = WaitForSingleObject(callback.got_opened, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     hr = IWMReaderAdvanced2_OpenStream(advanced, &stream.IStream_iface, &callback.IWMReaderCallback_iface, (void **)0xdeadbee0);
     ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
@@ -2205,6 +2250,15 @@ static void test_async_reader_streaming(void)
 
     hr = IWMReader_Start(reader, 0, 0, 1.0f, (void *)0xfacade);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ret = WaitForSingleObject(callback.got_started, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STARTED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_started);
+        ret = WaitForSingleObject(callback.got_started, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     /* By default the reader will time itself, and attempt to deliver samples
      * according to their presentation time. Call DeliverTime with the file
@@ -2235,6 +2289,15 @@ static void test_async_reader_streaming(void)
 
     hr = IWMReader_Start(reader, 0, 0, 1.0f, (void *)0xfacade);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ret = WaitForSingleObject(callback.got_started, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STARTED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_started);
+        ret = WaitForSingleObject(callback.got_started, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     hr = IWMReaderAdvanced2_DeliverTime(advanced, 3000 * 10000);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
@@ -2245,13 +2308,27 @@ static void test_async_reader_streaming(void)
 
     hr = IWMReader_Stop(reader);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ret = WaitForSingleObject(callback.got_stopped, 1000);
-    ok(!ret, "Wait timed out.\n");
+    ret = WaitForSingleObject(callback.got_stopped, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STOPPED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_stopped);
+        ret = WaitForSingleObject(callback.got_stopped, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     hr = IWMReader_Stop(reader);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ret = WaitForSingleObject(callback.got_stopped, 1000);
-    ok(!ret, "Wait timed out.\n");
+    ret = WaitForSingleObject(callback.got_stopped, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STOPPED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_stopped);
+        ret = WaitForSingleObject(callback.got_stopped, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     test_reader_attributes(profile);
     test_async_reader_selection(reader, advanced, &callback);
@@ -2263,7 +2340,8 @@ static void test_async_reader_streaming(void)
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
     ok(callback.got_closed == 1, "Got %u WMT_CLOSED callbacks.\n", callback.got_closed);
     ok(callback.refcount == 1, "Got outstanding refcount %ld.\n", callback.refcount);
-    callback_cleanup(&callback);
+    ret = WaitForSingleObject(callback.got_stopped, 0);
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STOPPED.\n");
 
     hr = IWMReader_Stop(reader);
     ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
@@ -2318,8 +2396,15 @@ static void test_async_reader_types(void)
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
     ok(stream.refcount > 1, "Got refcount %ld.\n", stream.refcount);
     ok(callback.refcount > 1, "Got refcount %ld.\n", callback.refcount);
-    ret = WaitForSingleObject(callback.got_opened, 1000);
-    ok(!ret, "Wait timed out.\n");
+    ret = WaitForSingleObject(callback.got_opened, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_OPENED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_opened);
+        ret = WaitForSingleObject(callback.got_opened, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     for (i = 0; i < 2; ++i)
     {
@@ -2541,8 +2626,15 @@ static void test_async_reader_file(void)
     hr = IWMReader_Open(reader, filename, &callback.IWMReaderCallback_iface, (void **)0xdeadbeef);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
     ok(callback.refcount > 1, "Got refcount %ld.\n", callback.refcount);
-    ret = WaitForSingleObject(callback.got_opened, 1000);
-    ok(!ret, "Wait timed out.\n");
+    ret = WaitForSingleObject(callback.got_opened, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_OPENED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_opened);
+        ret = WaitForSingleObject(callback.got_opened, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     hr = IWMReader_Open(reader, filename, &callback.IWMReaderCallback_iface, (void **)0xdeadbee0);
     ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
@@ -2554,12 +2646,22 @@ static void test_async_reader_file(void)
 
     hr = IWMReader_Start(reader, 0, 0, 1.0f, (void *)0xfacade);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ret = WaitForSingleObject(callback.got_started, 0);
+    todo_wine
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STARTED.\n");
+    if (ret == WAIT_TIMEOUT)
+    {
+        SetEvent(callback.expect_started);
+        ret = WaitForSingleObject(callback.got_started, 1000);
+        ok(!ret, "Wait timed out.\n");
+    }
 
     hr = IWMReader_Close(reader);
     ok(hr == S_OK, "Got hr %#lx.\n", hr);
     ok(callback.got_closed == 1, "Got %u WMT_CLOSED callbacks.\n", callback.got_closed);
     ok(callback.refcount == 1, "Got outstanding refcount %ld.\n", callback.refcount);
-    callback_cleanup(&callback);
+    ret = WaitForSingleObject(callback.got_stopped, 0);
+    ok(ret == WAIT_TIMEOUT, "Got unexpected WMT_STOPPED.\n");
 
     hr = IWMReader_Close(reader);
     ok(hr == NS_E_INVALID_REQUEST, "Got hr %#lx.\n", hr);


