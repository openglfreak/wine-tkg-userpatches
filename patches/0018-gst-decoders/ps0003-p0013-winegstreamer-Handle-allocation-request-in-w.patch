From 0db57d866017ca6bcedf320d4693d83a5d81cdb2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 6 Jun 2022 19:37:25 +0200
Subject: [PATCH 13/30] winegstreamer: Handle allocation request in wm_reader.

---
 dlls/winegstreamer/gst_private.h |  1 +
 dlls/winegstreamer/wg_sample.c   | 53 +++++++++++++++++++++++++
 dlls/winegstreamer/wm_reader.c   | 68 +++++++++++++++++++++++++++++++-
 3 files changed, 121 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -132,6 +132,7 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format);
 HRESULT wg_sample_create_raw(UINT32 size, struct wg_sample **out);
 HRESULT wg_sample_create_mf(IMFSample *sample, struct wg_sample **out);
 HRESULT wg_sample_create_quartz(IMediaSample *sample, struct wg_sample **out);
+HRESULT wg_sample_create_wm(INSSBuffer *wm_sample, struct wg_sample **out);
 void wg_sample_release(struct wg_sample *wg_sample);
 void wg_sample_queue_begin_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample);
 void wg_sample_queue_end_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample);
diff --git a/dlls/winegstreamer/wg_sample.c b/dlls/winegstreamer/wg_sample.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_sample.c
+++ b/dlls/winegstreamer/wg_sample.c
@@ -25,6 +25,7 @@
 #include "wine/list.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+WINE_DECLARE_DEBUG_CHANNEL(wmvcore);
 WINE_DECLARE_DEBUG_CHANNEL(quartz);
 
 struct wg_sample_queue
@@ -61,6 +62,10 @@ struct sample
         {
             IMediaSample *sample;
         } quartz;
+        struct
+        {
+            INSSBuffer *sample;
+        } wm;
     } u;
 };
 
@@ -200,6 +205,54 @@ HRESULT wg_sample_create_quartz(IMediaSample *media_sample, struct wg_sample **o
     return S_OK;
 }
 
+static const struct wg_sample_ops wm_sample_ops;
+
+static inline struct sample *unsafe_wm_from_wg_sample(struct wg_sample *wg_sample)
+{
+    struct sample *sample = CONTAINING_RECORD(wg_sample, struct sample, wg_sample);
+    if (sample->ops != &wm_sample_ops) return NULL;
+    return sample;
+}
+
+static void wm_sample_destroy(struct wg_sample *wg_sample)
+{
+    struct sample *sample = unsafe_wm_from_wg_sample(wg_sample);
+
+    TRACE_(wmvcore)("wg_sample %p.\n", wg_sample);
+
+    INSSBuffer_Release(sample->u.wm.sample);
+}
+
+static const struct wg_sample_ops wm_sample_ops =
+{
+    wm_sample_destroy,
+};
+
+HRESULT wg_sample_create_wm(INSSBuffer *wm_sample, struct wg_sample **out)
+{
+    DWORD current_length, max_length;
+    struct sample *sample;
+    BYTE *buffer;
+    HRESULT hr;
+
+    if (FAILED(hr = INSSBuffer_GetBufferAndLength(wm_sample, &buffer, &current_length)))
+        return hr;
+    if (FAILED(hr = INSSBuffer_GetMaxLength(wm_sample, &max_length)))
+        return hr;
+    if (!(sample = calloc(1, sizeof(*sample))))
+        return E_OUTOFMEMORY;
+
+    INSSBuffer_AddRef((sample->u.wm.sample = wm_sample));
+    sample->wg_sample.data = buffer;
+    sample->wg_sample.size = current_length;
+    sample->wg_sample.max_size = max_length;
+    sample->ops = &wm_sample_ops;
+
+    TRACE_(wmvcore)("Created wg_sample %p for sample %p.\n", &sample->wg_sample, wm_sample);
+    *out = &sample->wg_sample;
+    return S_OK;
+}
+
 void wg_sample_release(struct wg_sample *wg_sample)
 {
     struct sample *sample = CONTAINING_RECORD(wg_sample, struct sample, wg_sample);
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -574,6 +574,72 @@ static void handle_read_request(struct wm_reader *reader, IStream *stream,
     wg_parser_push_data(reader->wg_parser, wg_sample, reader->wg_sample_queue);
 }
 
+static HRESULT wm_allocate_sample(struct wm_stream *stream, UINT32 size, INSSBuffer **sample)
+{
+    IWMReaderCallbackAdvanced *callback_advanced = stream->reader->callback_advanced;
+    HRESULT hr;
+
+    if (callback_advanced && stream->read_compressed && stream->allocate_stream)
+    {
+        if (FAILED(hr = IWMReaderCallbackAdvanced_AllocateForStream(callback_advanced,
+                stream->index + 1, size, sample, NULL)))
+            return hr;
+    }
+    else if (callback_advanced && !stream->read_compressed && stream->allocate_output)
+    {
+        if (FAILED(hr = IWMReaderCallbackAdvanced_AllocateForOutput(callback_advanced,
+                stream->index, size, sample, NULL)))
+            return hr;
+    }
+    else
+    {
+        struct buffer *object;
+
+        /* FIXME: Should these be pooled? */
+        if (!(object = calloc(1, offsetof(struct buffer, data[size]))))
+            return E_OUTOFMEMORY;
+
+        object->INSSBuffer_iface.lpVtbl = &buffer_vtbl;
+        object->refcount = 1;
+        object->capacity = size;
+
+        TRACE("Created buffer %p.\n", object);
+        *sample = &object->INSSBuffer_iface;
+    }
+
+    return S_OK;
+}
+
+static void handle_alloc_request(struct wm_reader *reader, struct wg_parser_stream *wg_stream, UINT32 size)
+{
+    struct wg_sample *wg_sample = NULL;
+    struct wm_stream *stream = NULL;
+    HRESULT hr = E_FAIL;
+    INSSBuffer *sample;
+    int i;
+
+    for (i = 0; i < reader->stream_count && !stream; ++i)
+        if (reader->streams[i].wg_stream == wg_stream)
+            stream = reader->streams + i;
+
+    if (!stream)
+        WARN("No stream found for wg_stream %p\n", wg_stream);
+    else if (SUCCEEDED(hr = wm_allocate_sample(stream, size, &sample)))
+    {
+        hr = wg_sample_create_wm(sample, &wg_sample);
+        INSSBuffer_Release(sample);
+    }
+
+    if (FAILED(hr))
+    {
+        ERR("Failed to allocate sample, hr %#lx\n", hr);
+        wg_parser_done_alloc(reader->wg_parser, NULL, NULL);
+        return;
+    }
+
+    wg_parser_done_alloc(reader->wg_parser, wg_sample, reader->wg_sample_queue);
+}
+
 static DWORD CALLBACK read_thread(void *arg)
 {
     struct wm_reader *reader = arg;
@@ -622,7 +688,7 @@ static DWORD CALLBACK read_thread(void *arg)
             }
 
             case WG_REQUEST_ALLOC:
-                wg_parser_done_alloc(reader->wg_parser, NULL, NULL);
+                handle_alloc_request(reader, request.u.alloc.stream, request.u.alloc.size);
                 continue;
 
             default:
-- 
2.37.1

