commit 484b78bda01b4943023cae859271aa32b949c6ae
Author: Zebediah Figura <zfigura@codeweavers.com>
Date:   Sun Sep 12 16:07:51 2021 -0500

    ntoskrnl: Report the initial status of an IRP separately from the IOSB status.
    
    Based on a patch by Chip Davis.
    
    Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30155
    Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
    Signed-off-by: Alexandre Julliard <julliard@winehq.org>

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index b4d038c299b..42976f4905e 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -492,6 +492,7 @@ static NTSTATUS dispatch_irp( DEVICE_OBJECT *device, IRP *irp, struct dispatch_c
 {
     struct irp_data *irp_data;
     LARGE_INTEGER count;
+    NTSTATUS status;
 
     if (!(irp_data = malloc( sizeof(*irp_data) )))
         return STATUS_NO_MEMORY;
@@ -508,11 +509,14 @@ static NTSTATUS dispatch_irp( DEVICE_OBJECT *device, IRP *irp, struct dispatch_c
 
     device->CurrentIrp = irp;
     KeEnterCriticalRegion();
-    IoCallDriver( device, irp );
+    status = IoCallDriver( device, irp );
     KeLeaveCriticalRegion();
     device->CurrentIrp = NULL;
 
-    return STATUS_SUCCESS;
+    if (status != STATUS_PENDING && !irp_data->complete)
+        ERR( "dispatch routine returned %#x but didn't complete the IRP\n", status );
+
+    return status;
 }
 
 /* process a create request for a given file */
@@ -934,6 +938,7 @@ NTSTATUS CDECL wine_ntoskrnl_main_loop( HANDLE stop_event )
                 IRP *irp = context.irp_data->irp;
 
                 req->user_ptr = wine_server_client_ptr( irp );
+                req->status   = status;
 
                 if (context.irp_data->complete)
                 {
@@ -943,19 +948,12 @@ NTSTATUS CDECL wine_ntoskrnl_main_loop( HANDLE stop_event )
                     if (irp->Flags & IRP_WRITE_OPERATION)
                         out_buff = NULL;  /* do not transfer back input buffer */
 
-                    req->prev      = wine_server_obj_handle( context.irp_data->handle );
-                    req->status    = irp->IoStatus.u.Status;
-                    req->result    = irp->IoStatus.Information;
+                    req->prev        = wine_server_obj_handle( context.irp_data->handle );
+                    req->iosb_status = irp->IoStatus.u.Status;
+                    req->result      = irp->IoStatus.Information;
                     if (!NT_ERROR(irp->IoStatus.u.Status) && out_buff)
                         wine_server_add_data( req, out_buff, irp->IoStatus.Information );
                 }
-                else
-                {
-                    if (status == STATUS_SUCCESS)
-                        status = STATUS_PENDING;
-
-                    req->status    = status;
-                }
             }
             else
             {
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 5744609c4a7..4a12e6533f6 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -4801,9 +4801,9 @@ struct get_next_device_request_request
     obj_handle_t prev;
     unsigned int status;
     client_ptr_t user_ptr;
+    unsigned int iosb_status;
     data_size_t  result;
     /* VARARG(data,bytes); */
-    char __pad_36[4];
 };
 struct get_next_device_request_reply
 {
diff --git a/server/async.c b/server/async.c
index 2dbdfc76a59..df30ae3c7da 100644
--- a/server/async.c
+++ b/server/async.c
@@ -48,6 +48,7 @@ struct async
     async_data_t         data;            /* data for async I/O call */
     struct iosb         *iosb;            /* I/O status block */
     obj_handle_t         wait_handle;     /* pre-allocated wait handle */
+    unsigned int         initial_status;  /* status returned from initial request */
     unsigned int         signaled :1;
     unsigned int         pending :1;      /* request successfully queued, but pending */
     unsigned int         direct_result :1;/* a flag if we're passing result directly from request instead of APC  */
@@ -125,7 +126,10 @@ static void async_satisfied( struct object *obj, struct wait_queue_entry *entry
         async->direct_result = 0;
     }
 
-    set_wait_status( entry, async->iosb->status );
+    if (async->initial_status == STATUS_PENDING && async->blocking)
+        set_wait_status( entry, async->iosb->status );
+    else
+        set_wait_status( entry, async->initial_status );
 
     /* close wait handle here to avoid extra server round trip */
     if (async->wait_handle)
@@ -255,6 +259,7 @@ struct async *create_async( struct fd *fd, struct thread *thread, const async_da
     async->timeout       = NULL;
     async->queue         = NULL;
     async->fd            = (struct fd *)grab_object( fd );
+    async->initial_status = STATUS_PENDING;
     async->signaled      = 0;
     async->pending       = 1;
     async->wait_handle   = 0;
@@ -285,17 +290,31 @@ struct async *create_async( struct fd *fd, struct thread *thread, const async_da
     return async;
 }
 
-void set_async_pending( struct async *async )
+/* set the initial status of an async whose status was previously unknown
+ * the initial status may be STATUS_PENDING */
+void async_set_initial_status( struct async *async, unsigned int status )
 {
+    assert( async->unknown_status );
     if (!async->terminated)
     {
-        async->pending = 1;
+        async->initial_status = status;
         async->unknown_status = 0;
-        if (!async->blocking && !async->signaled)
-        {
-            async->signaled = 1;
-            wake_up( &async->obj, 0 );
-        }
+    }
+}
+
+void set_async_pending( struct async *async )
+{
+    if (!async->terminated)
+        async->pending = 1;
+}
+
+void async_wake_obj( struct async *async )
+{
+    assert( !async->unknown_status );
+    if (!async->blocking)
+    {
+        async->signaled = 1;
+        wake_up( &async->obj, 0 );
     }
 }
 
@@ -311,6 +330,8 @@ obj_handle_t async_handoff( struct async *async, data_size_t *result, int force_
         return async->wait_handle;
     }
 
+    async->initial_status = get_error();
+
     if (!async->pending && NT_ERROR( get_error() ))
     {
         close_handle( async->thread->process, async->wait_handle );
@@ -348,6 +369,7 @@ obj_handle_t async_handoff( struct async *async, data_size_t *result, int force_
             async->wait_handle = 0;
         }
     }
+    async->initial_status = async->iosb->status;
     set_error( async->iosb->status );
     return async->wait_handle;
 }
diff --git a/server/device.c b/server/device.c
index b0e417a6473..df1a71a5a4d 100644
--- a/server/device.c
+++ b/server/device.c
@@ -952,18 +952,31 @@ DECL_HANDLER(get_next_device_request)
         irp = manager->current_call;
         irp->user_ptr = req->user_ptr;
 
-        if (req->prev)
+        if (irp->async)
         {
-            set_irp_result( irp, req->status, get_req_data(), get_req_data_size(), req->result );
-            close_handle( current->process, req->prev );  /* avoid an extra round-trip for close */
+            if (req->status == STATUS_PENDING)
+                set_async_pending( irp->async );
+            async_set_initial_status( irp->async, req->status );
+
+            if (req->prev)
+            {
+                set_irp_result( irp, req->iosb_status, get_req_data(), get_req_data_size(), req->result );
+                close_handle( current->process, req->prev );  /* avoid an extra round-trip for close */
+            }
+            else
+            {
+                async_wake_obj( irp->async );
+                if (irp->canceled)
+                {
+                    /* if it was canceled during dispatch, we couldn't queue cancel
+                     * call without client pointer, so we need to do it now */
+                    cancel_irp_call( irp );
+                }
+            }
         }
-        else if (irp->async)
+        else
         {
-            set_async_pending( irp->async );
-            if (irp->canceled)
-                /* if it was canceled during dispatch, we couldn't queue cancel call without client pointer,
-                 * so we need to do it now */
-                cancel_irp_call( irp );
+            set_irp_result( irp, req->status, NULL, 0, 0 );
         }
 
         free_irp_params( irp );
diff --git a/server/file.h b/server/file.h
index 80f2191c050..1d830cd3d6f 100644
--- a/server/file.h
+++ b/server/file.h
@@ -230,6 +230,8 @@ extern void async_set_result( struct object *obj, unsigned int status, apc_param
 extern void async_set_completion_callback( struct async *async, async_completion_callback func, void *private );
 extern void async_set_unknown_status( struct async *async );
 extern void set_async_pending( struct async *async );
+extern void async_set_initial_status( struct async *async, unsigned int status );
+extern void async_wake_obj( struct async *async );
 extern int async_waiting( struct async_queue *queue );
 extern void async_terminate( struct async *async, unsigned int status );
 extern void async_request_complete( struct async *async, unsigned int status, data_size_t result,
diff --git a/server/protocol.def b/server/protocol.def
index fec212a3ea3..608c481db27 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3368,6 +3368,7 @@ struct handle_info
     obj_handle_t prev;            /* handle to the previous irp */
     unsigned int status;          /* status of the previous irp */
     client_ptr_t user_ptr;        /* user pointer of the previous irp */
+    unsigned int iosb_status;     /* IOSB status of the previous irp */
     data_size_t  result;          /* IOSB result of the previous irp */
     VARARG(data,bytes);           /* output data of the previous irp */
 @REPLY
diff --git a/server/request.h b/server/request.h
index 9fc6056122e..c2e8e30d1e1 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2053,7 +2053,8 @@ C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, manager) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, prev) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, status) == 20 );
 C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, user_ptr) == 24 );
-C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, result) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, iosb_status) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_next_device_request_request, result) == 36 );
 C_ASSERT( sizeof(struct get_next_device_request_request) == 40 );
 C_ASSERT( FIELD_OFFSET(struct get_next_device_request_reply, params) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_next_device_request_reply, next) == 40 );
diff --git a/server/trace.c b/server/trace.c
index a0c60fa3fb8..fa943d217bb 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4177,6 +4177,7 @@ static void dump_get_next_device_request_request( const struct get_next_device_r
     fprintf( stderr, ", prev=%04x", req->prev );
     fprintf( stderr, ", status=%08x", req->status );
     dump_uint64( ", user_ptr=", &req->user_ptr );
+    fprintf( stderr, ", iosb_status=%08x", req->iosb_status );
     fprintf( stderr, ", result=%u", req->result );
     dump_varargs_bytes( ", data=", cur_size );
 }
