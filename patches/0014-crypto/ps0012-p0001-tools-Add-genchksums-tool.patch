From f98f5d6523d720548e908a464b06e28c969963e0 Mon Sep 17 00:00:00 2001
From: Torge Matthies <tmatthies@codeweavers.com>
Date: Fri, 29 Sep 2023 09:49:08 +0200
Subject: [PATCH 1/3] tools: Add genchksums tool.

---
 configure                     |   2 +
 configure.ac                  |   1 +
 tools/genchksums/Makefile.in  |   3 +
 tools/genchksums/genchksums.c | 212 ++++++++++++++++++++++++++++++++++
 4 files changed, 218 insertions(+)
 create mode 100644 tools/genchksums/Makefile.in
 create mode 100644 tools/genchksums/genchksums.c

diff --git a/configure b/configure
index 11111111111..11111111111 100755
--- a/configure
+++ b/configure
@@ -1731,6 +1731,7 @@ enable_wusa
 enable_xcopy
 enable_server
 enable_tools
+enable_genchksums
 enable_sfnt2fon
 enable_widl
 enable_winebuild
@@ -22300,6 +22301,7 @@ wine_fn_config_makefile programs/xcopy enable_xcopy
 wine_fn_config_makefile programs/xcopy/tests enable_tests
 wine_fn_config_makefile server enable_server
 test "x$enable_tools" = xno || wine_fn_config_makefile tools enable_tools
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/genchksums enable_genchksums
 test "x$enable_tools" = xno || wine_fn_config_makefile tools/sfnt2fon enable_sfnt2fon
 test "x$enable_tools" = xno || wine_fn_config_makefile tools/widl enable_widl
 test "x$enable_tools" = xno || wine_fn_config_makefile tools/winebuild enable_winebuild
diff --git a/configure.ac b/configure.ac
index 11111111111..11111111111 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3599,6 +3599,7 @@ WINE_CONFIG_MAKEFILE(programs/xcopy)
 WINE_CONFIG_MAKEFILE(programs/xcopy/tests)
 WINE_CONFIG_MAKEFILE(server)
 WINE_CONFIG_MAKEFILE(tools,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/genchksums,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/sfnt2fon,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/widl,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/winebuild,,[test "x$enable_tools" = xno])
diff --git a/tools/genchksums/Makefile.in b/tools/genchksums/Makefile.in
new file mode 100644
index 00000000000..11111111111
--- /dev/null
+++ b/tools/genchksums/Makefile.in
@@ -0,0 +1,3 @@
+PROGRAMS = genchksums
+
+C_SRCS = genchksums.c
diff --git a/tools/genchksums/genchksums.c b/tools/genchksums/genchksums.c
new file mode 100644
index 00000000000..11111111111
--- /dev/null
+++ b/tools/genchksums/genchksums.c
@@ -0,0 +1,212 @@
+/*
+ * File checksum generation tool
+ *
+ * Copyright 2004 Filip Navara
+ * Copyright 2023 Torge Matthies
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+
+/* SHA1 algorithm
+ *
+ * Based on public domain SHA code by Steve Reid <steve@edmweb.com>
+ * Copied and adapted from ntdll.A_SHAInit / ntdll.A_SHAUpdate / ntdll.A_SHAFinal
+ */
+
+struct sha1_context
+{
+   unsigned int state[5];
+   unsigned int count[2];
+   char         buffer[64];
+};
+
+#ifdef WORDS_BIGENDIAN
+#define DWORD2BE(x) (x)
+#else
+#define DWORD2BE(x) ((((x) >> 24) & 0xff) | (((x) >> 8) & 0xff00) | (((x) << 8) & 0xff0000) | (((x) << 24) & 0xff000000))
+#endif
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+#define blk0(i) (block[i] = DWORD2BE(block[i]))
+#define blk1(i) (block[i&15] = rol(block[(i+13)&15]^block[(i+8)&15]^block[(i+2)&15]^block[i&15],1))
+#define f1(x,y,z) (z^(x&(y^z)))
+#define f2(x,y,z) (x^y^z)
+#define f3(x,y,z) ((x&y)|(z&(x|y)))
+#define f4(x,y,z) (x^y^z)
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=f1(w,x,y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=f1(w,x,y)+blk1(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=f2(w,x,y)+blk1(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=f3(w,x,y)+blk1(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=f4(w,x,y)+blk1(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+/* Hash a single 512-bit block. This is the core of the algorithm. */
+static void sha1_transform(struct sha1_context *ctx)
+{
+   unsigned int a, b, c, d, e, *block = (unsigned int *)ctx->buffer;
+
+   /* Copy ctx->state[] to working variables */
+   a = ctx->state[0];
+   b = ctx->state[1];
+   c = ctx->state[2];
+   d = ctx->state[3];
+   e = ctx->state[4];
+
+   /* 4 rounds of 20 operations each. Loop unrolled. */
+   R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
+   R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
+   R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
+   R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
+   R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
+   R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
+   R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
+   R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
+   R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
+   R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
+   R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
+   R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
+   R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
+   R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
+   R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
+   R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
+   R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
+   R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
+   R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
+   R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
+
+   /* Add the working variables back into ctx->state[] */
+   ctx->state[0] += a;
+   ctx->state[1] += b;
+   ctx->state[2] += c;
+   ctx->state[3] += d;
+   ctx->state[4] += e;
+
+   /* Wipe variables */
+   a = b = c = d = e = 0;
+}
+
+void sha1_init(struct sha1_context *ctx)
+{
+   /* SHA1 initialization constants */
+   ctx->state[0] = 0x67452301;
+   ctx->state[1] = 0xEFCDAB89;
+   ctx->state[2] = 0x98BADCFE;
+   ctx->state[3] = 0x10325476;
+   ctx->state[4] = 0xC3D2E1F0;
+   ctx->count[0] = 0;
+   ctx->count[1] = 0;
+}
+
+void sha1_update(struct sha1_context *ctx, const char *data, size_t data_size)
+{
+   size_t buffer_size;
+
+   buffer_size = ctx->count[1] & 63;
+   ctx->count[1] += data_size;
+   if (ctx->count[1] < data_size) ctx->count[0]++;
+   ctx->count[0] += (data_size >> 29);
+
+   if (buffer_size + data_size < 64)
+      memcpy(&ctx->buffer[buffer_size], data, data_size);
+   else
+   {
+      while (buffer_size + data_size >= 64)
+      {
+         memcpy(ctx->buffer + buffer_size, data, 64 - buffer_size);
+         data += 64 - buffer_size;
+         data_size -= 64 - buffer_size;
+         sha1_transform(ctx);
+         buffer_size = 0;
+      }
+      memcpy(ctx->buffer + buffer_size, data, data_size);
+   }
+}
+
+void sha1_finalize(struct sha1_context *ctx, unsigned int result[5])
+{
+   unsigned int *count, length_hi, length_lo, i;
+   size_t pad_size, buffer_size;
+   char pad[72];
+
+   buffer_size = ctx->count[1] & 63;
+   if (buffer_size >= 56) pad_size = 56 + 64 - buffer_size;
+   else pad_size = 56 - buffer_size;
+
+   length_hi = (ctx->count[0] << 3) | (ctx->count[1] >> (32 - 3));
+   length_lo = (ctx->count[1] << 3);
+
+   memset(pad + 1, 0, pad_size - 1);
+   pad[0] = 0x80;
+   count = (unsigned int*)(pad + pad_size);
+   count[0] = DWORD2BE(length_hi);
+   count[1] = DWORD2BE(length_lo);
+   sha1_update(ctx, pad, pad_size + 8);
+
+   for (i = 0; i < 5; i++) result[i] = DWORD2BE(ctx->state[i]);
+
+   sha1_init(ctx);
+}
+
+static int hash_file(FILE *f, unsigned char hash[20])
+{
+    struct sha1_context ctx;
+    char buffer[64];
+    size_t r;
+
+    sha1_init(&ctx);
+    while (!feof(f) && !ferror(f) && (r = fread(buffer, 1, sizeof(buffer), f)))
+        sha1_update(&ctx, buffer, r);
+    if (ferror(f))
+        return 1;
+    sha1_finalize(&ctx, (unsigned int *)hash);
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    static const unsigned char hash_size = 20;
+
+    unsigned char hash[20];
+    char file_path[256];
+    int status;
+    FILE *f;
+
+    if (argc >= 2 && !freopen(argv[1], "rb", stdin))
+        return 1;
+    if (argc >= 3 && !freopen(argv[2], "wb", stdout))
+        return 1;
+#ifdef _WIN32
+    if (argc < 3 && !freopen("CON", "wb", stdout))
+        return 1;
+#endif
+
+    while (scanf("%255s", file_path) == 1)
+    {
+        file_path[sizeof(file_path) - 1] = '\0';
+        f = fopen(file_path, "rb");
+        if (!f)
+            return 1;
+        status = hash_file(f, hash);
+        fclose(f);
+        if (status || fwrite(&hash_size, 1, 1, stdout) != 1 ||
+            fwrite(hash, hash_size, 1, stdout) != 1)
+            return 1;
+    }
+    return 0;
+}
-- 
0.0.0

