From 8e5c31fbeb09f1531c2423e8f3f4c420f23451fb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 16 Feb 2022 17:37:46 +0100
Subject: [PATCH 17/20] winegstreamer: Implement videoconverter transform with
 using wg_transform.

---
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/mfplat.c                  | 325 +--------
 dlls/winegstreamer/videoconvert.c            | 713 +++++++++++++++++++
 dlls/winegstreamer/wg_transform.c            |   3 +-
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 include/wmcodecdsp.idl                       |   5 +
 7 files changed, 762 insertions(+), 292 deletions(-)
 create mode 100644 dlls/winegstreamer/videoconvert.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	media_source.c \
 	mfplat.c \
 	quartz_parser.c \
+	videoconvert.c \
 	wg_format.c \
 	wg_parser.c \
 	wg_pool.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -126,6 +126,7 @@ HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj);
 HRESULT aac_decoder_create(REFIID riid, void **ret);
 HRESULT h264_decoder_create(REFIID riid, void **ret);
 HRESULT audio_converter_create(REFIID riid, void **ret);
+HRESULT video_converter_create(REFIID riid, void **ret);
 
 struct wm_stream
 {
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -32,269 +32,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
 DEFINE_MEDIATYPE_GUID(MFAudioFormat_RAW_AAC, WAVE_FORMAT_RAW_AAC1);
 
-struct video_processor
-{
-    IMFTransform IMFTransform_iface;
-    LONG refcount;
-    IMFAttributes *attributes;
-    IMFAttributes *output_attributes;
-};
-
-static struct video_processor *impl_video_processor_from_IMFTransform(IMFTransform *iface)
-{
-    return CONTAINING_RECORD(iface, struct video_processor, IMFTransform_iface);
-}
-
-static HRESULT WINAPI video_processor_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
-{
-    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
-
-    if (IsEqualIID(riid, &IID_IMFTransform) ||
-            IsEqualIID(riid, &IID_IUnknown))
-    {
-        *obj = iface;
-        IMFTransform_AddRef(iface);
-        return S_OK;
-    }
-
-    WARN("Unsupported %s.\n", debugstr_guid(riid));
-    *obj = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG WINAPI video_processor_AddRef(IMFTransform *iface)
-{
-    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
-    ULONG refcount = InterlockedIncrement(&transform->refcount);
-
-    TRACE("%p, refcount %lu.\n", iface, refcount);
-
-    return refcount;
-}
-
-static ULONG WINAPI video_processor_Release(IMFTransform *iface)
-{
-    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
-    ULONG refcount = InterlockedDecrement(&transform->refcount);
-
-    TRACE("%p, refcount %lu.\n", iface, refcount);
-
-    if (!refcount)
-    {
-        if (transform->attributes)
-            IMFAttributes_Release(transform->attributes);
-        if (transform->output_attributes)
-            IMFAttributes_Release(transform->output_attributes);
-        free(transform);
-    }
-
-    return refcount;
-}
-
-static HRESULT WINAPI video_processor_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
-        DWORD *output_minimum, DWORD *output_maximum)
-{
-    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
-
-    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI video_processor_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
-{
-    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
-
-    *inputs = *outputs = 1;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI video_processor_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
-        DWORD output_size, DWORD *outputs)
-{
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
-{
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
-{
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
-{
-    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
-
-    TRACE("%p, %p.\n", iface, attributes);
-
-    *attributes = transform->attributes;
-    IMFAttributes_AddRef(*attributes);
-
-    return S_OK;
-}
-
-static HRESULT WINAPI video_processor_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
-        IMFAttributes **attributes)
-{
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
-        IMFAttributes **attributes)
-{
-    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
-
-    TRACE("%p, %lu, %p.\n", iface, id, attributes);
-
-    *attributes = transform->output_attributes;
-    IMFAttributes_AddRef(*attributes);
-
-    return S_OK;
-}
-
-static HRESULT WINAPI video_processor_DeleteInputStream(IMFTransform *iface, DWORD id)
-{
-    TRACE("%p, %lu.\n", iface, id);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
-{
-    TRACE("%p, %lu, %p.\n", iface, streams, ids);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
-        IMFMediaType **type)
-{
-    FIXME("%p, %lu, %lu, %p.\n", iface, id, index, type);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
-        IMFMediaType **type)
-{
-    FIXME("%p, %lu, %lu, %p.\n", iface, id, index, type);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
-{
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, type, flags);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
-{
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, type, flags);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
-{
-    FIXME("%p, %lu, %p.\n", iface, id, type);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
-{
-    FIXME("%p, %lu, %p.\n", iface, id, type);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
-{
-    FIXME("%p, %lu, %p.\n", iface, id, flags);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_GetOutputStatus(IMFTransform *iface, DWORD *flags)
-{
-    FIXME("%p, %p.\n", iface, flags);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
-{
-    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
-{
-    TRACE("%p, %lu, %p.\n", iface, id, event);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
-{
-    FIXME("%p, %u, %#Ix.\n", iface, message, param);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
-{
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, sample, flags);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_processor_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
-        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
-{
-    FIXME("%p, %#lx, %lu, %p, %p.\n", iface, flags, count, samples, status);
-
-    return E_NOTIMPL;
-}
-
-static const IMFTransformVtbl video_processor_vtbl =
-{
-    video_processor_QueryInterface,
-    video_processor_AddRef,
-    video_processor_Release,
-    video_processor_GetStreamLimits,
-    video_processor_GetStreamCount,
-    video_processor_GetStreamIDs,
-    video_processor_GetInputStreamInfo,
-    video_processor_GetOutputStreamInfo,
-    video_processor_GetAttributes,
-    video_processor_GetInputStreamAttributes,
-    video_processor_GetOutputStreamAttributes,
-    video_processor_DeleteInputStream,
-    video_processor_AddInputStreams,
-    video_processor_GetInputAvailableType,
-    video_processor_GetOutputAvailableType,
-    video_processor_SetInputType,
-    video_processor_SetOutputType,
-    video_processor_GetInputCurrentType,
-    video_processor_GetOutputCurrentType,
-    video_processor_GetInputStatus,
-    video_processor_GetOutputStatus,
-    video_processor_SetOutputBounds,
-    video_processor_ProcessEvent,
-    video_processor_ProcessMessage,
-    video_processor_ProcessInput,
-    video_processor_ProcessOutput,
-};
-
 struct class_factory
 {
     IClassFactory IClassFactory_iface;
@@ -371,32 +108,6 @@ static const IClassFactoryVtbl class_factory_vtbl =
     class_factory_LockServer,
 };
 
-static HRESULT video_processor_create(REFIID riid, void **ret)
-{
-    struct video_processor *object;
-    HRESULT hr;
-
-    if (!(object = calloc(1, sizeof(*object))))
-        return E_OUTOFMEMORY;
-
-    object->IMFTransform_iface.lpVtbl = &video_processor_vtbl;
-    object->refcount = 1;
-
-    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
-        goto failed;
-
-    if (FAILED(hr = MFCreateAttributes(&object->output_attributes, 0)))
-        goto failed;
-
-    *ret = &object->IMFTransform_iface;
-    return S_OK;
-
-failed:
-
-    IMFTransform_Release(&object->IMFTransform_iface);
-    return hr;
-}
-
 static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
 
 static const GUID CLSID_WINEAudioConverter = {0x6a170414,0xaad9,0x4693,{0xb8,0x06,0x3a,0x0c,0x47,0xc5,0x70,0xd6}};
@@ -408,11 +119,12 @@ static const struct class_object
 }
 class_objects[] =
 {
-    { &CLSID_VideoProcessorMFT, &video_processor_create },
+    { &CLSID_VideoProcessorMFT, &video_converter_create },
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
     { &CLSID_MSAACDecMFT, &aac_decoder_create },
     { &CLSID_MSH264DecoderMFT, &h264_decoder_create },
+    { &CLSID_CColorConvertDMO, &video_converter_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
@@ -490,6 +202,26 @@ static const GUID *const h264_decoder_output_types[] =
     &MFVideoFormat_YUY2,
 };
 
+static WCHAR color_converterW[] = L"Color Converter";
+static const GUID *color_converter_supported_types[] =
+{
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
 static const struct mft
 {
     const GUID *clsid;
@@ -548,13 +280,24 @@ mfts[] =
         ARRAY_SIZE(h264_decoder_output_types),
         h264_decoder_output_types,
     },
+    {
+        &CLSID_CColorConvertDMO,
+        &MFT_CATEGORY_VIDEO_EFFECT,
+        color_converterW,
+        0,
+        &MFMediaType_Video,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+    },
 };
 
 HRESULT mfplat_DllRegisterServer(void)
 {
     unsigned int i, j;
     HRESULT hr;
-    MFT_REGISTER_TYPE_INFO input_types[4], output_types[5];
+    MFT_REGISTER_TYPE_INFO input_types[16], output_types[16];
 
     for (i = 0; i < ARRAY_SIZE(mfts); i++)
     {
diff --git a/dlls/winegstreamer/videoconvert.c b/dlls/winegstreamer/videoconvert.c
new file mode 100644
index 00000000000..11111111111
--- /dev/null
+++ b/dlls/winegstreamer/videoconvert.c
@@ -0,0 +1,713 @@
+/* GStreamer Color Converter
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *const video_formats[] =
+{
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
+struct video_converter
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    struct wg_transform *wg_transform;
+    struct wg_format wg_format;
+};
+
+static struct video_converter *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_converter, IMFTransform_iface);
+}
+
+static HRESULT try_create_wg_transform(struct video_converter *transform)
+{
+    struct wg_format input_format;
+    struct wg_format output_format;
+
+    memset(&transform->wg_format, 0, sizeof(transform->wg_format));
+    if (transform->wg_transform)
+        wg_transform_destroy(transform->wg_transform);
+    transform->wg_transform = NULL;
+
+    mf_media_type_to_wg_format(transform->input_type, &input_format);
+    if (input_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(transform->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!(transform->wg_transform = wg_transform_create(&input_format, &output_format)))
+        return E_FAIL;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+            IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &transform->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI transform_AddRef(IMFTransform *iface)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&transform->refcount);
+
+    TRACE("iface %p increasing refcount to %lu.\n", transform, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI transform_Release(IMFTransform *iface)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&transform->refcount);
+
+    TRACE("iface %p decreasing refcount to %lu.\n", transform, refcount);
+
+    if (!refcount)
+    {
+        if (transform->wg_transform)
+            wg_transform_destroy(transform->wg_transform);
+        if (transform->input_type)
+            IMFMediaType_Release(transform->input_type);
+        if (transform->output_type)
+            IMFMediaType_Release(transform->output_type);
+        free(transform);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("iface %p, inputs %p, outputs %p.\n", iface, inputs, outputs);
+    *inputs = *outputs = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_size,
+        DWORD *inputs, DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %lu, inputs %p, output_size %lu, outputs %p stub!\n", iface,
+            input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    UINT32 sample_size;
+    UINT64 framesize;
+    GUID subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+
+    if (!transform->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (SUCCEEDED(hr = IMFMediaType_GetGUID(transform->input_type, &MF_MT_SUBTYPE, &subtype)) &&
+        SUCCEEDED(hr = IMFMediaType_GetUINT64(transform->input_type, &MF_MT_FRAME_SIZE, &framesize)))
+        MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &sample_size);
+    else
+        sample_size = 0;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbSize = sample_size;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    UINT32 sample_size;
+    UINT64 framesize;
+    GUID subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+
+    if (!transform->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (SUCCEEDED(hr = IMFMediaType_GetGUID(transform->output_type, &MF_MT_SUBTYPE, &subtype)) &&
+        SUCCEEDED(hr = IMFMediaType_GetUINT64(transform->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &sample_size);
+    else
+        sample_size = 0;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbSize = sample_size;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return MFCreateAttributes(attributes, 0);
+}
+
+static HRESULT WINAPI transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %#lx stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %lu, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT fill_media_type_defaults(IMFMediaType *media_type, IMFMediaType *default_type)
+{
+    UINT32 value, width, height;
+    MFVideoArea aperture = {0};
+    UINT64 value64;
+    GUID subtype;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &value64)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_SIZE, &value64)))
+            value64 = (UINT64)1920 << 32 | 1080;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, value64)))
+            return hr;
+    }
+    width = value64 >> 32;
+    height = value64;
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FRAME_RATE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_RATE, &value64)))
+            value64 = (UINT64)30000 << 32 | 1001;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, value64)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_PIXEL_ASPECT_RATIO, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_PIXEL_ASPECT_RATIO, &value64)))
+            value64 = (UINT64)1 << 32 | 1;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_PIXEL_ASPECT_RATIO, value64)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_SAMPLE_SIZE, NULL)))
+    {
+        if ((!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_SAMPLE_SIZE, &value))) &&
+                FAILED(hr = MFCalculateImageSize(&subtype, width, height, &value)))
+            return hr;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_DEFAULT_STRIDE, NULL)))
+    {
+        if ((!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_DEFAULT_STRIDE, &value))) &&
+                FAILED(hr = MFGetStrideForBitmapInfoHeader(subtype.Data1, width, (LONG *)&value)))
+            return hr;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_DEFAULT_STRIDE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_INTERLACE_MODE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_INTERLACE_MODE, &value)))
+            value = MFVideoInterlace_MixedInterlaceOrProgressive;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_INTERLACE_MODE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, &value)))
+            value = 1;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_VIDEO_ROTATION, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_VIDEO_ROTATION, &value)))
+            value = 0;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_VIDEO_ROTATION, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FIXED_SIZE_SAMPLES, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_FIXED_SIZE_SAMPLES, &value)))
+            value = 1;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, NULL)))
+    {
+        if (default_type && SUCCEEDED(hr = IMFMediaType_GetBlob(default_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                (BYTE *)&aperture, sizeof(aperture), NULL)))
+        {
+            if (FAILED(hr = IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture))))
+                return hr;
+        }
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    IMFMediaType *media_type;
+    const GUID *subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(video_formats))
+        return MF_E_NO_MORE_TYPES;
+    subtype = video_formats[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)) &&
+            SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, subtype)))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id,
+        DWORD index, IMFMediaType **type)
+{
+    IMFMediaType *media_type;
+    const GUID *subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(video_formats))
+        return MF_E_NO_MORE_TYPES;
+    subtype = video_formats[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)) &&
+            SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, subtype)))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    BOOL identical;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
+        if (IsEqualGUID(&subtype, video_formats[i]))
+            break;
+    if (i == ARRAY_SIZE(video_formats))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (transform->input_type)
+    {
+        if (SUCCEEDED(hr = IMFMediaType_Compare(transform->input_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
+        IMFMediaType_Release(transform->input_type);
+    }
+
+    IMFMediaType_AddRef((transform->input_type = type));
+
+    if (transform->output_type)
+        hr = fill_media_type_defaults(transform->input_type, transform->output_type);
+
+    if (transform->output_type && FAILED(hr = try_create_wg_transform(transform)))
+    {
+        IMFMediaType_Release(transform->input_type);
+        transform->input_type = NULL;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    BOOL identical;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
+        if (IsEqualGUID(&subtype, video_formats[i]))
+            break;
+    if (i == ARRAY_SIZE(video_formats))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (transform->output_type)
+    {
+        if (SUCCEEDED(hr = IMFMediaType_Compare(transform->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
+        IMFMediaType_Release(transform->output_type);
+    }
+
+    IMFMediaType_AddRef((transform->output_type = type));
+
+    if (transform->input_type)
+        hr = fill_media_type_defaults(transform->output_type, transform->input_type);
+
+    if (transform->input_type && FAILED(hr = try_create_wg_transform(transform)))
+    {
+        IMFMediaType_Release(transform->output_type);
+        transform->output_type = NULL;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, type %p.\n", iface, id, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!transform->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    return IMFMediaType_CopyAllItems(transform->input_type, (IMFAttributes *)ret);
+}
+
+static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, type %p.\n", iface, id, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!transform->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    return IMFMediaType_CopyAllItems(transform->output_type, (IMFAttributes *)ret);
+}
+
+static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %I64d, upper %I64d stub!\n", iface, lower, upper);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %#lx, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+
+    FIXME("iface %p, message %#x, param %Ix stub!\n", iface, message, param);
+
+    switch (message)
+    {
+    case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        memset(&transform->wg_format, 0, sizeof(transform->wg_format));
+        break;
+    default:
+        break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    struct wg_sample *wg_sample;
+    MFT_INPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!transform->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = mf_create_wg_sample(sample, &wg_sample)))
+        return hr;
+
+    hr = wg_transform_push_data(transform->wg_transform, wg_sample);
+
+    mf_destroy_wg_sample(wg_sample);
+    return hr;
+}
+
+static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct video_converter *transform = impl_from_IMFTransform(iface);
+    MFT_OUTPUT_STREAM_INFO info;
+    struct wg_sample *wg_sample;
+    MFVideoArea aperture = {0};
+    IMFMediaType *media_type;
+    UINT32 halign, valign;
+    UINT64 frame_rate;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count != 1)
+        return E_INVALIDARG;
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!transform->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(IMFMediaType_GetUINT64(transform->output_type, &MF_MT_FRAME_RATE, &frame_rate)))
+        frame_rate = (UINT64)30000 << 32 | 1001;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample) return E_INVALIDARG;
+
+    if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
+        return hr;
+
+    wg_sample->format = transform->wg_format;
+    if (wg_sample->max_size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else
+        hr = wg_transform_read_data(transform->wg_transform, wg_sample);
+
+    if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        transform->wg_format = wg_sample->format;
+        media_type = mf_media_type_from_wg_format(&wg_sample->format);
+        IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, frame_rate);
+
+        valign = transform->wg_format.u.video.width & 15;
+        halign = transform->wg_format.u.video.height & 15;
+        if (halign || valign)
+        {
+            aperture.Area.cx = transform->wg_format.u.video.width;
+            aperture.Area.cy = transform->wg_format.u.video.height;
+            IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture));
+
+            aperture.Area.cx += (16 - valign) & 15;
+            aperture.Area.cy += (16 - halign) & 15;
+            IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE,
+                    (UINT64)aperture.Area.cx << 32 | aperture.Area.cy);
+        }
+
+        IMFMediaType_Release(transform->output_type);
+        transform->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
+    mf_destroy_wg_sample(wg_sample);
+    return hr;
+}
+
+static const IMFTransformVtbl transform_vtbl =
+{
+    transform_QueryInterface,
+    transform_AddRef,
+    transform_Release,
+    transform_GetStreamLimits,
+    transform_GetStreamCount,
+    transform_GetStreamIDs,
+    transform_GetInputStreamInfo,
+    transform_GetOutputStreamInfo,
+    transform_GetAttributes,
+    transform_GetInputStreamAttributes,
+    transform_GetOutputStreamAttributes,
+    transform_DeleteInputStream,
+    transform_AddInputStreams,
+    transform_GetInputAvailableType,
+    transform_GetOutputAvailableType,
+    transform_SetInputType,
+    transform_SetOutputType,
+    transform_GetInputCurrentType,
+    transform_GetOutputCurrentType,
+    transform_GetInputStatus,
+    transform_GetOutputStatus,
+    transform_SetOutputBounds,
+    transform_ProcessEvent,
+    transform_ProcessMessage,
+    transform_ProcessInput,
+    transform_ProcessOutput,
+};
+
+HRESULT video_converter_create(REFIID riid, void **ret)
+{
+    struct video_converter *transform;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(transform = calloc(1, sizeof(*transform))))
+        return E_OUTOFMEMORY;
+
+    transform->IMFTransform_iface.lpVtbl = &transform_vtbl;
+    transform->refcount = 1;
+
+    *ret = &transform->IMFTransform_iface;
+    TRACE("Created transform %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -342,8 +342,9 @@ NTSTATUS wg_transform_create(void *args)
             }
             break;
 
-        case WG_MAJOR_TYPE_AUDIO:
         case WG_MAJOR_TYPE_VIDEO:
+            break;
+        case WG_MAJOR_TYPE_AUDIO:
         case WG_MAJOR_TYPE_UNKNOWN:
             GST_FIXME("Format %u not implemented!", input_format.major_type);
             gst_caps_unref(raw_caps);
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -79,3 +79,9 @@ coclass CWMADecMediaObject {};
     uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
 ]
 coclass CMSH264DecoderMFT {}
+
+[
+    threading(both),
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO {}
diff --git a/include/wmcodecdsp.idl b/include/wmcodecdsp.idl
index 11111111111..11111111111 100644
--- a/include/wmcodecdsp.idl
+++ b/include/wmcodecdsp.idl
@@ -49,3 +49,8 @@ coclass CWMADecMediaObject {};
     uuid(93af0c51-2275-45d2-a35b-f2ba21caed00)
 ]
 coclass AACMFTEncoder {};
+
+[
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO {}
-- 
2.35.1

