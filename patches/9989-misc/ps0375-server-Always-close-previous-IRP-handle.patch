From c0c60321fdac2a2ae103742740b141b92b25c83a Mon Sep 17 00:00:00 2001
From: Daniel Lehman <dlehman@esri.com>
Date: Thu, 10 Mar 2022 16:18:13 -0800
Subject: [PATCH] server: Always close previous IRP handle.

Signed-off-by: Daniel Lehman <dlehman@esri.com>
---
there's a handle leak in get_next_device_request that for long running
programs can exhaust the handle table and cause a hang

currently, req->prev is only closed if there's an associated req->async
but this isn't case for device_open_file

from the history, it looks like previously the handle was
always closed in get_next_device_request if (req->prev)
restoring that fixes the leak

i'm not sure how to add a wine test for this, but a very simple repro case is:
for (i = 0; i < loops; i++)
{
    h = CreateFileW(L"c:/windows/hh.exe", FILE_READ_ATTRIBUTES, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    GetFileInformationByHandle(h, &info);
    CloseHandle(h);
}
---
 server/device.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/server/device.c b/server/device.c
index d6288920bf4..436dac6bfe9 100644
--- a/server/device.c
+++ b/server/device.c
@@ -959,7 +959,6 @@ DECL_HANDLER(get_next_device_request)
             if (req->prev)
             {
                 set_irp_result( irp, req->iosb_status, get_req_data(), get_req_data_size(), req->result );
-                close_handle( current->process, req->prev );  /* avoid an extra round-trip for close */
             }
             else
             {
@@ -977,6 +976,9 @@ DECL_HANDLER(get_next_device_request)
             set_irp_result( irp, req->status, NULL, 0, 0 );
         }
 
+        if (req->prev)
+            close_handle( current->process, req->prev );  /* avoid an extra round-trip for close */
+
         free_irp_params( irp );
         release_object( irp );
         manager->current_call = NULL;

-- 
2.27.0

