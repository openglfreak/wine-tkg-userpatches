From 7c84e2c9efaf3614b530d25443a1222852fc13c7 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 8 Jun 2021 16:01:54 +0300
Subject: [PATCH 1/2] winex11.drv: Send missed KEYUP events after a keyboard grab
 is released.

Full focus lost / focus gained events on the Windows side are not
feasible for X11's keyboard grabs (see XGrabKeyboard()), and using them
would degrade user experience, especially with our full screen hack, by
causing the window to minimize or flash multiple times depending on a
game/window manager combo.

There's nothing else we could map X11's keyboard grab to force the
program to resync its key state.

This change attempts to improve user experience by syncing any missed
key release events that happened during the grab so the user won't end
up with stuck keys.

There's no syncing of key presses as those are more problematic because
of window manager quirks, e.g. on KDE it may end up syncing the Tab
press portion of Alt+Tab. Luckily missing key events for keys that were
pressed and not released while the WM had the keyboard grab is not
nearly as confusing as stuck keys.

For Warhammer: Chaosbane and Far Cry Primal keyboard state after focus
loss.

CW-Bug-ID: #17046
CW-Bug-ID: #18904
---
 dlls/winex11.drv/event.c    |  3 +++
 dlls/winex11.drv/keyboard.c | 43 +++++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/x11drv.h   |  1 +
 3 files changed, 45 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 11111111111..11111111111 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -911,6 +911,9 @@ BOOL x11drv_handle_focus_in_event( HWND hwnd, XEvent *xev, Time time )
         return FALSE;
     }
 
+    if (event->mode == NotifyUngrab)
+        x11drv_thread_data()->kbd_grab_release_hwnd = hwnd;
+
     /* ask the desktop window to re-apply the current ClipCursor rect */
     send_message( NtUserGetDesktopWindow(), WM_X11DRV_DESKTOP_CLIP_CURSOR, FALSE, FALSE );
 
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 11111111111..11111111111 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1212,11 +1212,19 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     int i, j;
     BYTE keystate[256];
     WORD vkey;
+    DWORD flags;
+    KeyCode keycode;
+    HWND kbd_grab_release_hwnd;
     BOOL changed = FALSE;
     struct {
         WORD vkey;
+        WORD scan;
         WORD pressed;
     } keys[256];
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    kbd_grab_release_hwnd = thread_data->kbd_grab_release_hwnd;
+    thread_data->kbd_grab_release_hwnd = NULL;
 
     if (!get_async_key_state( keystate )) return FALSE;
 
@@ -1231,11 +1239,17 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     {
         for (j = 0; j < 8; j++)
         {
-            vkey = keyc2vkey[(i * 8) + j];
+            keycode = (i * 8) + j;
+            vkey = keyc2vkey[keycode];
 
             /* If multiple keys map to the same vkey, we want to report it as
              * pressed iff any of them are pressed. */
-            if (!keys[vkey & 0xff].vkey) keys[vkey & 0xff].vkey = vkey;
+            if (!keys[vkey & 0xff].vkey)
+            {
+                keys[vkey & 0xff].vkey = vkey;
+                keys[vkey & 0xff].scan = keyc2scan[keycode] & 0xff;
+            }
+
             if (event->xkeymap.key_vector[i] & (1<<j)) keys[vkey & 0xff].pressed = TRUE;
         }
     }
@@ -1247,6 +1261,31 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
             TRACE( "Adjusting state for vkey %#.2x. State before %#.2x\n",
                    keys[vkey].vkey, keystate[vkey]);
 
+            /* This KeymapNotify follows a FocusIn(mode=NotifyUngrab) event,
+             * which is caused by a keyboard grab being released.
+             * See XGrabKeyboard().
+             *
+             * We might have missed some key press/release events while the
+             * keyboard was grabbed, but keyboard grab doesn't generate focus
+             * lost / focus gained events on the Windows side, so the affected
+             * program is not aware that it needs to resync the keyboard state.
+             *
+             * This, for example, may cause Alt being stuck after using Alt+Tab.
+             *
+             * To work around that problem we sync any possible key releases.
+             *
+             * Syncing key presses is not feasible as window managers differ in
+             * event sequences, e.g. KDE performs two keyboard grabs for
+             * Alt+Tab, which would sync the Tab press.
+             */
+            if (kbd_grab_release_hwnd && !keys[vkey].pressed)
+            {
+                TRACE( "Sending KEYUP for a modifier %#.2x\n", vkey);
+                flags = KEYEVENTF_KEYUP;
+                if (keys[vkey].vkey & 0x1000) flags |= KEYEVENTF_EXTENDEDKEY;
+                X11DRV_send_keyboard_input( kbd_grab_release_hwnd, vkey, keys[vkey].scan, flags, GetTickCount() );
+            }
+
             update_key_state( keystate, vkey, keys[vkey].pressed );
             changed = TRUE;
         }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 11111111111..11111111111 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -378,6 +378,7 @@ struct x11drv_thread_data
     HWND     last_focus;           /* last window that had focus */
     DWORD    activating_time;      /* time of the last SetActiveWindow call */
     HWND     activating_hwnd;      /* window currently activating */
+    HWND     kbd_grab_release_hwnd;/* window that should receive modifier release events */
     XIM      xim;                  /* input method */
     HWND     last_xic_hwnd;        /* last xic window */
     XFontSet font_set;             /* international text drawing font set */
