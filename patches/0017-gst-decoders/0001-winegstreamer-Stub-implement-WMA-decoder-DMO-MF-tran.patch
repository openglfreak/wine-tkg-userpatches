From 0eed81f606087c977a093780420460b07f506e9a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 27 Jan 2022 15:33:41 +0100
Subject: [PATCH 01/36] winegstreamer: Stub implement WMA decoder DMO / MF
 transform.

Final Fantasy XIV intro videos require media_object_GetStreamCount and
property_bag_Write to return S_OK in order to not get stuck. This could
be done in a separate commit but would cause a temporary regression.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/mf/tests/mf.c                           |   1 -
 dlls/winegstreamer/Makefile.in               |   5 +-
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/main.c                    |  26 +
 dlls/winegstreamer/mfplat.c                  |  28 +-
 dlls/winegstreamer/quartz_parser.c           |   2 +-
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 dlls/winegstreamer/wma_decoder.c             | 553 +++++++++++++++++++
 dlls/wmadmod/tests/wmadmod.c                 |   5 -
 9 files changed, 617 insertions(+), 10 deletions(-)
 create mode 100644 dlls/winegstreamer/wma_decoder.c

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index dede008fbd9..9bc36518df1 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -5743,7 +5743,6 @@ static void test_wma_decoder(void)
             &transform, &class_id))
         goto failed;
 
-    todo_wine
     check_interface(transform, &IID_IMediaObject, TRUE);
 
     /* check default media types */
diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 062fe57bdbb..1706effbd20 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -2,7 +2,7 @@ EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = winegstreamer.dll
 UNIXLIB   = winegstreamer.so
 IMPORTLIB = winegstreamer
-IMPORTS   = strmbase ole32
+IMPORTS   = strmbase ole32 msdmo
 DELAYIMPORTS = mfplat
 EXTRAINCL = $(GSTREAMER_CFLAGS)
 EXTRALIBS = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)
@@ -16,7 +16,8 @@ C_SRCS = \
 	wg_parser.c \
 	wm_asyncreader.c \
 	wm_reader.c \
-	wm_syncreader.c
+	wm_syncreader.c \
+	wma_decoder.c
 
 IDL_SRCS = \
 	winegstreamer_classes.idl
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 9e1d67417d4..222bce3b2c7 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -102,6 +102,7 @@ HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 HRESULT wave_parser_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 
 bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm);
 bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index ac9a3201792..260dd208e2f 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -25,7 +25,9 @@
 #include "gst_private.h"
 #include "winternl.h"
 #include "rpcproxy.h"
+#include "dmoreg.h"
 #include "gst_guids.h"
+#include "wmcodecdsp.h"
 
 static unixlib_handle_t unix_handle;
 
@@ -339,6 +341,7 @@ static struct class_factory avi_splitter_cf = {{&class_factory_vtbl}, avi_splitt
 static struct class_factory decodebin_parser_cf = {{&class_factory_vtbl}, decodebin_parser_create};
 static struct class_factory mpeg_splitter_cf = {{&class_factory_vtbl}, mpeg_splitter_create};
 static struct class_factory wave_parser_cf = {{&class_factory_vtbl}, wave_parser_create};
+static struct class_factory wma_decoder_cf = {{&class_factory_vtbl}, wma_decoder_create};
 
 HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
 {
@@ -361,6 +364,8 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
         factory = &mpeg_splitter_cf;
     else if (IsEqualGUID(clsid, &CLSID_WAVEParser))
         factory = &wave_parser_cf;
+    else if (IsEqualGUID(clsid, &CLSID_WMADecMediaObject))
+        factory = &wma_decoder_cf;
     else
     {
         FIXME("%s not implemented, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid(clsid));
@@ -522,6 +527,19 @@ static const REGFILTER2 reg_decodebin_parser =
 
 HRESULT WINAPI DllRegisterServer(void)
 {
+    DMO_PARTIAL_MEDIATYPE wma_decoder_output[2] =
+    {
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_PCM},
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_IEEE_FLOAT},
+    };
+    DMO_PARTIAL_MEDIATYPE wma_decoder_input[4] =
+    {
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_MSAUDIO1},
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO2},
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO3},
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO_LOSSLESS},
+    };
+
     IFilterMapper2 *mapper;
     HRESULT hr;
 
@@ -543,6 +561,10 @@ HRESULT WINAPI DllRegisterServer(void)
 
     IFilterMapper2_Release(mapper);
 
+    if (FAILED(hr = DMORegister(L"WMA Decoder DMO", &CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER,
+            0, ARRAY_SIZE(wma_decoder_input), wma_decoder_input, ARRAY_SIZE(wma_decoder_output), wma_decoder_output)))
+        return hr;
+
     return mfplat_DllRegisterServer();
 }
 
@@ -566,5 +588,9 @@ HRESULT WINAPI DllUnregisterServer(void)
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &CLSID_WAVEParser);
 
     IFilterMapper2_Release(mapper);
+
+    if (FAILED(hr = DMOUnregister(&CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER)))
+        return hr;
+
     return S_OK;
 }
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 5404728ba83..6a58f444204 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -21,6 +21,7 @@
 
 #include "ks.h"
 #include "ksmedia.h"
+#include "wmcodecdsp.h"
 #include "initguid.h"
 #include "mfapi.h"
 
@@ -442,6 +443,20 @@ static const GUID *audio_converter_supported_types[] =
     &MFAudioFormat_Float,
 };
 
+static WCHAR wma_decoderW[] = L"WMAudio Decoder MFT";
+static const GUID *wma_decoder_input_types[] =
+{
+    &MEDIASUBTYPE_MSAUDIO1,
+    &MFAudioFormat_WMAudioV8,
+    &MFAudioFormat_WMAudioV9,
+    &MFAudioFormat_WMAudio_Lossless,
+};
+static const GUID *wma_decoder_output_types[] =
+{
+    &MFAudioFormat_PCM,
+    &MFAudioFormat_Float,
+};
+
 static const struct mft
 {
     const GUID *clsid;
@@ -467,13 +482,24 @@ mfts[] =
         ARRAY_SIZE(audio_converter_supported_types),
         audio_converter_supported_types,
     },
+    {
+        &CLSID_WMADecMediaObject,
+        &MFT_CATEGORY_AUDIO_DECODER,
+        wma_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Audio,
+        ARRAY_SIZE(wma_decoder_input_types),
+        wma_decoder_input_types,
+        ARRAY_SIZE(wma_decoder_output_types),
+        wma_decoder_output_types,
+    },
 };
 
 HRESULT mfplat_DllRegisterServer(void)
 {
     unsigned int i, j;
     HRESULT hr;
-    MFT_REGISTER_TYPE_INFO input_types[2], output_types[2];
+    MFT_REGISTER_TYPE_INFO input_types[4], output_types[2];
 
     for (i = 0; i < ARRAY_SIZE(mfts); i++)
     {
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 8532fc1af8b..e8d56d54785 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -29,8 +29,8 @@
 #include "dvdmedia.h"
 #include "mmreg.h"
 #include "ks.h"
-#include "initguid.h"
 #include "wmcodecdsp.h"
+#include "initguid.h"
 #include "ksmedia.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(quartz);
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 072ec90eea4..90dc1dc839b 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -67,3 +67,9 @@ coclass GStreamerByteStreamHandler {}
     uuid(6a170414-aad9-4693-b806-3a0c47c570d6)
 ]
 coclass WINEAudioConverter { }
+
+[
+    threading(both),
+    uuid(2eeb4adf-4578-4d10-bca7-bb955f56320a)
+]
+coclass CWMADecMediaObject {};
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
new file mode 100644
index 00000000000..f034c34395e
--- /dev/null
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -0,0 +1,553 @@
+/* WMA Decoder DMO / MF Transform
+ *
+ * Copyright 2022 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wmadec);
+
+struct wma_decoder
+{
+    IUnknown IUnknown_inner;
+    IMFTransform IMFTransform_iface;
+    IMediaObject IMediaObject_iface;
+    IPropertyBag IPropertyBag_iface;
+    IUnknown *outer;
+    LONG refcount;
+};
+
+static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IUnknown_inner);
+}
+
+static HRESULT WINAPI unknown_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+{
+    struct wma_decoder *decoder = impl_from_IUnknown(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown))
+        *out = &decoder->IUnknown_inner;
+    else if (IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else if (IsEqualGUID(iid, &IID_IMediaObject))
+        *out = &decoder->IMediaObject_iface;
+    else if (IsEqualIID(iid, &IID_IPropertyBag))
+        *out = &decoder->IPropertyBag_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI unknown_AddRef(IUnknown *iface)
+{
+    struct wma_decoder *decoder = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI unknown_Release(IUnknown *iface)
+{
+    struct wma_decoder *decoder = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
+
+    if (!refcount)
+        free(decoder);
+
+    return refcount;
+}
+
+static const IUnknownVtbl unknown_vtbl =
+{
+    unknown_QueryInterface,
+    unknown_AddRef,
+    unknown_Release,
+};
+
+static struct wma_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IMFTransform_iface);
+}
+
+static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    return IUnknown_QueryInterface(decoder->outer, iid, out);
+}
+
+static ULONG WINAPI transform_AddRef(IMFTransform *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    return IUnknown_AddRef(decoder->outer);
+}
+
+static ULONG WINAPI transform_Release(IMFTransform *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    return IUnknown_Release(decoder->outer);
+}
+
+static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n", iface,
+            input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %u, info %p stub!\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %u, info %p stub!\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %u stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("iface %p, id %u, type %p, flags %#x stub!\n", iface, id, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("iface %p, id %u, type %p, flags %#x stub!\n", iface, id, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface, wine_dbgstr_longlong(lower),
+            wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("iface %p, id %u, sample %p, flags %#x stub!\n", iface, id, sample, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("iface %p, flags %#x, count %u, samples %p, status %p stub!\n", iface, flags, count, samples, status);
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl transform_vtbl =
+{
+    transform_QueryInterface,
+    transform_AddRef,
+    transform_Release,
+    transform_GetStreamLimits,
+    transform_GetStreamCount,
+    transform_GetStreamIDs,
+    transform_GetInputStreamInfo,
+    transform_GetOutputStreamInfo,
+    transform_GetAttributes,
+    transform_GetInputStreamAttributes,
+    transform_GetOutputStreamAttributes,
+    transform_DeleteInputStream,
+    transform_AddInputStreams,
+    transform_GetInputAvailableType,
+    transform_GetOutputAvailableType,
+    transform_SetInputType,
+    transform_SetOutputType,
+    transform_GetInputCurrentType,
+    transform_GetOutputCurrentType,
+    transform_GetInputStatus,
+    transform_GetOutputStatus,
+    transform_SetOutputBounds,
+    transform_ProcessEvent,
+    transform_ProcessMessage,
+    transform_ProcessInput,
+    transform_ProcessOutput,
+};
+
+static inline struct wma_decoder *impl_from_IMediaObject(IMediaObject *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IMediaObject_iface);
+}
+
+static HRESULT WINAPI media_object_QueryInterface(IMediaObject *iface, REFIID iid, void **obj)
+{
+    struct wma_decoder *decoder = impl_from_IMediaObject(iface);
+    return IUnknown_QueryInterface(decoder->outer, iid, obj);
+}
+
+static ULONG WINAPI media_object_AddRef(IMediaObject *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMediaObject(iface);
+    return IUnknown_AddRef(decoder->outer);
+}
+
+static ULONG WINAPI media_object_Release(IMediaObject *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMediaObject(iface);
+    return IUnknown_Release(decoder->outer);
+}
+
+static HRESULT WINAPI media_object_GetStreamCount(IMediaObject *iface, DWORD *input, DWORD *output)
+{
+    FIXME("iface %p, input %p, output %p semi-stub!\n", iface, input, output);
+    *input = *output = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI media_object_GetInputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetOutputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetInputType(IMediaObject *iface, DWORD index, DWORD type_index,
+        DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type_index %u, type %p stub!\n", iface, index, type_index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetOutputType(IMediaObject *iface, DWORD index, DWORD type_index,
+        DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type_index %u, type %p stub!\n", iface, index, type_index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index,
+        const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    FIXME("iface %p, index %u, type %p, flags %#x stub!\n", iface, index, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_SetOutputType(IMediaObject *iface, DWORD index,
+        const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    FIXME("iface %p, index %u, type %p, flags %#x stub!\n", iface, index, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type %p stub!\n", iface, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetOutputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type %p stub!\n", iface, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetInputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size,
+        DWORD *lookahead, DWORD *alignment)
+{
+    FIXME("iface %p, index %u, size %p, lookahead %p, alignment %p stub!\n", iface, index, size,
+            lookahead, alignment);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetOutputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size, DWORD *alignment)
+{
+    FIXME("iface %p, index %u, size %p, alignment %p stub!\n", iface, index, size, alignment);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
+{
+    FIXME("iface %p, index %u, latency %p stub!\n", iface, index, latency);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_SetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME latency)
+{
+    FIXME("iface %p, index %u, latency %s stub!\n", iface, index, wine_dbgstr_longlong(latency));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_Flush(IMediaObject *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_Discontinuity(IMediaObject *iface, DWORD index)
+{
+    FIXME("iface %p, index %u stub!\n", iface, index);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_AllocateStreamingResources(IMediaObject *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_FreeStreamingResources(IMediaObject *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_GetInputStatus(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_ProcessInput(IMediaObject *iface, DWORD index,
+        IMediaBuffer *buffer, DWORD flags, REFERENCE_TIME timestamp, REFERENCE_TIME timelength)
+{
+    FIXME("iface %p, index %u, buffer %p, flags %#x, timestamp %s, timelength %s stub!\n", iface,
+            index, buffer, flags, wine_dbgstr_longlong(timestamp), wine_dbgstr_longlong(timelength));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_ProcessOutput(IMediaObject *iface, DWORD flags, DWORD count,
+        DMO_OUTPUT_DATA_BUFFER *buffers, DWORD *status)
+{
+    FIXME("iface %p, flags %#x, count %u, buffers %p, status %p stub!\n", iface, flags, count, buffers, status);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI media_object_Lock(IMediaObject *iface, LONG lock)
+{
+    FIXME("iface %p, lock %d stub!\n", iface, lock);
+    return E_NOTIMPL;
+}
+
+static const IMediaObjectVtbl media_object_vtbl =
+{
+    media_object_QueryInterface,
+    media_object_AddRef,
+    media_object_Release,
+    media_object_GetStreamCount,
+    media_object_GetInputStreamInfo,
+    media_object_GetOutputStreamInfo,
+    media_object_GetInputType,
+    media_object_GetOutputType,
+    media_object_SetInputType,
+    media_object_SetOutputType,
+    media_object_GetInputCurrentType,
+    media_object_GetOutputCurrentType,
+    media_object_GetInputSizeInfo,
+    media_object_GetOutputSizeInfo,
+    media_object_GetInputMaxLatency,
+    media_object_SetInputMaxLatency,
+    media_object_Flush,
+    media_object_Discontinuity,
+    media_object_AllocateStreamingResources,
+    media_object_FreeStreamingResources,
+    media_object_GetInputStatus,
+    media_object_ProcessInput,
+    media_object_ProcessOutput,
+    media_object_Lock,
+};
+
+static inline struct wma_decoder *impl_from_IPropertyBag(IPropertyBag *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IPropertyBag_iface);
+}
+
+static HRESULT WINAPI property_bag_QueryInterface(IPropertyBag *iface, REFIID iid, void **out)
+{
+    struct wma_decoder *filter = impl_from_IPropertyBag(iface);
+    return IUnknown_QueryInterface(filter->outer, iid, out);
+}
+
+static ULONG WINAPI property_bag_AddRef(IPropertyBag *iface)
+{
+    struct wma_decoder *filter = impl_from_IPropertyBag(iface);
+    return IUnknown_AddRef(filter->outer);
+}
+
+static ULONG WINAPI property_bag_Release(IPropertyBag *iface)
+{
+    struct wma_decoder *filter = impl_from_IPropertyBag(iface);
+    return IUnknown_Release(filter->outer);
+}
+
+static HRESULT WINAPI property_bag_Read(IPropertyBag *iface, const WCHAR *prop_name, VARIANT *value,
+        IErrorLog *error_log)
+{
+    FIXME("iface %p, prop_name %s, value %p, error_log %p stub!\n", iface, debugstr_w(prop_name), value, error_log);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI property_bag_Write(IPropertyBag *iface, const WCHAR *prop_name, VARIANT *value)
+{
+    FIXME("iface %p, prop_name %s, value %p stub!\n", iface, debugstr_w(prop_name), value);
+    return S_OK;
+}
+
+static const IPropertyBagVtbl property_bag_vtbl =
+{
+    property_bag_QueryInterface,
+    property_bag_AddRef,
+    property_bag_Release,
+    property_bag_Read,
+    property_bag_Write,
+};
+
+HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out)
+{
+    struct wma_decoder *decoder;
+
+    TRACE("outer %p, out %p.\n", outer, out);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IUnknown_inner.lpVtbl = &unknown_vtbl;
+    decoder->IMFTransform_iface.lpVtbl = &transform_vtbl;
+    decoder->IMediaObject_iface.lpVtbl = &media_object_vtbl;
+    decoder->IPropertyBag_iface.lpVtbl = &property_bag_vtbl;
+    decoder->refcount = 1;
+    decoder->outer = outer ? outer : &decoder->IUnknown_inner;
+
+    *out = &decoder->IUnknown_inner;
+    TRACE("Created decoder %p\n", *out);
+    return S_OK;
+}
diff --git a/dlls/wmadmod/tests/wmadmod.c b/dlls/wmadmod/tests/wmadmod.c
index e95e297eaca..b49b609dac3 100644
--- a/dlls/wmadmod/tests/wmadmod.c
+++ b/dlls/wmadmod/tests/wmadmod.c
@@ -52,11 +52,8 @@ static void test_DMOGetTypes(void)
 
     hr = DMOGetTypes( &CLSID_CWMADecMediaObject, ARRAY_SIZE(input), &input_count, input,
                       ARRAY_SIZE(output), &output_count, output );
-    todo_wine
     ok( hr == S_OK, "DMOGetTypes returned %#lx\n", hr );
-    todo_wine
     ok( input_count == ARRAY_SIZE(expect_input), "got input_count %lu\n", input_count );
-    todo_wine
     ok( output_count == ARRAY_SIZE(expect_output), "got output_count %lu\n", output_count );
 
     for (i = 0; i < input_count; ++i)
@@ -135,9 +132,7 @@ static void test_interfaces(void)
 
     hr = CoCreateInstance( &CLSID_CWMADecMediaObject, &outer, CLSCTX_INPROC_SERVER, &IID_IUnknown,
                            (void **)&unknown );
-    todo_wine
     ok( hr == S_OK, "CoCreateInstance returned %#lx\n", hr );
-    if (FAILED(hr)) return;
     hr = IUnknown_QueryInterface( unknown, &IID_IMFTransform, (void **)&transform );
     ok( hr == S_OK, "QueryInterface returned %#lx\n", hr );
     hr = IUnknown_QueryInterface( unknown, &IID_IMediaObject, (void **)&media_object );
-- 
2.35.1

