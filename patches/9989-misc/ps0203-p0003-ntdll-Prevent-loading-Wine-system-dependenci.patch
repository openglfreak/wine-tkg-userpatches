From: Zebediah Figura <zfigura@codeweavers.com>
Subject: [PATCH 3/3] ntdll: Prevent loading Wine system dependencies in place of identically named application DLLs.
Message-Id: <20211101063731.260785-3-zfigura@codeweavers.com>
Date: Mon,  1 Nov 2021 01:37:31 -0500
In-Reply-To: <20211101063731.260785-1-zfigura@codeweavers.com>
References: <20211101063731.260785-1-zfigura@codeweavers.com>

That is, load Wine system dependencies only when they are imported from Wine
builtins or other system dependencies, and do not match a Wine system dependency
by its base name when looking for already-loaded modules.

The reasoning is that it is possible for an application to ship, and expect to
use, a newer version of a MinGW-compiled library, or one with custom patches, or
possibly an unrelated library with the same name. We don't want to offer Wine's
system dependencies in place of the application's, or vice versa.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
---
 dlls/ntdll/loader.c | 45 ++++++++++++++++++++++++++-------------------
 include/winternl.h  |  1 +
 2 files changed, 27 insertions(+), 19 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 42aa787cf34..fa18c6c4a26 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -187,7 +187,7 @@ static WINE_MODREF *current_modref;
 static LDR_DDAG_NODE *node_ntdll, *node_kernel32;
 
 static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WCHAR *default_ext,
-                          DWORD flags, WINE_MODREF** pwm );
+                          DWORD flags, WINE_MODREF** pwm, BOOL system );
 static NTSTATUS process_attach( LDR_DDAG_NODE *node, LPVOID lpReserved );
 static FARPROC find_ordinal_export( HMODULE module, const IMAGE_EXPORT_DIRECTORY *exports,
                                     DWORD exp_size, DWORD ordinal, LPCWSTR load_path );
@@ -506,21 +506,23 @@ static WINE_MODREF *get_modref( HMODULE hmod )
  * Find a module from its base name.
  * The loader_section must be locked while calling this function
  */
-static WINE_MODREF *find_basename_module( LPCWSTR name )
+static WINE_MODREF *find_basename_module( const WCHAR *name, BOOL system )
 {
     PLIST_ENTRY mark, entry;
     UNICODE_STRING name_str;
 
     RtlInitUnicodeString( &name_str, name );
 
-    if (cached_modref && RtlEqualUnicodeString( &name_str, &cached_modref->ldr.BaseDllName, TRUE ))
+    if (cached_modref && RtlEqualUnicodeString( &name_str, &cached_modref->ldr.BaseDllName, TRUE )
+            && system == !!(cached_modref->ldr.Flags & LDR_WINE_SYSTEM))
         return cached_modref;
 
     mark = &hash_table[hash_basename(name)];
     for (entry = mark->Flink; entry != mark; entry = entry->Flink)
     {
         LDR_DATA_TABLE_ENTRY *mod = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, HashLinks);
-        if (RtlEqualUnicodeString( &name_str, &mod->BaseDllName, TRUE ))
+        if (RtlEqualUnicodeString( &name_str, &mod->BaseDllName, TRUE )
+                && system == !!(mod->Flags & LDR_WINE_SYSTEM))
         {
             cached_modref = CONTAINING_RECORD(mod, WINE_MODREF, ldr);
             return cached_modref;
@@ -619,6 +621,7 @@ static WINE_MODREF **grow_module_deps( WINE_MODREF *wm, int count )
  */
 static FARPROC find_forwarded_export( HMODULE module, const char *forward, LPCWSTR load_path )
 {
+    BOOL system = !!(get_modref( module )->ldr.Flags & (LDR_WINE_SYSTEM | LDR_WINE_BUILTIN));
     const IMAGE_EXPORT_DIRECTORY *exports;
     DWORD exp_size;
     WINE_MODREF *wm;
@@ -638,10 +641,10 @@ static FARPROC find_forwarded_export( HMODULE module, const char *forward, LPCWS
     if (!wcschr( mod_name, '.' ))
         memcpy( mod_name + (end - forward), L".dll", sizeof(L".dll") );
 
-    if (!(wm = find_basename_module( mod_name )))
+    if (!(wm = find_basename_module( mod_name, system )))
     {
         TRACE( "delay loading %s for '%s'\n", debugstr_w(mod_name), forward );
-        if (load_dll( load_path, mod_name, L".dll", 0, &wm ) == STATUS_SUCCESS &&
+        if (load_dll( load_path, mod_name, L".dll", 0, &wm, system ) == STATUS_SUCCESS &&
             !(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS))
         {
             if (!imports_fixup_done && current_modref)
@@ -809,6 +812,7 @@ void * WINAPI RtlFindExportedRoutineByName( HMODULE module, const char *name )
  */
 static BOOL import_dll( HMODULE module, const IMAGE_IMPORT_DESCRIPTOR *descr, LPCWSTR load_path, WINE_MODREF **pwm )
 {
+    BOOL system = !!(current_modref->ldr.Flags & (LDR_WINE_SYSTEM | LDR_WINE_BUILTIN));
     NTSTATUS status;
     WINE_MODREF *wmImp;
     HMODULE imp_mod;
@@ -842,7 +846,7 @@ static BOOL import_dll( HMODULE module, const IMAGE_IMPORT_DESCRIPTOR *descr, LP
     {
         ascii_to_unicode( buffer, name, len );
         buffer[len] = 0;
-        status = load_dll( load_path, buffer, L".dll", 0, &wmImp );
+        status = load_dll( load_path, buffer, L".dll", 0, &wmImp, system );
     }
     else  /* need to allocate a larger buffer */
     {
@@ -850,7 +854,7 @@ static BOOL import_dll( HMODULE module, const IMAGE_IMPORT_DESCRIPTOR *descr, LP
         if (!ptr) return FALSE;
         ascii_to_unicode( ptr, name, len );
         ptr[len] = 0;
-        status = load_dll( load_path, ptr, L".dll", 0, &wmImp );
+        status = load_dll( load_path, ptr, L".dll", 0, &wmImp, system );
         RtlFreeHeap( GetProcessHeap(), 0, ptr );
     }
 
@@ -1131,7 +1135,7 @@ static NTSTATUS fixup_imports_ilonly( WINE_MODREF *wm, LPCWSTR load_path, void *
     prev = current_modref;
     current_modref = wm;
     assert( !wm->ldr.DdagNode->Dependencies.Tail );
-    if (!(status = load_dll( load_path, L"mscoree.dll", NULL, 0, &imp ))
+    if (!(status = load_dll( load_path, L"mscoree.dll", NULL, 0, &imp, FALSE ))
           && !add_module_dependency_after( wm->ldr.DdagNode, imp->ldr.DdagNode, NULL ))
         status = STATUS_NO_MEMORY;
     current_modref = prev;
@@ -2802,7 +2806,7 @@ done:
  */
 static NTSTATUS find_dll_file( const WCHAR *load_path, const WCHAR *libname, const WCHAR *default_ext,
                                UNICODE_STRING *nt_name, WINE_MODREF **pwm, HANDLE *mapping,
-                               SECTION_IMAGE_INFORMATION *image_info, struct file_id *id )
+                               SECTION_IMAGE_INFORMATION *image_info, struct file_id *id, BOOL system )
 {
     WCHAR *ext, *dllname;
     NTSTATUS status;
@@ -2843,7 +2847,7 @@ static NTSTATUS find_dll_file( const WCHAR *load_path, const WCHAR *libname, con
         else
         {
             if (status != STATUS_SXS_KEY_NOT_FOUND) goto done;
-            if ((*pwm = find_basename_module( libname )) != NULL)
+            if ((*pwm = find_basename_module( libname, system )) != NULL)
             {
                 status = STATUS_SUCCESS;
                 goto done;
@@ -2876,7 +2880,7 @@ done:
  * The loader_section must be locked while calling this function.
  */
 static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WCHAR *default_ext,
-                          DWORD flags, WINE_MODREF** pwm )
+                          DWORD flags, WINE_MODREF **pwm, BOOL system )
 {
     UNICODE_STRING nt_name;
     struct file_id id;
@@ -2887,10 +2891,10 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
 
     TRACE( "looking for %s in %s\n", debugstr_w(libname), debugstr_w(load_path) );
 
-    if (system_dll_path.Buffer)
-        nts = find_dll_file( system_dll_path.Buffer, libname, default_ext, &nt_name, pwm, &mapping, &image_info, &id );
+    if (system && system_dll_path.Buffer)
+        nts = find_dll_file( system_dll_path.Buffer, libname, default_ext, &nt_name, pwm, &mapping, &image_info, &id, TRUE );
     if (nts)
-        nts = find_dll_file( load_path, libname, default_ext, &nt_name, pwm, &mapping, &image_info, &id );
+        nts = find_dll_file( load_path, libname, default_ext, &nt_name, pwm, &mapping, &image_info, &id, FALSE );
 
     if (*pwm)  /* found already loaded module */
     {
@@ -2927,6 +2931,9 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, const WC
         break;
     }
 
+    if (system)
+        (*pwm)->ldr.Flags |= LDR_WINE_SYSTEM;
+
     if (NtCurrentTeb64())
         NtCurrentTeb64()->Tib.ArbitraryUserPointer = prev;
     else
@@ -2984,7 +2991,7 @@ NTSTATUS WINAPI DECLSPEC_HOTPATCH LdrLoadDll(LPCWSTR path_name, DWORD flags,
 
     RtlEnterCriticalSection( &loader_section );
 
-    nts = load_dll( path_name, libname->Buffer, L".dll", flags, &wm );
+    nts = load_dll( path_name, libname->Buffer, L".dll", flags, &wm, FALSE );
 
     if (nts == STATUS_SUCCESS && !(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS))
     {
@@ -3059,7 +3066,7 @@ NTSTATUS WINAPI LdrGetDllHandleEx( ULONG flags, LPCWSTR load_path, ULONG *dll_ch
 
     RtlEnterCriticalSection( &loader_section );
 
-    status = find_dll_file( load_path, name->Buffer, L".dll", &nt_name, &wm, &mapping, &image_info, &id );
+    status = find_dll_file( load_path, name->Buffer, L".dll", &nt_name, &wm, &mapping, &image_info, &id, FALSE );
 
     if (wm) *base = wm->ldr.DllBase;
     else
@@ -3740,7 +3747,7 @@ static void init_wow64( CONTEXT *context )
         NTSTATUS status;
         static const WCHAR wow64_path[] = L"C:\\windows\\system32\\wow64.dll";
 
-        if ((status = load_dll( NULL, wow64_path, NULL, 0, &wm )))
+        if ((status = load_dll( NULL, wow64_path, NULL, 0, &wm, FALSE )))
         {
             ERR( "could not load %s, status %x\n", debugstr_w(wow64_path), status );
             NtTerminateProcess( GetCurrentProcess(), status );
@@ -3891,7 +3898,7 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
 
         if (NtCurrentTeb()->WowTebOffset) init_wow64( context );
 
-        if ((status = load_dll( NULL, L"kernel32.dll", NULL, 0, &kernel32 )) != STATUS_SUCCESS)
+        if ((status = load_dll( NULL, L"kernel32.dll", NULL, 0, &kernel32, FALSE )) != STATUS_SUCCESS)
         {
             MESSAGE( "wine: could not load kernel32.dll, status %x\n", status );
             NtTerminateProcess( GetCurrentProcess(), status );
diff --git a/include/winternl.h b/include/winternl.h
index 5da3e010bf0..5d4be728b28 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -3393,6 +3393,7 @@ typedef void (CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION)(ULONG, LDR_DLL_NOTIFICAT
 #define LDR_COR_ILONLY                  0x01000000
 
 /* these ones is Wine specific */
+#define LDR_WINE_SYSTEM                 0x20000000
 #define LDR_DONT_RESOLVE_REFS           0x40000000
 #define LDR_WINE_BUILTIN                0x80000000
 

-- 
2.33.0

