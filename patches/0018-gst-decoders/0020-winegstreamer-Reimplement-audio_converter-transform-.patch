From 66879ba34e664efcdd8aff25a8fc26a22182f072 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 1 Mar 2022 11:58:21 +0100
Subject: [PATCH 20/20] winegstreamer: Reimplement audio_converter transform
 with wg_transform.

---
 dlls/winegstreamer/audioconvert.c | 598 ++++++++++++++++++------------
 dlls/winegstreamer/wg_transform.c |   2 +-
 2 files changed, 361 insertions(+), 239 deletions(-)

diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/audioconvert.c
+++ b/dlls/winegstreamer/audioconvert.c
@@ -1,6 +1,7 @@
 /* GStreamer Audio Converter
  *
  * Copyright 2020 Derek Lesho
+ * Copyright 2022 RÃ©mi Bernon for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -21,20 +22,41 @@
 
 #include "mfapi.h"
 #include "mferror.h"
-#include "ks.h"
-#include "ksmedia.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
 
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+struct audio_format
+{
+    const GUID *subtype;
+    UINT32 sample_size;
+};
+static const struct audio_format audio_formats[] =
+{
+    {&MFAudioFormat_PCM, 8},
+    {&MFAudioFormat_PCM, 16},
+    {&MFAudioFormat_PCM, 32},
+    {&MFAudioFormat_Float, 16},
+    {&MFAudioFormat_Float, 32},
+};
+static const UINT32 sample_rates[] =
+{
+    48000, 44100, 22050, 11025,
+};
+
 struct audio_converter
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
     IMFMediaType *input_type;
     IMFMediaType *output_type;
-    CRITICAL_SECTION cs;
+
+    struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static struct audio_converter *impl_from_IMFTransform(IMFTransform *iface)
@@ -42,21 +64,47 @@ static struct audio_converter *impl_from_IMFTransform(IMFTransform *iface)
     return CONTAINING_RECORD(iface, struct audio_converter, IMFTransform_iface);
 }
 
-static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+static HRESULT try_create_wg_transform(struct audio_converter *transform)
+{
+    struct wg_format input_format, output_format;
+
+    memset(&transform->wg_format, 0, sizeof(transform->wg_format));
+    if (transform->wg_transform)
+        wg_transform_destroy(transform->wg_transform);
+    transform->wg_transform = NULL;
+
+    mf_media_type_to_wg_format(transform->input_type, &input_format);
+    if (input_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(transform->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!(transform->wg_transform = wg_transform_create(&input_format, &output_format)))
+        return E_FAIL;
+
+    transform->wg_format = output_format;
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
 {
-    TRACE("iface %p, riid %s, obj %p.\n", iface, debugstr_guid(riid), obj);
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
 
-    if (IsEqualIID(riid, &IID_IMFTransform) ||
-            IsEqualIID(riid, &IID_IUnknown))
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &transform->IMFTransform_iface;
+    else
     {
-        *obj = iface;
-        IMFTransform_AddRef(iface);
-        return S_OK;
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
     }
 
-    WARN("Unsupported %s.\n", debugstr_guid(riid));
-    *obj = NULL;
-    return E_NOINTERFACE;
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
 }
 
 static ULONG WINAPI transform_AddRef(IMFTransform *iface)
@@ -78,8 +126,12 @@ static ULONG WINAPI transform_Release(IMFTransform *iface)
 
     if (!refcount)
     {
-        transform->cs.DebugInfo->Spare[0] = 0;
-        DeleteCriticalSection(&transform->cs);
+        if (transform->wg_transform)
+            wg_transform_destroy(transform->wg_transform);
+        if (transform->input_type)
+            IMFMediaType_Release(transform->input_type);
+        if (transform->output_type)
+            IMFMediaType_Release(transform->output_type);
         free(transform);
     }
 
@@ -116,14 +168,50 @@ static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_si
 
 static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("iface %p, id %lu, info %p stub!\n", iface, id, info);
-    return E_NOTIMPL;
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    UINT32 channel_count, block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+
+    if (!transform->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(transform->input_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        return hr;
+    if (FAILED(hr = IMFMediaType_GetUINT32(transform->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->dwFlags = 0;
+    info->cbSize = 0x1800 * block_alignment * channel_count;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbMaxLookahead = 0;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("iface %p, id %lu, info %p stub!\n", iface, id, info);
-    return E_NOTIMPL;
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    UINT32 channel_count, block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+
+    if (!transform->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(transform->output_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        return hr;
+    if (FAILED(hr = IMFMediaType_GetUINT32(transform->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->dwFlags = 0;
+    info->cbSize = 0x1800 * block_alignment * channel_count;
+    info->cbAlignment = 0;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
@@ -161,251 +249,258 @@ static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD strea
 static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    IMFMediaType *ret;
+    UINT32 channel_counts[] = {1, 2, 6}, channel_counts_len = ARRAY_SIZE(channel_counts);
+    ULONG type_count = ARRAY_SIZE(audio_formats) * ARRAY_SIZE(sample_rates);
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    UINT32 sample_rate, block_alignment, channel_count;
+    struct audio_format audio_format;
+    IMFMediaType *media_type;
     HRESULT hr;
 
-    TRACE("iface %p, id %lu, index %lu, type %p.\n", iface, id, index, type);
-
-    if (id != 0)
-        return MF_E_INVALIDSTREAMNUMBER;
-
-    if (index >= 2)
-        return MF_E_NO_MORE_TYPES;
+    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
 
-    if (FAILED(hr = MFCreateMediaType(&ret)))
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
         return hr;
 
-    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+    *type = NULL;
+    if (transform->output_type)
     {
-        IMFMediaType_Release(ret);
-        return hr;
+        if (FAILED(hr = IMFMediaType_GetUINT32(transform->output_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_counts)))
+            goto done;
+        channel_counts_len = 1;
     }
+    type_count *= channel_counts_len;
 
-    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, index ? &MFAudioFormat_Float : &MFAudioFormat_PCM)))
-    {
-        IMFMediaType_Release(ret);
-        return hr;
-    }
+    if (index >= type_count)
+        return MF_E_NO_MORE_TYPES;
 
-    *type = ret;
+    channel_count = channel_counts[index % channel_counts_len];
+    index /= channel_counts_len;
+    sample_rate = sample_rates[index % ARRAY_SIZE(sample_rates)];
+    index /= ARRAY_SIZE(sample_rates);
+    audio_format = audio_formats[index];
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, audio_format.subtype)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, audio_format.sample_size)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_count)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate)))
+        goto done;
+
+    block_alignment = audio_format.sample_size * channel_count / 8;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, block_alignment)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * block_alignment)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, 1)))
+        goto done;
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
 
-    return S_OK;
+    IMFMediaType_Release(media_type);
+    return hr;
 }
 
 static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    IMFMediaType *output_type;
+    UINT32 channel_counts[] = {1, 2, 6}, channel_counts_len = ARRAY_SIZE(channel_counts);
+    ULONG type_count = ARRAY_SIZE(audio_formats) * ARRAY_SIZE(sample_rates);
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    UINT32 sample_rate, block_alignment, channel_count;
+    struct audio_format audio_format;
+    IMFMediaType *media_type;
     HRESULT hr;
 
-    static const struct
-    {
-        const GUID *subtype;
-        DWORD depth;
-    }
-    formats[] =
-    {
-        {&MFAudioFormat_PCM, 16},
-        {&MFAudioFormat_PCM, 24},
-        {&MFAudioFormat_PCM, 32},
-        {&MFAudioFormat_Float, 32},
-    };
-
-    static const DWORD rates[] = {44100, 48000};
-    static const DWORD channel_cnts[] = {1, 2, 6};
-    const GUID *subtype;
-    DWORD rate, channels, bps;
+    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
 
-    TRACE("iface %p, id %lu, index %lu, type %p.\n", iface, id, index, type);
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
 
-    if (id != 0)
-        return MF_E_INVALIDSTREAMNUMBER;
+    *type = NULL;
+    if (transform->input_type)
+    {
+        if (FAILED(hr = IMFMediaType_GetUINT32(transform->input_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_counts)))
+            goto done;
+        channel_counts_len = 1;
+    }
+    type_count *= channel_counts_len;
 
-    if (index >= ARRAY_SIZE(formats) * 2/*rates*/ * 3/*layouts*/)
+    if (index >= type_count)
         return MF_E_NO_MORE_TYPES;
 
-    if (FAILED(hr = MFCreateMediaType(&output_type)))
-        return hr;
-
-    subtype = formats[index / 6].subtype;
-    bps = formats[index / 6].depth;
-    rate = rates[index % 2];
-    channels = channel_cnts[(index / 2) % 3];
-
-    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_SUBTYPE, subtype)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, rate)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_NUM_CHANNELS, channels)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, bps)))
-        goto fail;
-
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, channels * bps / 8)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, rate * channels * bps / 8)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_CHANNEL_MASK,
-            channels == 1 ? KSAUDIO_SPEAKER_MONO :
-            channels == 2 ? KSAUDIO_SPEAKER_STEREO :
-          /*channels == 6*/ KSAUDIO_SPEAKER_5POINT1)))
-        goto fail;
-    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)))
-        goto fail;
-
-    *type = output_type;
+    channel_count = channel_counts[index % channel_counts_len];
+    index /= channel_counts_len;
+    sample_rate = sample_rates[index % ARRAY_SIZE(sample_rates)];
+    index /= ARRAY_SIZE(sample_rates);
+    audio_format = audio_formats[index];
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, audio_format.subtype)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, audio_format.sample_size)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_count)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate)))
+        goto done;
+
+    block_alignment = audio_format.sample_size * channel_count / 8;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, block_alignment)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * block_alignment)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, 1)))
+        goto done;
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
 
-    return S_OK;
-fail:
-    IMFMediaType_Release(output_type);
+    IMFMediaType_Release(media_type);
     return hr;
 }
 
 static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    GUID major_type, subtype;
-    UINT32 unused;
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
+    ULONG i;
 
-    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
 
-    TRACE("iface %p, id %lu, type %p, flags %#lx.\n", iface, id, type, flags);
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(audio_formats); ++i)
+        if (IsEqualGUID(&subtype, audio_formats[i].subtype))
+            break;
+    if (i == ARRAY_SIZE(audio_formats))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
 
-    if (id != 0)
-        return MF_E_INVALIDSTREAMNUMBER;
-
-    if (!type)
+    if (transform->input_type)
     {
-        if (flags & MFT_SET_TYPE_TEST_ONLY)
+        if (SUCCEEDED(hr = IMFMediaType_Compare(transform->input_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
             return S_OK;
-
-        EnterCriticalSection(&transform->cs);
-
-        if (transform->input_type)
-        {
-            IMFMediaType_Release(transform->input_type);
-            transform->input_type = NULL;
-        }
-
-        LeaveCriticalSection(&transform->cs);
-
-        return S_OK;
+        IMFMediaType_Release(transform->input_type);
     }
 
-    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
-        return MF_E_INVALIDTYPE;
-    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
-        return MF_E_INVALIDTYPE;
-    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &unused)))
-        return MF_E_INVALIDTYPE;
-    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &unused)))
-        return MF_E_INVALIDTYPE;
-    if (IsEqualGUID(&subtype, &MFAudioFormat_PCM) && FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &unused)))
-        return MF_E_INVALIDTYPE;
-
-    if (!(IsEqualGUID(&major_type, &MFMediaType_Audio)))
-        return MF_E_INVALIDTYPE;
-
-    if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
-        return MF_E_INVALIDTYPE;
-
-    if (flags & MFT_SET_TYPE_TEST_ONLY)
-        return S_OK;
-
-    EnterCriticalSection(&transform->cs);
-
-    hr = S_OK;
-
-    if (!transform->input_type)
-        hr = MFCreateMediaType(&transform->input_type);
-
-    if (SUCCEEDED(hr))
-        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) transform->input_type);
+    IMFMediaType_AddRef((transform->input_type = type));
 
-    if (FAILED(hr))
+    if (transform->output_type && FAILED(hr = try_create_wg_transform(transform)))
     {
         IMFMediaType_Release(transform->input_type);
         transform->input_type = NULL;
     }
 
-    LeaveCriticalSection(&transform->cs);
-
     return hr;
 }
 
 static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct audio_converter *transform = impl_from_IMFTransform(iface);
-    GUID major_type, subtype;
-    UINT32 unused;
+    MF_ATTRIBUTE_TYPE item_type;
+    GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
+    ULONG i;
 
     TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
 
-    if (id != 0)
-        return MF_E_INVALIDSTREAMNUMBER;
-
-    if (!transform->input_type)
-        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(audio_formats); ++i)
+        if (IsEqualGUID(&subtype, audio_formats[i].subtype))
+            break;
+    if (i == ARRAY_SIZE(audio_formats))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
 
-    if (!type)
+    if (transform->output_type)
     {
-        if (flags & MFT_SET_TYPE_TEST_ONLY)
+        if (SUCCEEDED(hr = IMFMediaType_Compare(transform->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
             return S_OK;
-
-        EnterCriticalSection(&transform->cs);
-
-        if (transform->output_type)
-        {
-            IMFMediaType_Release(transform->output_type);
-            transform->output_type = NULL;
-        }
-
-        LeaveCriticalSection(&transform->cs);
-
-        return S_OK;
+        IMFMediaType_Release(transform->output_type);
     }
 
-    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
-        return MF_E_INVALIDTYPE;
-    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
-        return MF_E_INVALIDTYPE;
-    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &unused)))
-        return MF_E_INVALIDTYPE;
-    if (IsEqualGUID(&subtype, &MFAudioFormat_PCM) && FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &unused)))
-        return MF_E_INVALIDTYPE;
-    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &unused)))
-        return MF_E_INVALIDTYPE;
-
-    if (!(IsEqualGUID(&major_type, &MFMediaType_Audio)))
-        return MF_E_INVALIDTYPE;
-
-    if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
-        return MF_E_INVALIDTYPE;
+    IMFMediaType_AddRef((transform->output_type = type));
 
-    if (flags & MFT_SET_TYPE_TEST_ONLY)
-        return S_OK;
-
-    EnterCriticalSection(&transform->cs);
-
-    hr = S_OK;
-
-    if (!transform->output_type)
-        hr = MFCreateMediaType(&transform->output_type);
-
-    if (SUCCEEDED(hr))
-        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) transform->output_type);
-
-    if (FAILED(hr))
+    if (transform->input_type && FAILED(hr = try_create_wg_transform(transform)))
     {
         IMFMediaType_Release(transform->output_type);
         transform->output_type = NULL;
     }
 
-    LeaveCriticalSection(&transform->cs);
-
     return hr;
 }
 
@@ -420,24 +515,13 @@ static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD i
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
 
+    if (!transform->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
     if (FAILED(hr = MFCreateMediaType(&ret)))
         return hr;
 
-    EnterCriticalSection(&transform->cs);
-
-    if (transform->input_type)
-        hr = IMFMediaType_CopyAllItems(transform->input_type, (IMFAttributes *)ret);
-    else
-        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
-
-    LeaveCriticalSection(&transform->cs);
-
-    if (SUCCEEDED(hr))
-        *type = ret;
-    else
-        IMFMediaType_Release(ret);
-
-    return hr;
+    return IMFMediaType_CopyAllItems(transform->input_type, (IMFAttributes *)ret);
 }
 
 static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
@@ -451,24 +535,13 @@ static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
 
+    if (!transform->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
     if (FAILED(hr = MFCreateMediaType(&ret)))
         return hr;
 
-    EnterCriticalSection(&transform->cs);
-
-    if (transform->output_type)
-        hr = IMFMediaType_CopyAllItems(transform->output_type, (IMFAttributes *)ret);
-    else
-        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
-
-    LeaveCriticalSection(&transform->cs);
-
-    if (SUCCEEDED(hr))
-        *type = ret;
-    else
-        IMFMediaType_Release(ret);
-
-    return hr;
+    return IMFMediaType_CopyAllItems(transform->output_type, (IMFAttributes *)ret);
 }
 
 static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
@@ -511,15 +584,66 @@ static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_
 
 static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("iface %p, id %lu, sample %p, flags %#lx stub!\n", iface, id, sample, flags);
-    return E_NOTIMPL;
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    struct wg_sample *wg_sample;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
+
+    if (!transform->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = mf_create_wg_sample(sample, &wg_sample)))
+        return hr;
+
+    hr = wg_transform_push_data(transform->wg_transform, wg_sample);
+
+    mf_destroy_wg_sample(wg_sample);
+    return hr;
 }
 
 static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("iface %p, flags %#lx, count %lu, samples %p, status %p stub!\n", iface, flags, count, samples, status);
-    return E_NOTIMPL;
+    struct audio_converter *transform = impl_from_IMFTransform(iface);
+    MFT_OUTPUT_STREAM_INFO info;
+    struct wg_sample *wg_sample;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+        return E_INVALIDARG;
+
+    if (!transform->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
+        return hr;
+
+    wg_sample->format = transform->wg_format;
+    wg_sample->size = 0;
+    if (wg_sample->max_size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(transform->wg_transform, wg_sample)))
+    {
+        if (wg_sample->flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+
+    mf_destroy_wg_sample(wg_sample);
+    return hr;
 }
 
 static const IMFTransformVtbl transform_vtbl =
@@ -564,9 +688,7 @@ HRESULT audio_converter_create(REFIID riid, void **ret)
     transform->IMFTransform_iface.lpVtbl = &transform_vtbl;
     transform->refcount = 1;
 
-    InitializeCriticalSection(&transform->cs);
-    transform->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": transform_lock");
-
     *ret = &transform->IMFTransform_iface;
+    TRACE("Created transform %p\n", *ret);
     return S_OK;
 }
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -345,8 +345,8 @@ NTSTATUS wg_transform_create(void *args)
             break;
 
         case WG_MAJOR_TYPE_VIDEO:
-            break;
         case WG_MAJOR_TYPE_AUDIO:
+            break;
         case WG_MAJOR_TYPE_UNKNOWN:
             GST_FIXME("Format %u not implemented!", input_format.major_type);
             gst_caps_unref(raw_caps);
-- 
2.35.3

