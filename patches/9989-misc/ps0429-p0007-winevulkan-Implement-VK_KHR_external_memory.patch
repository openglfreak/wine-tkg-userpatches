From 675d13e9d52771120b29ffc53a3d91753d2db378 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 19 May 2021 13:38:12 -0400
Subject: [PATCH] winevulkan: Implement VK_KHR_external_memory_win32 for
 images.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winevulkan/make_vulkan |   3 +
 dlls/winevulkan/vulkan.c    | 111 ++++++++++++++++++++++++++++--------
 2 files changed, 91 insertions(+), 23 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 11111111111..11111111111 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -216,6 +216,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateGraphicsPipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkCreateImage" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -294,7 +295,9 @@ STRUCT_CHAIN_CONVERSIONS = {
 
     # Structs which require pNext chain modification
     "VkBufferCreateInfo": [],
+    "VkImageCreateInfo": [],
     "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
+    "VkPhysicalDeviceImageFormatInfo2": [],
 }
 
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 11111111111..11111111111 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1396,52 +1396,80 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
     return STATUS_SUCCESS;
 }
 
-NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2(void *args)
+static VkResult wine_vk_get_physical_device_image_format_properties_2(VkPhysicalDevice phys_dev,
+        VkResult (*p_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice, const VkPhysicalDeviceImageFormatInfo2 *, VkImageFormatProperties2 *),
+        const VkPhysicalDeviceImageFormatInfo2 *format_info, VkImageFormatProperties2 *properties)
 {
-    struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
-    VkPhysicalDevice phys_dev = params->physicalDevice;
-    const VkPhysicalDeviceImageFormatInfo2 *format_info = params->pImageFormatInfo;
-    VkImageFormatProperties2 *properties = params->pImageFormatProperties;
+    VkPhysicalDeviceExternalImageFormatInfo *external_image_info_dup = NULL;
+    const VkPhysicalDeviceExternalImageFormatInfo *external_image_info;
+    VkPhysicalDeviceImageFormatInfo2 format_info_host = *format_info;
     VkExternalImageFormatProperties *external_image_properties;
     VkResult res;
 
-    TRACE("%p, %p, %p\n", phys_dev, format_info, properties);
+    if ((external_image_info = wine_vk_find_struct(format_info, PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)) && external_image_info->handleType)
+    {
+        if ((res = convert_VkPhysicalDeviceImageFormatInfo2_struct_chain(format_info->pNext, &format_info_host)) < 0)
+        {
+            WARN("Failed to convert VkPhysicalDeviceImageFormatInfo2 pNext chain, res=%d.\n", res);
+            return res;
+        }
+        external_image_info_dup = wine_vk_find_struct(&format_info_host, PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO);
+
+        wine_vk_normalize_handle_types_win(&external_image_info_dup->handleType);
+
+        if (external_image_info_dup->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            external_image_info_dup->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        wine_vk_normalize_handle_types_host(&external_image_info_dup->handleType);
+        if (!external_image_info_dup->handleType)
+        {
+            WARN("Unsupported handle type %#x.\n", external_image_info->handleType);
+            return VK_ERROR_FORMAT_NOT_SUPPORTED;
+        }
+    }
 
-    res = thunk_vkGetPhysicalDeviceImageFormatProperties2(phys_dev, format_info, properties);
+    res = p_vkGetPhysicalDeviceImageFormatProperties2(phys_dev, &format_info_host, properties);
+
+    if (external_image_info_dup)
+        free_VkPhysicalDeviceImageFormatInfo2_struct_chain(&format_info_host);
 
     if ((external_image_properties = wine_vk_find_struct(properties, EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
     {
         VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
+        if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
+
+        if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
     }
 
     return res;
 }
 
-NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
+NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2(void *args)
 {
-    struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
+    struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
     VkPhysicalDevice phys_dev = params->physicalDevice;
     const VkPhysicalDeviceImageFormatInfo2 *format_info = params->pImageFormatInfo;
     VkImageFormatProperties2 *properties = params->pImageFormatProperties;
-    VkExternalImageFormatProperties *external_image_properties;
-    VkResult res;
 
     TRACE("%p, %p, %p\n", phys_dev, format_info, properties);
 
-    res = thunk_vkGetPhysicalDeviceImageFormatProperties2KHR(phys_dev, format_info, properties);
+    return wine_vk_get_physical_device_image_format_properties_2(phys_dev, thunk_vkGetPhysicalDeviceImageFormatProperties2, format_info, properties);
+}
 
-    if ((external_image_properties = wine_vk_find_struct(properties, EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
-    {
-        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
-    }
+NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
+{
+    struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
+    VkPhysicalDevice phys_dev = params->physicalDevice;
+    const VkPhysicalDeviceImageFormatInfo2 *format_info = params->pImageFormatInfo;
+    VkImageFormatProperties2 *properties = params->pImageFormatProperties;
 
-    return res;
+    TRACE("%p, %p, %p\n", phys_dev, format_info, properties);
+
+    return wine_vk_get_physical_device_image_format_properties_2(phys_dev, thunk_vkGetPhysicalDeviceImageFormatProperties2KHR, format_info, properties);
 }
 
 /* From ntdll/unix/sync.c */
@@ -2263,3 +2291,40 @@ NTSTATUS wine_vkCreateBuffer(void *args)
 
     return res;
 }
+
+NTSTATUS wine_vkCreateImage(void *args)
+{
+    struct vkCreateImage_params *params = args;
+    VkDevice device = params->device;
+    const VkImageCreateInfo *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkImage *image = params->pImage;
+
+    VkExternalMemoryImageCreateInfo *external_memory_info;
+    VkImageCreateInfo create_info_host = *create_info;
+    VkResult res;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, image);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if ((res = convert_VkImageCreateInfo_struct_chain(create_info->pNext, &create_info_host)))
+    {
+        WARN("Failed to convert VkImageCreateInfo pNext chain, res=%d.\n", res);
+        return res;
+    }
+
+    if ((external_memory_info = wine_vk_find_struct(&create_info_host, EXTERNAL_MEMORY_IMAGE_CREATE_INFO)))
+    {
+        if (external_memory_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR)
+            external_memory_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+        wine_vk_normalize_handle_types_host(&external_memory_info->handleTypes);
+    }
+
+    res = device->funcs.p_vkCreateImage(device->device, &create_info_host, NULL, image);
+
+    free_VkImageCreateInfo_struct_chain(&create_info_host);
+
+    return res;
+}
-- 
2.37.1

