From bfdec809dc8395de3489846d77107b2971c9037f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Oct 2021 12:44:17 +0200
Subject: [PATCH 21/25] user32: Pretend there's always one monitor in
 QueryDisplayConfig.

---
 dlls/user32/sysparams.c | 34 +++++++++++++++++++++++++++++++---
 1 file changed, 31 insertions(+), 3 deletions(-)

diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 2a73a2c0d42..dc2ec4d80d1 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -4630,6 +4630,9 @@ LONG WINAPI GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *num_path_info, UIN
             (*num_path_info)++;
     }
 
+    /* pretend there's always one monitor */
+    if (monitor_index == 1) *num_path_info = 1;
+
     *num_mode_info = *num_path_info * 2;
     ret = ERROR_SUCCESS;
     TRACE("returning %u path(s) %u mode(s)\n", *num_path_info, *num_mode_info);
@@ -4781,7 +4784,8 @@ static LONG query_display_device_modes( const WCHAR *device_name, UINT32 output_
     if (++mode_index == *mode_count) return -1;
 
     /* Extract the adapter index from device_name to use as the source ID */
-    adapter_index = wcstol( device_name + lstrlenW( L"\\\\.\\DISPLAY" ), NULL, 10 ) - 1;
+    if (!device_name) adapter_index = 0;
+    else adapter_index = wcstol( device_name + lstrlenW( L"\\\\.\\DISPLAY" ), NULL, 10 ) - 1;
 
     /* Multiple targets can be driven by the same source, ensure a mode
      * hasn't already been added for this source.
@@ -4811,8 +4815,8 @@ LONG WINAPI QueryDisplayConfig(UINT32 flags, UINT32 *numpathelements, DISPLAYCON
     HDEVINFO devinfo;
     SP_DEVINFO_DATA device_data = {sizeof(device_data)};
     DWORD monitor_index = 0, state_flags, type;
-    UINT32 output_id, path_index = 0, mode_index = 0;
-    LUID gpu_luid;
+    UINT32 output_id = 0, path_index = 0, mode_index = 0;
+    LUID gpu_luid = {0};
     WCHAR device_name[CCHDEVICENAME];
 
     FIXME("(%08x %p %p %p %p %p): semi-stub\n", flags, numpathelements, pathinfo, numinfoelements, modeinfo, topologyid);
@@ -4889,6 +4893,22 @@ LONG WINAPI QueryDisplayConfig(UINT32 flags, UINT32 *numpathelements, DISPLAYCON
         mode_index += ret;
     }
 
+    /* pretend there's always one monitor */
+    if (monitor_index == 1)
+    {
+        ret = query_display_device_modes(NULL, output_id, &gpu_luid, flags,
+                                         path_index, numpathelements, pathinfo,
+                                         mode_index, numinfoelements, modeinfo);
+        if (ret < 0)
+        {
+            ret = ERROR_INSUFFICIENT_BUFFER;
+            goto done;
+        }
+
+        path_index += 1;
+        mode_index += ret;
+    }
+
     *numpathelements = path_index;
     *numinfoelements = mode_index;
     ret = ERROR_SUCCESS;
@@ -4963,6 +4983,14 @@ LONG WINAPI DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *packet)
             break;
         }
         SetupDiDestroyDeviceInfoList(devinfo);
+        /* pretend there's always one monitor */
+        if (index == 1 && source_name->header.id == 0 &&
+            source_name->header.adapterId.LowPart == 0 &&
+            source_name->header.adapterId.HighPart == 0)
+        {
+            wcscpy(source_name->viewGdiDeviceName, L"\\\\.\\DISPLAY1");
+            ret = ERROR_SUCCESS;
+        }
         release_display_device_init_mutex(mutex);
         return ret;
     }
-- 
2.34.0

