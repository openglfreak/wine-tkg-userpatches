From 4c5c1bcb97d49f8c249cb26202b7466488d14b1e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 11:59:33 +0100
Subject: [PATCH 08/14] wineboot: Initialize Qpc flags and calibrate frequency.

---
 programs/wineboot/wineboot.c | 136 +++++++++++++++++++++++++++++++++++
 1 file changed, 136 insertions(+)

diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 9427448b612..e3f5439ecf5 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -241,12 +241,147 @@ static void initialize_xstate_features(struct _KUSER_SHARED_DATA *data)
     TRACE("XSAVE feature 2 %#x, %#x, %#x, %#x.\n", regs[0], regs[1], regs[2], regs[3]);
 }
 
+static void initialize_qpc_features(struct _KUSER_SHARED_DATA *data)
+{
+    int regs[4], cpuid_level, denom, numer, freq, tmp;
+
+    if (data->QpcBypassEnabled) return;
+
+    data->QpcBypassEnabled = 0;
+    data->QpcFrequency = 10000000;
+    data->QpcShift = 0;
+    data->QpcBias = 0;
+
+    if (!data->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE])
+    {
+        ERR("No RDTSC support, disabling QpcBypass\n");
+        return;
+    }
+
+    __cpuid(regs, 0x80000000);
+    if (regs[0] < 0x80000007)
+    {
+        ERR("Unable to check invariant TSC, disabling QpcBypass\n");
+        return;
+    }
+
+    /* check for invariant tsc bit */
+    __cpuid(regs, 0x80000007);
+    if (!(regs[3] & (1 << 8)))
+    {
+        ERR("No invariant TSC, disabling QpcBypass\n");
+        return;
+    }
+    data->QpcBypassEnabled |= SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED;
+
+    /* check for rdtscp support bit */
+    __cpuid(regs, 0x80000001);
+    if ((regs[3] & (1 << 27)))
+        data->QpcBypassEnabled |= SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP;
+    else if (data->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE])
+        data->QpcBypassEnabled |= SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE;
+    else
+        data->QpcBypassEnabled |= SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE;
+
+    __cpuid(regs, 0);
+    tmp = regs[2];
+    regs[2] = regs[3];
+    regs[3] = tmp;
+
+    /* only available on some intel CPUs */
+    if (memcmp(regs + 1, "GenuineIntel", 12)) data->QpcFrequency = 0;
+    else if ((cpuid_level = regs[0]) < 0x15) data->QpcFrequency = 0;
+    else
+    {
+        __cpuid(regs, 0x15);
+        if (!(denom = regs[0]) || !(numer = regs[1])) data->QpcFrequency = 0;
+        else
+        {
+            if (!(freq = regs[2]) && cpuid_level >= 0x16)
+            {
+                __cpuid(regs, 0x16); /* eax is base freq in MHz */
+                freq = regs[0] * 1000 * denom / numer;
+            }
+
+            data->QpcFrequency = freq * numer / denom;
+        }
+
+        if (!data->QpcFrequency)
+            ERR("Failed to read TSC frequency from CPUID, falling back to calibration.\n");
+        else
+        {
+            data->QpcFrequency = (data->QpcFrequency + (1 << 10) - 1) >> 10;
+            data->QpcShift = 10;
+            data->QpcBias = 0;
+
+            ERR("TSC frequency read from CPUID, freq %I64d, shift %d, bias %I64d\n",
+                  data->QpcFrequency, data->QpcShift, data->QpcBias);
+        }
+    }
+
+    if (!data->QpcFrequency)
+    {
+        LARGE_INTEGER tsc0, tsc1, freq0, freq1;
+        LONGLONG time0, time1, time2, time3;
+        UINT retries = 10;
+
+        data->QpcShift = 0;
+        data->QpcBias = 0;
+
+        do
+        {
+            time0 = RtlGetSystemTimePrecise();
+            RtlQueryPerformanceCounter(&tsc0);
+            time1 = RtlGetSystemTimePrecise();
+            Sleep(1);
+            time2 = RtlGetSystemTimePrecise();
+            RtlQueryPerformanceCounter(&tsc1);
+            time3 = RtlGetSystemTimePrecise();
+
+            freq0.QuadPart = (tsc1.QuadPart - tsc0.QuadPart) * 10000000 / (time2 - time0);
+            freq0.QuadPart = (freq0.QuadPart + (1 << 10) - 1) >> 10;
+            freq1.QuadPart = (tsc1.QuadPart - tsc0.QuadPart) * 10000000 / (time3 - time1);
+            freq1.QuadPart = (freq1.QuadPart + (1 << 10) - 1) >> 10;
+        }
+        while (freq0.QuadPart != freq1.QuadPart && retries--);
+
+        if (freq0.QuadPart != freq1.QuadPart)
+            ERR("TSC frequency calibration failed, unstable TSC?\n");
+        else
+        {
+            data->QpcFrequency = freq0.QuadPart;
+            data->QpcShift = 10;
+            data->QpcBias = 0;
+
+            ERR("TSC frequency calibration complete, freq %I64d, shift %d, bias %I64d\n",
+                  data->QpcFrequency, data->QpcShift, data->QpcBias);
+        }
+    }
+
+    if (!data->QpcFrequency)
+    {
+        ERR("Unable to calibrate TSC frequency, disabling QpcBypass.\n");
+        data->QpcBypassEnabled = 0;
+        data->QpcFrequency = 10000000;
+        data->QpcShift = 0;
+        data->QpcBias = 0;
+    }
+}
+
 #else
 
 static void initialize_xstate_features(struct _KUSER_SHARED_DATA *data)
 {
 }
 
+static void initialize_qpc_features(struct _KUSER_SHARED_DATA *data)
+{
+    data->QpcBypassEnabled = 0;
+    data->QpcFrequency = 10000000;
+    data->QpcShift = 0;
+    data->QpcBias = 0;
+}
+
 #endif
 
 static void create_user_shared_data(void)
@@ -336,6 +471,7 @@ static void create_user_shared_data(void)
     data->ActiveGroupCount = 1;
 
     initialize_xstate_features( data );
+    initialize_qpc_features( data );
 
     UnmapViewOfFile( data );
 }
-- 
2.30.2

