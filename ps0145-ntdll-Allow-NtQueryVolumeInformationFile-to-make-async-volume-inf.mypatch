From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
#Subject: [PATCH v6 2/5] ntdll: Allow NtQueryVolumeInformationFile to make async volume information queries.
Message-Id: <CAEU2+vrfgwa3cfs_FdKmXZTgrRBV_-J0ac4_DeN4FEgSXV3Prw@mail.gmail.com>
Date: Sat, 6 Feb 2021 11:25:02 -0700

This patch allows NtQueryVolumeInformationFile to pass
FileFsVolumeInformation and FileFsAttributeInformation requests to the
mountmgr (as well as other device drivers).  These requests currently
do not work for NT device paths, which results in a bunch of
duplication in kernelbase (see patch 5).

v6: No change
v5: Fixed improper usage of io->u.Status that caused intermittent test
failures in v4 patch 5
v4: Reordered (no content change)
v3: No change
v2: Split

Best,
Erich

From e84b0673c80502a8db4a5f0996de156edeed8d08 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Fri, 12 Jun 2020 14:53:43 -0600
Subject: ntdll: Allow NtQueryVolumeInformationFile to make async volume
 information queries.

Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
---
 dlls/ntdll/unix/file.c | 23 ++++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index f198cdccc6c..e1c9d822f70 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6221,16 +6221,33 @@ NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, IO_STATUS_BLOCK *io
     io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
     if (io->u.Status == STATUS_BAD_DEVICE_TYPE)
     {
+        struct async_irp *async;
+        HANDLE wait_handle;
+        NTSTATUS status;
+
+        if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+            return STATUS_NO_MEMORY;
+        async->buffer  = buffer;
+        async->size    = length;
+
         SERVER_START_REQ( get_volume_info )
         {
+            req->async = server_async( handle, &async->io, NULL, NULL, NULL, io );
             req->handle = wine_server_obj_handle( handle );
             req->info_class = info_class;
             wine_server_set_reply( req, buffer, length );
-            io->u.Status = wine_server_call( req );
-            if (!io->u.Status) io->Information = wine_server_reply_size( reply );
+            status = wine_server_call( req );
+            if (status != STATUS_PENDING)
+            {
+                io->u.Status = status;
+                io->Information = wine_server_reply_size( reply );
+            }
+            wait_handle = wine_server_ptr_handle( reply->wait );
         }
         SERVER_END_REQ;
-        return io->u.Status;
+        if (status != STATUS_PENDING) free( async );
+        if (wait_handle) status = wait_async( wait_handle, FALSE, io );
+        return status;
     }
     else if (io->u.Status) return io->u.Status;
 

-- 
2.17.1

