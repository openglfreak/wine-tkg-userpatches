From 53cf4876674133e66120c989565e6679ec8e1826 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 23 Feb 2022 14:25:52 +0100
Subject: [PATCH 24/35] winegstreamer: Support dynamic wg_transform video
 format change.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c |  30 ++++++++-
 dlls/winegstreamer/unix_private.h |   2 +
 dlls/winegstreamer/unixlib.h      |   1 +
 dlls/winegstreamer/wg_transform.c | 108 ++++++++++++++++++++++++------
 dlls/winegstreamer/wma_decoder.c  |   4 ++
 5 files changed, 124 insertions(+), 21 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -50,6 +50,7 @@ struct h264_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -62,6 +63,7 @@ static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
     struct wg_format input_format;
     struct wg_format output_format;
 
+    memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
     decoder->wg_transform = NULL;
@@ -370,7 +372,7 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
         goto done;
 
-    hr = fill_output_media_type(media_type, NULL);
+    hr = fill_output_media_type(media_type, decoder->output_type);
 
 done:
     if (SUCCEEDED(hr))
@@ -419,6 +421,7 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
     ULONG i;
 
@@ -441,7 +444,13 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
         return MF_E_INVALIDMEDIATYPE;
 
     if (decoder->output_type)
+    {
+        if (SUCCEEDED(hr = IMFMediaType_Compare(decoder->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
         IMFMediaType_Release(decoder->output_type);
+    }
+
     IMFMediaType_AddRef((decoder->output_type = type));
 
     if (FAILED(hr = try_create_wg_transform(decoder)))
@@ -525,6 +534,8 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     MFT_OUTPUT_STREAM_INFO info;
     struct wg_sample *wg_sample;
+    IMFMediaType *media_type;
+    UINT64 frame_rate;
     HRESULT hr;
 
     TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
@@ -538,6 +549,9 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (!decoder->wg_transform)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
 
+    if (FAILED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &frame_rate)))
+        frame_rate = (UINT64)30000 << 32 | 1001;
+
     *status = 0;
     samples[0].dwStatus = 0;
     if (!samples[0].pSample) return E_INVALIDARG;
@@ -545,11 +559,25 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
         return hr;
 
+    wg_sample->format = decoder->wg_format;
     if (wg_sample->max_size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
     else
         hr = wg_transform_read_data(decoder->wg_transform, wg_sample);
 
+    if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        decoder->wg_format = wg_sample->format;
+        media_type = mf_media_type_from_wg_format(&wg_sample->format);
+        IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, frame_rate);
+
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
     mf_destroy_wg_sample(wg_sample);
     return hr;
 }
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -31,6 +31,8 @@ extern GstElement *create_element(const char *name, const char *plugin_set) DECL
 extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
 extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
 extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
+extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
+extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
 
 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -121,6 +121,7 @@ enum wg_sample_flag
 
 struct wg_sample
 {
+    struct wg_format format;
     /* timestamp and duration are in 100-nanosecond units. */
     LONGLONG timestamp, duration;
     UINT32 flags;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -59,6 +59,7 @@ struct wg_transform
     GstSegment segment;
     pthread_mutex_t mutex;
     struct list samples;
+    GstCaps *sink_caps;
 };
 
 static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
@@ -74,7 +75,7 @@ static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, Gst
     {
         pthread_mutex_lock(&transform->mutex);
         entry->buffer_size = gst_buffer_get_size(buffer);
-        entry->sample = gst_sample_new(buffer, NULL, NULL, NULL);
+        entry->sample = gst_sample_new(buffer, transform->sink_caps, NULL, NULL);
         list_add_tail(&transform->samples, &entry->entry);
         pthread_mutex_unlock(&transform->mutex);
     }
@@ -84,6 +85,39 @@ static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, Gst
     return GST_FLOW_OK;
 }
 
+static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_INFO("transform %p, type \"%s\".", transform, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps;
+        gchar *str;
+
+        gst_event_parse_caps(event, &caps);
+        str = gst_caps_to_string(caps);
+        GST_WARNING("Got caps \"%s\".", str);
+        g_free(str);
+
+        pthread_mutex_lock(&transform->mutex);
+        gst_caps_unref(transform->sink_caps);
+        transform->sink_caps = gst_caps_ref(caps);
+        pthread_mutex_unlock(&transform->mutex);
+        break;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+        break;
+    }
+
+    gst_event_unref(event);
+    return TRUE;
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
@@ -100,6 +134,7 @@ NTSTATUS wg_transform_destroy(void *args)
     g_object_unref(transform->container);
     g_object_unref(transform->my_sink);
     g_object_unref(transform->my_src);
+    gst_caps_unref(transform->sink_caps);
     pthread_mutex_destroy(&transform->mutex);
     free(transform);
 
@@ -177,15 +212,15 @@ static bool transform_append_element(struct wg_transform *transform, GstElement
 NTSTATUS wg_transform_create(void *args)
 {
     struct wg_transform_create_params *params = args;
-    GstCaps *raw_caps = NULL, *src_caps = NULL, *sink_caps = NULL;
     struct wg_format output_format = *params->output_format;
     struct wg_format input_format = *params->input_format;
     GstElement *first = NULL, *last = NULL, *element;
+    GstCaps *sink_caps = NULL, *src_caps = NULL;
     NTSTATUS status = STATUS_UNSUCCESSFUL;
-    GstPadTemplate *template = NULL;
     struct wg_transform *transform;
-    const gchar *media_type;
+    GstPadTemplate *template;
     GstEvent *event;
+    int i;
 
     if (!init_gstreamer())
         return STATUS_UNSUCCESSFUL;
@@ -204,34 +239,52 @@ NTSTATUS wg_transform_create(void *args)
     if (!transform->my_src)
         goto out;
 
-    if (!(sink_caps = wg_format_to_caps(&output_format)))
+    if (!(transform->sink_caps = wg_format_to_caps(&output_format)))
         goto out;
-    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps)))
+    if (!(sink_caps = gst_caps_copy(transform->sink_caps)))
+        goto out;
+
+    /* Remove the frame size attributes so that our sink doesn't force any
+     * video frame size, and instead let it dynamically change.
+     */
+    for (i = 0; i < gst_caps_get_size(sink_caps); ++i)
+        gst_structure_remove_fields(gst_caps_get_structure(sink_caps, i),
+                "width", "height", NULL);
+
+    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, gst_caps_copy(sink_caps))))
+    {
+        gst_caps_unref(sink_caps);
         goto out;
+    }
     transform->my_sink = gst_pad_new_from_template(template, "sink");
     g_object_unref(template);
     if (!transform->my_sink)
+    {
+        gst_caps_unref(sink_caps);
         goto out;
+    }
 
     gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
 
     /* Since we append conversion elements, we don't want to filter decoders
-     * based on the actual output caps now. Matching decoders with the
-     * raw output media type should be enough.
+     * based on the actual output caps now. Strip everything from the sink
+     * caps and only keep the first structure name, the media type. Matching
+     * decoders with the raw output media type should be enough.
      */
-    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
-    if (!(raw_caps = gst_caps_new_empty_simple(media_type)))
-        goto out;
+    gst_structure_remove_all_fields(gst_caps_get_structure(sink_caps, 0));
+    for (i = 1; i < gst_caps_get_size(sink_caps); ++i)
+        gst_caps_remove_structure(sink_caps, i);
 
     switch (input_format.major_type)
     {
         case WG_MAJOR_TYPE_H264:
         case WG_MAJOR_TYPE_WMA:
-            if (!(element = transform_find_element(GST_ELEMENT_FACTORY_TYPE_DECODER, src_caps, raw_caps))
+            if (!(element = transform_find_element(GST_ELEMENT_FACTORY_TYPE_DECODER, src_caps, sink_caps))
                     || !transform_append_element(transform, element, &first, &last))
             {
-                gst_caps_unref(raw_caps);
+                gst_caps_unref(sink_caps);
                 goto out;
             }
             break;
@@ -240,11 +293,11 @@ NTSTATUS wg_transform_create(void *args)
         case WG_MAJOR_TYPE_VIDEO:
         case WG_MAJOR_TYPE_UNKNOWN:
             GST_FIXME("Format %u not implemented!", input_format.major_type);
-            gst_caps_unref(raw_caps);
+            gst_caps_unref(sink_caps);
             goto out;
     }
 
-    gst_caps_unref(raw_caps);
+    gst_caps_unref(sink_caps);
 
     switch (output_format.major_type)
     {
@@ -267,6 +320,11 @@ NTSTATUS wg_transform_create(void *args)
             break;
 
         case WG_MAJOR_TYPE_VIDEO:
+            if (!(element = create_element("videoconvert", "base"))
+                    || !transform_append_element(transform, element, &first, &last))
+                goto out;
+            break;
+
         case WG_MAJOR_TYPE_H264:
         case WG_MAJOR_TYPE_WMA:
         case WG_MAJOR_TYPE_UNKNOWN:
@@ -307,7 +365,6 @@ NTSTATUS wg_transform_create(void *args)
             || !gst_pad_push_event(transform->my_src, event))
         goto out;
 
-    gst_caps_unref(sink_caps);
     gst_caps_unref(src_caps);
 
     pthread_mutex_init(&transform->mutex, NULL);
@@ -325,7 +382,7 @@ out:
     if (transform->my_sink)
         gst_object_unref(transform->my_sink);
     if (sink_caps)
-        gst_caps_unref(sink_caps);
+        gst_caps_unref(transform->sink_caps);
     if (transform->my_src)
         gst_object_unref(transform->my_src);
     if (src_caps)
@@ -408,12 +465,22 @@ static void copy_sample_meta_data(struct wg_sample *sample, struct sample_entry
     }
 }
 
-static NTSTATUS copy_from_sample_entry(struct wg_sample *sample, struct sample_entry *entry)
+static NTSTATUS copy_from_sample_entry(struct wg_sample *sample, struct sample_entry *entry, HRESULT *result)
 {
     GstBuffer *buffer = gst_sample_get_buffer(entry->sample);
+    GstCaps *caps = gst_sample_get_caps(entry->sample);
+    struct wg_format format;
     GstMapInfo info;
 
     sample->size = 0;
+    wg_format_from_caps(&format, caps);
+    if (!wg_format_compare(&sample->format, &format))
+    {
+        sample->format = format;
+        *result = MF_E_TRANSFORM_STREAM_CHANGE;
+        return STATUS_SUCCESS;
+    }
+
     if (!gst_buffer_map(buffer, &info, GST_MAP_READ))
     {
         GST_ERROR("Failed to map buffer %p", buffer);
@@ -434,6 +501,8 @@ static NTSTATUS copy_from_sample_entry(struct wg_sample *sample, struct sample_e
     copy_sample_meta_data(sample, entry);
 
     GST_INFO("Copied %u bytes, flags %#x", sample->size, (UINT32)sample->flags);
+
+    *result = S_OK;
     return STATUS_SUCCESS;
 }
 
@@ -449,9 +518,8 @@ NTSTATUS wg_transform_read_data(void *args)
     pthread_mutex_lock(&transform->mutex);
     if ((head = list_head(&transform->samples)))
     {
-        params->result = S_OK;
         entry = LIST_ENTRY(head, struct sample_entry, entry);
-        status = copy_from_sample_entry(sample, entry);
+        status = copy_from_sample_entry(sample, entry, &params->result);
         release_sample_entry(sample, entry);
     }
     else
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -58,6 +58,7 @@ struct wma_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
@@ -69,6 +70,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
 {
     struct wg_format input_format, output_format;
 
+    memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
     decoder->wg_transform = NULL;
@@ -84,6 +86,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
     if (!(decoder->wg_transform = wg_transform_create(&input_format, &output_format)))
         return E_FAIL;
 
+    decoder->wg_format = output_format;
     return S_OK;
 }
 
@@ -579,6 +582,7 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
         return hr;
 
+    wg_sample->format = decoder->wg_format;
     wg_sample->size = 0;
     if (wg_sample->max_size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;

