From 11870982af639c5b4c31eecbf5a2b5f9ef300518 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 16 Feb 2022 12:01:15 +0100
Subject: [PATCH 29/30] winegstreamer: Support XMAudio2 input format in WMA
 decoder.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
---
 dlls/winegstreamer/mfplat.c      | 12 +++++++++++-
 dlls/winegstreamer/unixlib.h     |  1 +
 dlls/winegstreamer/wg_format.c   | 22 ++++++++++++++++------
 dlls/winegstreamer/wma_decoder.c |  3 +++
 4 files changed, 31 insertions(+), 7 deletions(-)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -37,6 +37,8 @@ DEFINE_GUID(DMOVideoFormat_RGB565,D3DFMT_R5G6B5,0x524f,0x11ce,0x9f,0x53,0x00,0x2
 DEFINE_GUID(DMOVideoFormat_RGB555,D3DFMT_X1R5G5B5,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
 DEFINE_GUID(DMOVideoFormat_RGB8,D3DFMT_P8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
 
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 struct video_processor
 {
     IMFTransform IMFTransform_iface;
@@ -888,6 +890,7 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
 {
     UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
     BYTE codec_data[64];
+    bool is_xma = false;
     UINT32 version;
 
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
@@ -929,6 +932,11 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
         version = 3;
     else if (IsEqualGUID(subtype, &MFAudioFormat_WMAudio_Lossless))
         version = 4;
+    else if (IsEqualGUID(subtype, &MFAudioFormat_XMAudio2))
+    {
+        version = 2;
+        is_xma = true;
+    }
     else
     {
         assert(0);
@@ -944,6 +952,7 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
     format->u.wma.block_align = block_align;
     format->u.wma.codec_data_len = codec_data_len;
     memcpy(format->u.wma.codec_data, codec_data, codec_data_len);
+    format->u.wma.is_xma = is_xma;
 }
 
 static void mf_media_type_to_wg_format_h264(IMFMediaType *type, struct wg_format *format)
@@ -1000,7 +1009,8 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
         if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9) ||
-                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
+                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless) ||
+                IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
             mf_media_type_to_wg_format_wma(type, &subtype, format);
         else
             mf_media_type_to_wg_format_audio(type, &subtype, format);
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -104,6 +104,7 @@ struct wg_format
             uint32_t block_align;
             uint32_t codec_data_len;
             unsigned char codec_data[64];
+            bool is_xma;
         } wma;
         struct
         {
diff --git a/dlls/winegstreamer/wg_format.c b/dlls/winegstreamer/wg_format.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_format.c
+++ b/dlls/winegstreamer/wg_format.c
@@ -407,15 +407,25 @@ static GstCaps *wg_format_to_caps_video(const struct wg_format *format)
     return caps;
 }
 
-static GstCaps *wg_format_to_caps_wma(const struct wg_format *format)
+static GstCaps *wg_format_to_caps_xwma(const struct wg_format *format)
 {
     GstBuffer *buffer;
     GstCaps *caps;
 
-    if (!(caps = gst_caps_new_empty_simple("audio/x-wma")))
-        return NULL;
-    if (format->u.wma.version)
-        gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.wma.version, NULL);
+    if (format->u.wma.is_xma)
+    {
+        if (!(caps = gst_caps_new_empty_simple("audio/x-xma")))
+            return NULL;
+        if (format->u.wma.version)
+            gst_caps_set_simple(caps, "xmaversion", G_TYPE_INT, format->u.wma.version, NULL);
+    }
+    else
+    {
+        if (!(caps = gst_caps_new_empty_simple("audio/x-wma")))
+            return NULL;
+        if (format->u.wma.version)
+            gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.wma.version, NULL);
+    }
 
     if (format->u.wma.bitrate)
         gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.wma.bitrate, NULL);
@@ -516,7 +526,7 @@ GstCaps *wg_format_to_caps(const struct wg_format *format)
         case WG_MAJOR_TYPE_MPEG1_AUDIO:
             return wg_format_to_caps_mpeg1_audio(format);
         case WG_MAJOR_TYPE_WMA:
-            return wg_format_to_caps_wma(format);
+            return wg_format_to_caps_xwma(format);
         case WG_MAJOR_TYPE_H264:
             return wg_format_to_caps_h264(format);
         case WG_MAJOR_TYPE_AUDIO:
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -31,12 +31,15 @@
 WINE_DEFAULT_DEBUG_CHANNEL(wmadec);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 static const GUID *const wma_decoder_input_types[] =
 {
     &MEDIASUBTYPE_MSAUDIO1,
     &MFAudioFormat_WMAudioV8,
     &MFAudioFormat_WMAudioV9,
     &MFAudioFormat_WMAudio_Lossless,
+    &MFAudioFormat_XMAudio2,
 };
 static const GUID *const wma_decoder_output_types[] =
 {
-- 
2.37.1

