From fd294e60820e843b80ea3ccb8e928944e8491e70 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 8 Mar 2022 23:31:36 +0100
Subject: [PATCH 06/20] winegstreamer: Implement H264 decoder ProcessOutput.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/mf/tests/mf.c                |  6 ---
 dlls/winegstreamer/h264_decoder.c | 63 ++++++++++++++++++++++++--
 dlls/winegstreamer/unix_private.h |  2 +
 dlls/winegstreamer/unixlib.h      |  1 +
 dlls/winegstreamer/wg_transform.c | 75 +++++++++++++++++++++++++++----
 dlls/winegstreamer/wma_decoder.c  |  4 ++
 6 files changed, 134 insertions(+), 17 deletions(-)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 11111111111..11111111111 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -6822,7 +6822,6 @@ static void test_h264_decoder(void)
     status = 0;
     memset(&output, 0, sizeof(output));
     hr = IMFTransform_ProcessOutput(transform, 0, 1, &output, &status);
-    todo_wine
     ok(hr == E_INVALIDARG || hr == MF_E_TRANSFORM_NEED_MORE_INPUT, "ProcessOutput returned %#lx\n", hr);
     ok(output.dwStreamID == 0, "got dwStreamID %lu\n", output.dwStreamID);
     ok(!output.pSample, "got pSample %p\n", output.pSample);
@@ -6850,7 +6849,6 @@ static void test_h264_decoder(void)
         ok(ret == 0, "Release returned %lu\n", ret);
 
         hr = IMFTransform_ProcessInput(transform, 0, sample, 0);
-        todo_wine
         ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
         ret = IMFSample_Release(sample);
         ok(ret <= 1, "Release returned %lu\n", ret);
@@ -6872,15 +6870,12 @@ static void test_h264_decoder(void)
     ok(i == 2, "got %lu iterations\n", i);
     todo_wine
     ok(h264_encoded_data_len == 48194, "got h264_encoded_data_len %lu\n", h264_encoded_data_len);
-    todo_wine
     ok(hr == MF_E_TRANSFORM_STREAM_CHANGE, "ProcessOutput returned %#lx\n", hr);
     ok(output.dwStreamID == 0, "got dwStreamID %lu\n", output.dwStreamID);
     ok(!!output.pSample, "got pSample %p\n", output.pSample);
-    todo_wine
     ok(output.dwStatus == MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE,
             "got dwStatus %#lx\n", output.dwStatus);
     ok(!output.pEvents, "got pEvents %p\n", output.pEvents);
-    todo_wine
     ok(status == MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS,
             "got status %#lx\n", status);
     check_sample(output.pSample, NULL, 0, NULL);
@@ -6925,7 +6920,6 @@ static void test_h264_decoder(void)
     memset(&output, 0, sizeof(output));
     output.pSample = create_sample(NULL, actual_width * actual_height * 2);
     hr = IMFTransform_ProcessOutput(transform, 0, 1, &output, &status);
-    todo_wine
     ok(hr == S_OK, "ProcessOutput returned %#lx\n", hr);
     ok(output.dwStreamID == 0, "got dwStreamID %lu\n", output.dwStreamID);
     ok(!!output.pSample, "got pSample %p\n", output.pSample);
diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -50,6 +50,7 @@ struct h264_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -62,6 +63,7 @@ static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
     struct wg_format input_format;
     struct wg_format output_format;
 
+    memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
     decoder->wg_transform = NULL;
@@ -369,7 +371,7 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
         goto done;
 
-    hr = fill_output_media_type(media_type, NULL);
+    hr = fill_output_media_type(media_type, decoder->output_type);
 
 done:
     if (SUCCEEDED(hr))
@@ -418,6 +420,7 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
     ULONG i;
 
@@ -440,7 +443,14 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
         return MF_E_INVALIDMEDIATYPE;
 
     if (decoder->output_type)
+    {
+        fill_output_media_type(decoder->output_type, NULL);
+        if (SUCCEEDED(hr = IMFMediaType_Compare(decoder->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
         IMFMediaType_Release(decoder->output_type);
+    }
+
     IMFMediaType_AddRef((decoder->output_type = type));
 
     if (FAILED(hr = try_create_wg_transform(decoder)))
@@ -503,8 +513,55 @@ static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFS
 static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("iface %p, flags %#lx, count %lu, samples %p, status %p stub!\n", iface, flags, count, samples, status);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    MFT_OUTPUT_STREAM_INFO info;
+    struct wg_sample *wg_sample;
+    IMFMediaType *media_type;
+    UINT64 frame_rate;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count != 1)
+        return E_INVALIDARG;
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &frame_rate)))
+        frame_rate = (UINT64)30000 << 32 | 1001;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample) return E_INVALIDARG;
+
+    if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
+        return hr;
+
+    wg_sample->format = decoder->wg_format;
+    if (wg_sample->max_size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else
+        hr = wg_transform_read_data(decoder->wg_transform, wg_sample);
+
+    if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        decoder->wg_format = wg_sample->format;
+        media_type = mf_media_type_from_wg_format(&wg_sample->format);
+        IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, frame_rate);
+
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
+    mf_destroy_wg_sample(wg_sample);
+    return hr;
 }
 
 static const IMFTransformVtbl transform_vtbl =
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -31,6 +31,8 @@ extern GstElement *create_element(const char *name, const char *plugin_set) DECL
 extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
 extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
 extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
+extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
+extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
 
 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -119,6 +119,7 @@ enum wg_sample_flag
 
 struct wg_sample
 {
+    struct wg_format format;
     UINT32 flags;
     UINT32 max_size;
     UINT32 size;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -52,6 +52,7 @@ struct wg_transform
     guint input_max_length;
 
     pthread_mutex_t mutex;
+    GstCaps *sink_caps, *output_caps;
     GstBuffer *output;
 };
 
@@ -71,6 +72,42 @@ static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, Gst
     return GST_FLOW_OK;
 }
 
+static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_LOG("transform %p, type \"%s\".", transform, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps, *prev_caps;
+        gchar *str;
+
+        gst_event_parse_caps(event, &caps);
+        str = gst_caps_to_string(caps);
+        GST_INFO("Got caps \"%s\".", str);
+        g_free(str);
+
+        pthread_mutex_lock(&transform->mutex);
+        prev_caps = transform->sink_caps;
+        transform->sink_caps = gst_caps_ref(caps);
+        if (transform->output_caps || !gst_caps_is_always_compatible(prev_caps, caps))
+            transform->output_caps = transform->sink_caps;
+        gst_caps_unref(prev_caps);
+        pthread_mutex_unlock(&transform->mutex);
+        break;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+        break;
+    }
+
+    gst_event_unref(event);
+    return TRUE;
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
@@ -86,6 +123,7 @@ NTSTATUS wg_transform_destroy(void *args)
     g_object_unref(transform->container);
     g_object_unref(transform->my_sink);
     g_object_unref(transform->my_src);
+    gst_caps_unref(transform->sink_caps);
     pthread_mutex_destroy(&transform->mutex);
     free(transform);
 
@@ -163,15 +201,16 @@ static bool transform_append_element(struct wg_transform *transform, GstElement
 NTSTATUS wg_transform_create(void *args)
 {
     struct wg_transform_create_params *params = args;
-    GstCaps *raw_caps = NULL, *src_caps = NULL, *sink_caps = NULL;
     struct wg_format output_format = *params->output_format;
     struct wg_format input_format = *params->input_format;
     GstElement *first = NULL, *last = NULL, *element;
+    GstCaps *raw_caps = NULL, *src_caps = NULL;
     NTSTATUS status = STATUS_UNSUCCESSFUL;
     GstPadTemplate *template = NULL;
     struct wg_transform *transform;
     const gchar *media_type;
     GstEvent *event;
+    int i;
 
     if (!init_gstreamer())
         return STATUS_UNSUCCESSFUL;
@@ -193,9 +232,17 @@ NTSTATUS wg_transform_create(void *args)
     if (!transform->my_src)
         goto out;
 
-    if (!(sink_caps = wg_format_to_caps(&output_format)))
+    if (!(transform->sink_caps = wg_format_to_caps(&output_format)))
         goto out;
-    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps)))
+
+    /* Remove the frame size attributes so that our sink doesn't force any
+     * video frame size, and instead let it dynamically change.
+     */
+    for (i = 0; i < gst_caps_get_size(transform->sink_caps); ++i)
+        gst_structure_remove_fields(gst_caps_get_structure(transform->sink_caps, i),
+                "width", "height", NULL);
+
+    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, transform->sink_caps)))
         goto out;
     transform->my_sink = gst_pad_new_from_template(template, "sink");
     g_object_unref(template);
@@ -203,13 +250,14 @@ NTSTATUS wg_transform_create(void *args)
         goto out;
 
     gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
 
     /* Since we append conversion elements, we don't want to filter decoders
      * based on the actual output caps now. Matching decoders with the
      * raw output media type should be enough.
      */
-    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
+    media_type = gst_structure_get_name(gst_caps_get_structure(transform->sink_caps, 0));
     if (!(raw_caps = gst_caps_new_empty_simple(media_type)))
         goto out;
 
@@ -263,6 +311,11 @@ NTSTATUS wg_transform_create(void *args)
             break;
 
         case WG_MAJOR_TYPE_VIDEO:
+            if (!(element = create_element("videoconvert", "base"))
+                    || !transform_append_element(transform, element, &first, &last))
+                goto out;
+            /* Let GStreamer choose a default number of threads. */
+            gst_util_set_object_arg(G_OBJECT(element), "n-threads", "0");
             break;
 
         case WG_MAJOR_TYPE_H264:
@@ -305,7 +358,6 @@ NTSTATUS wg_transform_create(void *args)
             || !gst_pad_push_event(transform->my_src, event))
         goto out;
 
-    gst_caps_unref(sink_caps);
     gst_caps_unref(src_caps);
 
     pthread_mutex_init(&transform->mutex, NULL);
@@ -321,8 +373,8 @@ out:
         gst_object_unref(transform->their_src);
     if (transform->my_sink)
         gst_object_unref(transform->my_sink);
-    if (sink_caps)
-        gst_caps_unref(sink_caps);
+    if (transform->sink_caps)
+        gst_caps_unref(transform->sink_caps);
     if (transform->my_src)
         gst_object_unref(transform->my_src);
     if (src_caps)
@@ -426,7 +478,14 @@ NTSTATUS wg_transform_read_data(void *args)
 
     sample->size = 0;
     pthread_mutex_lock(&transform->mutex);
-    if (transform->output)
+    if (transform->output_caps)
+    {
+        wg_format_from_caps(&sample->format, transform->output_caps);
+        transform->output_caps = NULL;
+        params->result = MF_E_TRANSFORM_STREAM_CHANGE;
+        status = STATUS_SUCCESS;
+    }
+    else if (transform->output)
     {
         params->result = S_OK;
         status = read_transform_output_data(transform, sample);
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -58,6 +58,7 @@ struct wma_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
@@ -69,6 +70,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
 {
     struct wg_format input_format, output_format;
 
+    memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
     decoder->wg_transform = NULL;
@@ -84,6 +86,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
     if (!(decoder->wg_transform = wg_transform_create(&input_format, &output_format)))
         return E_FAIL;
 
+    decoder->wg_format = output_format;
     return S_OK;
 }
 
@@ -579,6 +582,7 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
         return hr;
 
+    wg_sample->format = decoder->wg_format;
     wg_sample->size = 0;
     if (wg_sample->max_size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
-- 
2.35.1

