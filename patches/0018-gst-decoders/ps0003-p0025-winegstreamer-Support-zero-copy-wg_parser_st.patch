From 60a89f990c77ec25db52f052647b5de3c5fac9c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 7 Jun 2022 09:21:15 +0200
Subject: [PATCH 25/30] winegstreamer: Support zero-copy
 wg_parser_stream_read_data for media_source.

---
 dlls/winegstreamer/gst_private.h  |  3 ++
 dlls/winegstreamer/media_source.c | 22 +++++-----
 dlls/winegstreamer/unixlib.h      |  1 +
 dlls/winegstreamer/wg_parser.c    | 67 +++++++++++++++++++++++--------
 dlls/winegstreamer/wg_sample.c    | 30 ++++++++++++++
 5 files changed, 98 insertions(+), 25 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -135,6 +135,9 @@ void wg_sample_release(struct wg_sample *wg_sample);
 void wg_sample_queue_begin_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample);
 void wg_sample_queue_end_append(struct wg_sample_queue *queue, struct wg_sample *wg_sample);
 
+bool wg_sample_queue_find_mf(struct wg_sample_queue *queue, void *data,
+        struct wg_sample **wg_sample, IMFSample **mf_sample);
+
 HRESULT wg_transform_push_mf(struct wg_transform *transform, struct wg_sample *sample,
         struct wg_sample_queue *queue);
 HRESULT wg_transform_push_quartz(struct wg_transform *transform, struct wg_sample *sample,
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -471,21 +471,25 @@ static HRESULT mf_allocate_sample(UINT32 size, IMFSample **sample)
 
 static void send_buffer(struct media_stream *stream, const struct wg_parser_buffer *wg_buffer, IUnknown *token)
 {
+    struct media_source *source = stream->parent_source;
     struct wg_sample *wg_sample;
     IMFSample *sample;
     bool success;
     HRESULT hr;
 
-    if (FAILED(hr = mf_allocate_sample(wg_buffer->size, &sample)))
+    if (!wg_sample_queue_find_mf(source->wg_sample_queue, wg_buffer->data, &wg_sample, &sample))
     {
-        ERR("Failed to create sample, hr %#lx.\n", hr);
-        return;
-    }
-    if (FAILED(hr = wg_sample_create_mf(sample, &wg_sample)))
-    {
-        ERR("Failed to create sample, hr %#lx.\n", hr);
-        IMFSample_Release(sample);
-        return;
+        if (FAILED(hr = mf_allocate_sample(wg_buffer->size, &sample)))
+        {
+            ERR("Failed to create sample, hr %#lx.\n", hr);
+            return;
+        }
+        if (FAILED(hr = wg_sample_create_mf(sample, &wg_sample)))
+        {
+            ERR("Failed to create sample, hr %#lx.\n", hr);
+            IMFSample_Release(sample);
+            return;
+        }
     }
 
     success = wg_parser_stream_read_mf(stream->wg_stream, wg_sample);
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -167,6 +167,7 @@ struct wg_parser_buffer
     UINT64 pts;
     UINT32 size;
     bool has_pts;
+    void *data;
 };
 
 enum wg_parser_type
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -292,31 +292,42 @@ static NTSTATUS wg_parser_stream_get_buffer(void *args)
     struct wg_parser_stream *stream = params->stream;
     struct wg_parser *parser = stream->parser;
     GstBuffer *buffer;
+    GstMapInfo info;
 
     pthread_mutex_lock(&parser->mutex);
 
     while (!stream->eos && !stream->buffer)
         pthread_cond_wait(&stream->event_cond, &parser->mutex);
 
+    if (!stream->buffer)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return S_FALSE;
+    }
+
+    buffer = gst_buffer_ref(stream->buffer);
+    pthread_mutex_unlock(&parser->mutex);
+
     /* Note that we can both have a buffer and stream->eos, in which case we
      * must return the buffer. */
-    if ((buffer = stream->buffer))
-    {
-        /* FIXME: Should we use gst_segment_to_stream_time_full()? Under what
-         * circumstances is the stream time not equal to the buffer PTS? Note
-         * that this will need modification to wg_parser_stream_notify_qos() as
-         * well. */
 
-        if ((wg_buffer->has_pts = GST_BUFFER_PTS_IS_VALID(buffer)))
-            wg_buffer->pts = GST_BUFFER_PTS(buffer) / 100;
-        wg_buffer->size = gst_buffer_get_size(buffer);
+    /* FIXME: Should we use gst_segment_to_stream_time_full()? Under what
+     * circumstances is the stream time not equal to the buffer PTS? Note
+     * that this will need modification to wg_parser_stream_notify_qos() as
+     * well. */
 
-        pthread_mutex_unlock(&parser->mutex);
-        return S_OK;
+    if ((wg_buffer->has_pts = GST_BUFFER_PTS_IS_VALID(buffer)))
+        wg_buffer->pts = GST_BUFFER_PTS(buffer) / 100;
+    wg_buffer->size = gst_buffer_get_size(buffer);
+    wg_buffer->data = NULL;
+    if (gst_buffer_map(buffer, &info, GST_MAP_READ))
+    {
+        wg_buffer->data = info.data;
+        gst_buffer_unmap(buffer, &info);
     }
 
-    pthread_mutex_unlock(&parser->mutex);
-    return S_FALSE;
+    gst_buffer_unref(buffer);
+    return S_OK;
 }
 
 static NTSTATUS wg_parser_stream_read_data(void *args)
@@ -325,6 +336,8 @@ static NTSTATUS wg_parser_stream_read_data(void *args)
     struct wg_parser_stream *stream = params->stream;
     struct wg_parser *parser = stream->parser;
     struct wg_sample *sample = params->sample;
+    bool discard_data = false;
+    GstBuffer *buffer;
     NTSTATUS status;
 
     pthread_mutex_lock(&parser->mutex);
@@ -335,16 +348,38 @@ static NTSTATUS wg_parser_stream_read_data(void *args)
         return VFW_E_WRONG_STATE;
     }
 
-    status = wg_sample_read_from_buffer(stream->buffer, NULL, 0, sample);
+    buffer = gst_buffer_ref(stream->buffer);
+
+    pthread_mutex_unlock(&parser->mutex);
+
+    if ((status = wg_sample_read_from_buffer(buffer, NULL, 0, sample)))
+    {
+        gst_buffer_unref(buffer);
+        wg_allocator_release_sample(stream->allocator, sample, false);
+        return status;
+    }
+
     if (!(sample->flags & WG_SAMPLE_FLAG_INCOMPLETE))
     {
+        pthread_mutex_lock(&parser->mutex);
         gst_buffer_unref(stream->buffer);
         stream->buffer = NULL;
+        pthread_mutex_unlock(&parser->mutex);
         pthread_cond_signal(&stream->event_empty_cond);
-    }
 
-    pthread_mutex_unlock(&parser->mutex);
+        /* Make sure the memory cannot be reused by the buffer pool so it always
+         * requests memory from the allocator, and so we can provide output sample
+         * memory to achieve zero-copy. However, some decoder keep a reference on
+         * the buffer they passed downstream, to re-use it later. In this case, it
+         * will not be possible to do zero-copy, and we should copy the data back
+         * to the buffer and leave it unchanged.
+         */
+        if ((discard_data = gst_buffer_is_writable(buffer)))
+            gst_buffer_remove_all_memory(buffer);
+    }
 
+    gst_buffer_unref(buffer);
+    wg_allocator_release_sample(stream->allocator, sample, discard_data);
     return status;
 }
 
diff --git a/dlls/winegstreamer/wg_sample.c b/dlls/winegstreamer/wg_sample.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_sample.c
+++ b/dlls/winegstreamer/wg_sample.c
@@ -561,3 +561,33 @@ bool wg_parser_stream_read_wm(struct wg_parser_stream *stream, struct wg_sample
 
     return true;
 }
+
+bool wg_sample_queue_find_mf(struct wg_sample_queue *queue, void *data,
+        struct wg_sample **wg_sample, IMFSample **mf_sample)
+{
+    struct sample *sample, *next;
+
+    *wg_sample = NULL;
+    EnterCriticalSection(&queue->cs);
+
+    LIST_FOR_EACH_ENTRY_SAFE(sample, next, &queue->samples, struct sample, entry)
+    {
+        if (sample->wg_sample.data != data)
+            continue;
+
+        if (sample->ops != &mf_sample_ops)
+        {
+            WARN_(mfplat)("Invalid sample %p ops %p for data %p\n", sample->u.mf.sample, sample->ops, data);
+            break;
+        }
+
+        TRACE_(mfplat)("Found sample %p for data %p\n", sample->u.mf.sample, data);
+        IMFSample_AddRef((*mf_sample = sample->u.mf.sample));
+        *wg_sample = &sample->wg_sample;
+        list_remove(&sample->entry);
+        break;
+    }
+
+    LeaveCriticalSection(&queue->cs);
+    return !!*wg_sample;
+}
-- 
2.37.1

