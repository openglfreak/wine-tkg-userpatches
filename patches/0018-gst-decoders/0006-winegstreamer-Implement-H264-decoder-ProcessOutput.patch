From 1e9ceab33cad28b3468eaf95b676a74dc5efd300 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 8 Mar 2022 23:31:36 +0100
Subject: [PATCH 06/20] winegstreamer: Implement H264 decoder ProcessOutput.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 31 ++++++++++++-
 dlls/winegstreamer/unix_private.h |  2 +
 dlls/winegstreamer/unixlib.h      |  1 +
 dlls/winegstreamer/wg_transform.c | 72 ++++++++++++++++++++++++++++---
 dlls/winegstreamer/wma_decoder.c  |  4 ++
 5 files changed, 102 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -50,6 +50,7 @@ struct h264_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -62,6 +63,7 @@ static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
     struct wg_format input_format;
     struct wg_format output_format;
 
+    memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
     decoder->wg_transform = NULL;
@@ -369,7 +371,7 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
         goto done;
 
-    hr = fill_output_media_type(media_type, NULL);
+    hr = fill_output_media_type(media_type, decoder->output_type);
 
 done:
     if (SUCCEEDED(hr))
@@ -418,6 +420,7 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
     ULONG i;
 
@@ -440,7 +443,14 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
         return MF_E_INVALIDMEDIATYPE;
 
     if (decoder->output_type)
+    {
+        fill_output_media_type(decoder->output_type, NULL);
+        if (SUCCEEDED(hr = IMFMediaType_Compare(decoder->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
         IMFMediaType_Release(decoder->output_type);
+    }
+
     IMFMediaType_AddRef((decoder->output_type = type));
 
     if (FAILED(hr = try_create_wg_transform(decoder)))
@@ -524,6 +534,8 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     MFT_OUTPUT_STREAM_INFO info;
     struct wg_sample *wg_sample;
+    IMFMediaType *media_type;
+    UINT64 frame_rate;
     HRESULT hr;
 
     TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
@@ -537,6 +549,9 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (!decoder->wg_transform)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
 
+    if (FAILED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &frame_rate)))
+        frame_rate = (UINT64)30000 << 32 | 1001;
+
     *status = 0;
     samples[0].dwStatus = 0;
     if (!samples[0].pSample) return E_INVALIDARG;
@@ -544,11 +559,25 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
         return hr;
 
+    wg_sample->format = decoder->wg_format;
     if (wg_sample->max_size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
     else
         hr = wg_transform_read_data(decoder->wg_transform, wg_sample);
 
+    if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        decoder->wg_format = wg_sample->format;
+        media_type = mf_media_type_from_wg_format(&wg_sample->format);
+        IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, frame_rate);
+
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
     mf_destroy_wg_sample(wg_sample);
     return hr;
 }
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -31,6 +31,8 @@ extern GstElement *create_element(const char *name, const char *plugin_set) DECL
 extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
 extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
 extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
+extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
+extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
 
 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -119,6 +119,7 @@ enum wg_sample_flag
 
 struct wg_sample
 {
+    struct wg_format format;
     UINT32 flags;
     UINT32 max_size;
     UINT32 size;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -50,6 +50,7 @@ struct wg_transform
     GstSegment segment;
     GstBufferList *input;
     guint input_max_length;
+    GstCaps *sink_caps, *output_caps;
     GstAtomicQueue *output_queue;
     GstBuffer *output_buffer;
 };
@@ -65,6 +66,40 @@ static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, Gst
     return GST_FLOW_OK;
 }
 
+static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_LOG("transform %p, type \"%s\".", transform, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps, *prev_caps;
+        gchar *str;
+
+        gst_event_parse_caps(event, &caps);
+        str = gst_caps_to_string(caps);
+        GST_INFO("Got caps \"%s\".", str);
+        g_free(str);
+
+        prev_caps = transform->sink_caps;
+        transform->sink_caps = gst_caps_ref(caps);
+        if (transform->output_caps || !gst_caps_is_always_compatible(prev_caps, caps))
+            transform->output_caps = transform->sink_caps;
+        gst_caps_unref(prev_caps);
+        break;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+        break;
+    }
+
+    gst_event_unref(event);
+    return TRUE;
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
@@ -85,6 +120,7 @@ NTSTATUS wg_transform_destroy(void *args)
     g_object_unref(transform->container);
     g_object_unref(transform->my_sink);
     g_object_unref(transform->my_src);
+    gst_caps_unref(transform->sink_caps);
     gst_atomic_queue_unref(transform->output_queue);
     free(transform);
 
@@ -162,15 +198,16 @@ static bool transform_append_element(struct wg_transform *transform, GstElement
 NTSTATUS wg_transform_create(void *args)
 {
     struct wg_transform_create_params *params = args;
-    GstCaps *raw_caps = NULL, *src_caps = NULL, *sink_caps = NULL;
     struct wg_format output_format = *params->output_format;
     struct wg_format input_format = *params->input_format;
     GstElement *first = NULL, *last = NULL, *element;
+    GstCaps *raw_caps = NULL, *src_caps = NULL;
     NTSTATUS status = STATUS_UNSUCCESSFUL;
     GstPadTemplate *template = NULL;
     struct wg_transform *transform;
     const gchar *media_type;
     GstEvent *event;
+    int i;
 
     if (!init_gstreamer())
         return STATUS_UNSUCCESSFUL;
@@ -194,9 +231,17 @@ NTSTATUS wg_transform_create(void *args)
     if (!transform->my_src)
         goto out;
 
-    if (!(sink_caps = wg_format_to_caps(&output_format)))
+    if (!(transform->sink_caps = wg_format_to_caps(&output_format)))
         goto out;
-    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps)))
+
+    /* Remove the frame size attributes so that our sink doesn't force any
+     * video frame size, and instead let it dynamically change.
+     */
+    for (i = 0; i < gst_caps_get_size(transform->sink_caps); ++i)
+        gst_structure_remove_fields(gst_caps_get_structure(transform->sink_caps, i),
+                "width", "height", NULL);
+
+    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, transform->sink_caps)))
         goto out;
     transform->my_sink = gst_pad_new_from_template(template, "sink");
     g_object_unref(template);
@@ -204,13 +249,14 @@ NTSTATUS wg_transform_create(void *args)
         goto out;
 
     gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
 
     /* Since we append conversion elements, we don't want to filter decoders
      * based on the actual output caps now. Matching decoders with the
      * raw output media type should be enough.
      */
-    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
+    media_type = gst_structure_get_name(gst_caps_get_structure(transform->sink_caps, 0));
     if (!(raw_caps = gst_caps_new_empty_simple(media_type)))
         goto out;
 
@@ -264,6 +310,11 @@ NTSTATUS wg_transform_create(void *args)
             break;
 
         case WG_MAJOR_TYPE_VIDEO:
+            if (!(element = create_element("videoconvert", "base"))
+                    || !transform_append_element(transform, element, &first, &last))
+                goto out;
+            /* Let GStreamer choose a default number of threads. */
+            gst_util_set_object_arg(G_OBJECT(element), "n-threads", "0");
             break;
 
         case WG_MAJOR_TYPE_H264:
@@ -306,7 +357,6 @@ NTSTATUS wg_transform_create(void *args)
             || !gst_pad_push_event(transform->my_src, event))
         goto out;
 
-    gst_caps_unref(sink_caps);
     gst_caps_unref(src_caps);
 
     GST_INFO("Created winegstreamer transform %p.", transform);
@@ -320,8 +370,8 @@ out:
         gst_object_unref(transform->their_src);
     if (transform->my_sink)
         gst_object_unref(transform->my_sink);
-    if (sink_caps)
-        gst_caps_unref(sink_caps);
+    if (transform->sink_caps)
+        gst_caps_unref(transform->sink_caps);
     if (transform->my_src)
         gst_object_unref(transform->my_src);
     if (src_caps)
@@ -417,6 +467,14 @@ NTSTATUS wg_transform_read_data(void *args)
         return STATUS_UNSUCCESSFUL;
     }
 
+    if (transform->output_caps)
+    {
+        wg_format_from_caps(&sample->format, transform->output_caps);
+        transform->output_caps = NULL;
+        params->result = MF_E_TRANSFORM_STREAM_CHANGE;
+        return STATUS_SUCCESS;
+    }
+
     if (!transform->output_buffer && !(transform->output_buffer = gst_atomic_queue_pop(transform->output_queue)))
     {
         sample->size = 0;
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -58,6 +58,7 @@ struct wma_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
 };
 
 static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
@@ -69,6 +70,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
 {
     struct wg_format input_format, output_format;
 
+    memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
     decoder->wg_transform = NULL;
@@ -84,6 +86,7 @@ static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
     if (!(decoder->wg_transform = wg_transform_create(&input_format, &output_format)))
         return E_FAIL;
 
+    decoder->wg_format = output_format;
     return S_OK;
 }
 
@@ -579,6 +582,7 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
         return hr;
 
+    wg_sample->format = decoder->wg_format;
     wg_sample->size = 0;
     if (wg_sample->max_size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
-- 
2.35.3

