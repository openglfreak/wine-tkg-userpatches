From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Subject: [PATCH 1/5] mountmgr.sys: Move query_unix_drive to drive.c.
Message-Id: <CAEU2+voy2Kk1uOPkMdFaHCOZ6oTqKuDqEuE4=4FePpq=hae2jw@mail.gmail.com>
Date: Thu, 18 Mar 2021 10:52:57 -0600

The purpose of this patchset is to further consolidate the volume
information in the mountmgr.  Currently there are a couple of
different paths that can be taken to obtain the volume information, by
the end of this set all
FileFsAttributeInformation/FileFsVolumeInformation queries run through
the same code in the mountmgr.

This particular patch just moves query_unix_device to facilitate code
reuse in later patches.

Best,
Erich

From 9138b7e7e4cde0f29a71af4e3c6806b767930d56 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Sun, 28 Feb 2021 11:15:30 -0700
#Subject: mountmgr.sys: Move query_unix_drive to drive.c.

Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
---
 dlls/mountmgr.sys/device.c   | 100 +++++++++++++++++++++++++++++++++--
 dlls/mountmgr.sys/mountmgr.c |  91 -------------------------------
 dlls/mountmgr.sys/mountmgr.h |   7 +--
 3 files changed, 97 insertions(+), 101 deletions(-)

diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
index dd2c7d70759..418bb9e9420 100644
--- a/dlls/mountmgr.sys/device.c
+++ b/dlls/mountmgr.sys/device.c
@@ -1696,8 +1696,8 @@ static enum mountmgr_fs_type get_mountmgr_fs_type(enum fs_type fs_type)
 }
 
 /* query information about an existing dos drive, by letter or udi */
-NTSTATUS query_dos_device( int letter, enum device_type *type, enum mountmgr_fs_type *fs_type,
-                           DWORD *serial, char **device, char **mount_point, WCHAR **label )
+static NTSTATUS query_dos_device( int letter, enum device_type *type, enum mountmgr_fs_type *fs_type,
+                                  DWORD *serial, char **device, char **mount_point, WCHAR **label )
 {
     NTSTATUS status = STATUS_NO_SUCH_DEVICE;
     struct dos_drive *drive;
@@ -1722,9 +1722,9 @@ NTSTATUS query_dos_device( int letter, enum device_type *type, enum mountmgr_fs_
 }
 
 /* query information about an existing unix device, by dev_t */
-NTSTATUS query_unix_device( ULONGLONG unix_dev, enum device_type *type,
-                            enum mountmgr_fs_type *fs_type, DWORD *serial, char **device,
-                            char **mount_point, WCHAR **label )
+static NTSTATUS query_unix_device( ULONGLONG unix_dev, enum device_type *type,
+                                   enum mountmgr_fs_type *fs_type, DWORD *serial, char **device,
+                                   char **mount_point, WCHAR **label )
 {
     NTSTATUS status = STATUS_NO_SUCH_DEVICE;
     struct volume *volume;
@@ -1754,6 +1754,96 @@ NTSTATUS query_unix_device( ULONGLONG unix_dev, enum device_type *type,
     return status;
 }
 
+/* implementation of IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE */
+NTSTATUS query_unix_drive( void *buff, SIZE_T insize, SIZE_T outsize, IO_STATUS_BLOCK *iosb )
+{
+    const struct mountmgr_unix_drive *input = buff;
+    struct mountmgr_unix_drive *output = NULL;
+    char *device, *mount_point;
+    int letter = tolowerW( input->letter );
+    NTSTATUS status;
+    DWORD size, type = DEVICE_UNKNOWN, serial;
+    enum mountmgr_fs_type fs_type;
+    enum device_type device_type;
+    char *ptr;
+    WCHAR *label;
+
+    if (!letter)
+    {
+        if ((status = query_unix_device( input->unix_dev, &device_type, &fs_type,
+                                         &serial, &device, &mount_point, &label )))
+            return status;
+    }
+    else
+    {
+        if (letter < 'a' || letter > 'z') return STATUS_INVALID_PARAMETER;
+
+        if ((status = query_dos_device( letter - 'a', &device_type, &fs_type, &serial, &device,
+                                        &mount_point, &label )))
+            return status;
+    }
+
+    switch (device_type)
+    {
+    case DEVICE_UNKNOWN:      type = DRIVE_UNKNOWN; break;
+    case DEVICE_HARDDISK:     type = DRIVE_REMOVABLE; break;
+    case DEVICE_HARDDISK_VOL: type = DRIVE_FIXED; break;
+    case DEVICE_FLOPPY:       type = DRIVE_REMOVABLE; break;
+    case DEVICE_CDROM:        type = DRIVE_CDROM; break;
+    case DEVICE_DVD:          type = DRIVE_CDROM; break;
+    case DEVICE_NETWORK:      type = DRIVE_REMOTE; break;
+    case DEVICE_RAMDISK:      type = DRIVE_RAMDISK; break;
+    }
+
+    size = sizeof(*output);
+    if (label) size += (strlenW(label) + 1) * sizeof(WCHAR);
+    if (device) size += strlen(device) + 1;
+    if (mount_point) size += strlen(mount_point) + 1;
+
+    input = NULL;
+    output = buff;
+    output->size = size;
+    output->letter = letter;
+    output->type = type;
+    output->fs_type = fs_type;
+    output->serial = serial;
+    output->mount_point_offset = 0;
+    output->device_offset = 0;
+    output->label_offset = 0;
+
+    ptr = (char *)(output + 1);
+
+    if (label && ptr + (strlenW(label) + 1) * sizeof(WCHAR) - (char *)output <= outsize)
+    {
+        output->label_offset = ptr - (char *)output;
+        strcpyW( (WCHAR *)ptr, label );
+        ptr += (strlenW(label) + 1) * sizeof(WCHAR);
+    }
+    if (mount_point && ptr + strlen(mount_point) + 1 - (char *)output <= outsize)
+    {
+        output->mount_point_offset = ptr - (char *)output;
+        strcpy( ptr, mount_point );
+        ptr += strlen(ptr) + 1;
+    }
+    if (device && ptr + strlen(device) + 1 - (char *)output <= outsize)
+    {
+        output->device_offset = ptr - (char *)output;
+        strcpy( ptr, device );
+        ptr += strlen(ptr) + 1;
+    }
+
+    TRACE( "returning %c: dev %s mount %s type %u\n",
+           letter, debugstr_a(device), debugstr_a(mount_point), type );
+
+    iosb->Information = ptr - (char *)output;
+    if (size > outsize) status = STATUS_BUFFER_OVERFLOW;
+
+    RtlFreeHeap( GetProcessHeap(), 0, device );
+    RtlFreeHeap( GetProcessHeap(), 0, mount_point );
+    RtlFreeHeap( GetProcessHeap(), 0, label );
+    return status;
+}
+
 static NTSTATUS query_property( struct disk_device *device, IRP *irp )
 {
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
diff --git a/dlls/mountmgr.sys/mountmgr.c b/dlls/mountmgr.sys/mountmgr.c
index 9e3dcadb8d7..61d51d8e61d 100644
--- a/dlls/mountmgr.sys/mountmgr.c
+++ b/dlls/mountmgr.sys/mountmgr.c
@@ -285,97 +285,6 @@ static NTSTATUS define_unix_drive( const void *in_buff, SIZE_T insize )
     }
 }
 
-/* implementation of IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE */
-static NTSTATUS query_unix_drive( void *buff, SIZE_T insize,
-                                  SIZE_T outsize, IO_STATUS_BLOCK *iosb )
-{
-    const struct mountmgr_unix_drive *input = buff;
-    struct mountmgr_unix_drive *output = NULL;
-    char *device, *mount_point;
-    int letter = tolowerW( input->letter );
-    NTSTATUS status;
-    DWORD size, type = DEVICE_UNKNOWN, serial;
-    enum mountmgr_fs_type fs_type;
-    enum device_type device_type;
-    char *ptr;
-    WCHAR *label;
-
-    if (!letter)
-    {
-        if ((status = query_unix_device( input->unix_dev, &device_type, &fs_type,
-                                         &serial, &device, &mount_point, &label )))
-            return status;
-    }
-    else
-    {
-        if (letter < 'a' || letter > 'z') return STATUS_INVALID_PARAMETER;
-
-        if ((status = query_dos_device( letter - 'a', &device_type, &fs_type, &serial, &device,
-                                        &mount_point, &label )))
-            return status;
-    }
-
-    switch (device_type)
-    {
-    case DEVICE_UNKNOWN:      type = DRIVE_UNKNOWN; break;
-    case DEVICE_HARDDISK:     type = DRIVE_REMOVABLE; break;
-    case DEVICE_HARDDISK_VOL: type = DRIVE_FIXED; break;
-    case DEVICE_FLOPPY:       type = DRIVE_REMOVABLE; break;
-    case DEVICE_CDROM:        type = DRIVE_CDROM; break;
-    case DEVICE_DVD:          type = DRIVE_CDROM; break;
-    case DEVICE_NETWORK:      type = DRIVE_REMOTE; break;
-    case DEVICE_RAMDISK:      type = DRIVE_RAMDISK; break;
-    }
-
-    size = sizeof(*output);
-    if (label) size += (strlenW(label) + 1) * sizeof(WCHAR);
-    if (device) size += strlen(device) + 1;
-    if (mount_point) size += strlen(mount_point) + 1;
-
-    input = NULL;
-    output = buff;
-    output->size = size;
-    output->letter = letter;
-    output->type = type;
-    output->fs_type = fs_type;
-    output->serial = serial;
-    output->mount_point_offset = 0;
-    output->device_offset = 0;
-    output->label_offset = 0;
-
-    ptr = (char *)(output + 1);
-
-    if (label && ptr + (strlenW(label) + 1) * sizeof(WCHAR) - (char *)output <= outsize)
-    {
-        output->label_offset = ptr - (char *)output;
-        strcpyW( (WCHAR *)ptr, label );
-        ptr += (strlenW(label) + 1) * sizeof(WCHAR);
-    }
-    if (mount_point && ptr + strlen(mount_point) + 1 - (char *)output <= outsize)
-    {
-        output->mount_point_offset = ptr - (char *)output;
-        strcpy( ptr, mount_point );
-        ptr += strlen(ptr) + 1;
-    }
-    if (device && ptr + strlen(device) + 1 - (char *)output <= outsize)
-    {
-        output->device_offset = ptr - (char *)output;
-        strcpy( ptr, device );
-        ptr += strlen(ptr) + 1;
-    }
-
-    TRACE( "returning %c: dev %s mount %s type %u\n",
-           letter, debugstr_a(device), debugstr_a(mount_point), type );
-
-    iosb->Information = ptr - (char *)output;
-    if (size > outsize) status = STATUS_BUFFER_OVERFLOW;
-
-    RtlFreeHeap( GetProcessHeap(), 0, device );
-    RtlFreeHeap( GetProcessHeap(), 0, mount_point );
-    RtlFreeHeap( GetProcessHeap(), 0, label );
-    return status;
-}
-
 /* implementation of IOCTL_MOUNTMGR_QUERY_DHCP_REQUEST_PARAMS */
 static NTSTATUS query_dhcp_request_params( void *buff, SIZE_T insize,
                                            SIZE_T outsize, IO_STATUS_BLOCK *iosb )
diff --git a/dlls/mountmgr.sys/mountmgr.h b/dlls/mountmgr.sys/mountmgr.h
index 3e4554c4768..13be732e337 100644
--- a/dlls/mountmgr.sys/mountmgr.h
+++ b/dlls/mountmgr.sys/mountmgr.h
@@ -59,11 +59,8 @@ extern NTSTATUS add_dos_device( int letter, const char *udi, const char *device,
                                 const char *mount_point, enum device_type type, const GUID *guid,
                                 UNICODE_STRING *devname ) DECLSPEC_HIDDEN;
 extern NTSTATUS remove_dos_device( int letter, const char *udi ) DECLSPEC_HIDDEN;
-extern NTSTATUS query_dos_device( int letter, enum device_type *type, enum mountmgr_fs_type *fs_type, DWORD *serial,
-                                  char **device, char **mount_point, WCHAR **label ) DECLSPEC_HIDDEN;
-extern NTSTATUS query_unix_device( ULONGLONG unix_dev, enum device_type *type,
-                                   DWORD *serial, enum mountmgr_fs_type *fs_type, char **device,
-                                   char **mount_point, WCHAR **label ) DECLSPEC_HIDDEN;
+extern NTSTATUS query_unix_drive( void *buff, SIZE_T insize, SIZE_T outsize,
+                                  IO_STATUS_BLOCK *iosb ) DECLSPEC_HIDDEN;
 extern NTSTATUS WINAPI harddisk_driver_entry( DRIVER_OBJECT *driver, UNICODE_STRING *path ) DECLSPEC_HIDDEN;
 extern NTSTATUS WINAPI serial_driver_entry( DRIVER_OBJECT *driver, UNICODE_STRING *path ) DECLSPEC_HIDDEN;
 extern NTSTATUS WINAPI parallel_driver_entry( DRIVER_OBJECT *driver, UNICODE_STRING *path ) DECLSPEC_HIDDEN;

-- 
2.17.1

