From c82160f1c6e7aa9fc0349d5d0e7412dcb6d5b40c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 22 Jan 2020 11:27:24 +0100
Subject: [PATCH 37/37] winex11.drv: Implement SetActiveWindow specialization.

---
 dlls/winex11.drv/event.c  | 80 +++++++++++++++++++++++++++++--
 dlls/winex11.drv/window.c |  2 +-
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 77 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 1fc6f8c8785..7facad69ede 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -535,6 +535,8 @@ DWORD EVENT_x11_time_to_win32_time(Time time)
     if (time == CurrentTime)
         return now;
 
+    if (last_user_time == 0) update_user_time( time );
+
     /* Sometimes the first events timestamps are completely off. This
      * is happening for instance on TestBot runs. */
     if (time_to_tick_diff && (int)time_to_tick_diff < (int)diff && diff - time_to_tick_diff > 10000)
@@ -1523,6 +1525,86 @@ void wait_for_withdrawn_state( HWND hwnd, BOOL set )
 }
 
 
+/***********************************************************************
+ *      x11drv_activate_window
+ */
+static void x11drv_activate_window( HWND hwnd, struct x11drv_win_data *data )
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+    struct x11drv_win_data *active_data;
+    HWND active_hwnd = GetActiveWindow();
+    Window active_window = None;
+    XEvent event;
+
+    if (thread_data->active_window == hwnd)
+    {
+        TRACE("ignoring activation for already active window %p\n", hwnd);
+        return;
+    }
+
+    if (!data || !data->managed) return;
+
+    if (!data->mapped)
+    {
+        FIXME( "cannot activate hidden window %p/%lx, hacking focus\n", hwnd, data->whole_window );
+        XSetInputFocus( gdi_display, None, RevertToPointerRoot, last_user_time );
+        XFlush( gdi_display );
+        return;
+    }
+
+    if (!thread_data->ewmh.has__net_active_window)
+    {
+        FIXME( "no support for _NET_ACTIVE_WINDOW, cannot activate window %p/%lx\n", hwnd, data->whole_window );
+        return;
+    }
+
+    if ((active_data = get_win_data( active_hwnd )))
+        active_window = active_data->whole_window;
+    release_win_data( active_data );
+
+    TRACE("Sending _NET_ACTIVE_WINDOW to %p/%lx, current active %p/%lx\n",
+        hwnd, data->whole_window, active_hwnd, active_window );
+
+    event.xclient.type = ClientMessage;
+    event.xclient.window = data->whole_window;
+    event.xclient.message_type = x11drv_atom(_NET_ACTIVE_WINDOW);
+    event.xclient.serial = 0;
+    event.xclient.display = gdi_display;
+    event.xclient.send_event = True;
+    event.xclient.format = 32;
+
+    event.xclient.data.l[0] = 1; /* source: application */
+    event.xclient.data.l[1] = last_user_time;
+    event.xclient.data.l[2] = active_window;
+    event.xclient.data.l[3] = 0;
+    event.xclient.data.l[4] = 0;
+    XSendEvent( gdi_display, DefaultRootWindow( gdi_display ), False,
+                SubstructureRedirectMask | SubstructureNotifyMask, &event );
+    XFlush( gdi_display );
+}
+
+
+/***********************************************************************
+ *      SetActiveWindow  (X11DRV.@)
+ */
+void CDECL X11DRV_SetActiveWindow( HWND hwnd )
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+    struct x11drv_win_data *data;
+
+    if (thread_data->current_event) return;
+    if (is_virtual_desktop()) return;
+    if (!hwnd || hwnd == GetDesktopWindow()) return;
+    if (!(data = get_win_data( hwnd ))) return;
+
+    TRACE("%p/%lx\n", hwnd, data->whole_window);
+
+    x11drv_activate_window( hwnd, data );
+
+    release_win_data( data );
+}
+
+
 /*****************************************************************
  *		SetFocus   (X11DRV.@)
  *
@@ -1553,7 +1628,6 @@ void CDECL X11DRV_SetFocus( HWND hwnd )
  */
 BOOL CDECL X11DRV_SetForegroundWindow( HWND hwnd )
 {
-    struct x11drv_win_data *data;
     BOOL foreign;
     if (is_virtual_desktop()) return TRUE;
     if (!hwnd || hwnd == GetDesktopWindow()) return TRUE;
@@ -1566,10 +1640,6 @@ BOOL CDECL X11DRV_SetForegroundWindow( HWND hwnd )
         return FALSE;
     }
 
-    if ((data = get_win_data( hwnd )) && data->managed && !data->mapped)
-        FIXME( "cannot set hidden window %p/%lx foreground\n", hwnd, data->whole_window );
-    if (data) release_win_data( data );
-
     return TRUE;
 }
 
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index dd1041508ad..88e0e595589 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -86,7 +86,7 @@ BOOL clipping_cursor = FALSE;
 XContext win_data_context = 0;
 
 /* time of last user event and window where it's stored */
-static Time last_user_time;
+Time last_user_time;
 static Window user_time_window;
 
 static const char foreign_window_prop[] = "__wine_x11_foreign_window";
@@ -2323,55 +2323,6 @@ BOOL CDECL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
     return ret;
 }
 
-
-/***********************************************************************
- *		SetActiveWindow  (X11DRV.@)
- */
-void CDECL X11DRV_SetActiveWindow( HWND hwnd )
-{
-    struct x11drv_thread_data *thread_data = x11drv_init_thread_data();
-    struct x11drv_win_data *data;
-
-    TRACE("%p\n", hwnd);
-
-    if (thread_data->active_window == hwnd)
-    {
-        TRACE("ignoring activation for already active window %p\n", hwnd);
-        return;
-    }
-
-    if (!(data = get_win_data( hwnd ))) return;
-
-    if (data->mapped && data->managed)
-    {
-        XEvent xev;
-        struct x11drv_win_data *active = get_win_data( thread_data->active_window );
-        DWORD timestamp = GetMessageTime() - EVENT_x11_time_to_win32_time( 0 );
-
-        TRACE("setting _NET_ACTIVE_WINDOW to %p/%lx, current active %p/%lx\n",
-            data->hwnd, data->whole_window, active ? active->hwnd : NULL, active ? active->whole_window : 0 );
-
-        xev.xclient.type = ClientMessage;
-        xev.xclient.window = data->whole_window;
-        xev.xclient.message_type = x11drv_atom(_NET_ACTIVE_WINDOW);
-        xev.xclient.serial = 0;
-        xev.xclient.display = data->display;
-        xev.xclient.send_event = True;
-        xev.xclient.format = 32;
-
-        xev.xclient.data.l[0] = 1; /* source: application */
-        xev.xclient.data.l[1] = timestamp;
-        xev.xclient.data.l[2] = active ? active->whole_window : 0;
-        xev.xclient.data.l[3] = 0;
-        xev.xclient.data.l[4] = 0;
-        XSendEvent( data->display, root_window, False, SubstructureRedirectMask | SubstructureNotifyMask, &xev );
-
-        if (active) release_win_data( active );
-    }
-
-    release_win_data( data );
-}
-
 /***********************************************************************
  *		SetCapture  (X11DRV.@)
  */
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 149e9799c22..41021dfe642 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -429,6 +429,7 @@ extern int xrender_error_base DECLSPEC_HIDDEN;
 extern HMODULE x11drv_module DECLSPEC_HIDDEN;
 extern char *process_name DECLSPEC_HIDDEN;
 extern Display *clipboard_display DECLSPEC_HIDDEN;
+extern Time last_user_time DECLSPEC_HIDDEN;
 extern HANDLE steam_overlay_event DECLSPEC_HIDDEN;
 
 /* atoms */
-- 
2.31.0

