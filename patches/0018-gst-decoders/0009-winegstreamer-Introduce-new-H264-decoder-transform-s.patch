From 2c766bb36feffaa8fcf31aea63fb4397745767ef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 16 Feb 2022 16:12:15 +0100
Subject: [PATCH 09/35] winegstreamer: Introduce new H264 decoder transform
 stub.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/h264_decoder.c            | 277 +++++++++++++++++++
 dlls/winegstreamer/mfplat.c                  |  29 +-
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 5 files changed, 313 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winegstreamer/h264_decoder.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -8,6 +8,7 @@ EXTRALIBS = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
 	audioconvert.c \
+	h264_decoder.c \
 	main.c \
 	media_source.c \
 	mfplat.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -123,6 +123,7 @@ void mf_destroy_wg_sample(struct wg_sample *wg_sample);
 
 HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj);
 
+HRESULT h264_decoder_create(REFIID riid, void **ret);
 HRESULT audio_converter_create(REFIID riid, void **ret);
 
 struct wm_stream
diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
new file mode 100644
index 00000000000..11111111111
--- /dev/null
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -0,0 +1,277 @@
+/* H264 Decoder Transform
+ *
+ * Copyright 2022 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct h264_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+};
+
+static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct h264_decoder, IMFTransform_iface);
+}
+
+static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+            IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI transform_AddRef(IMFTransform *iface)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %lu.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI transform_Release(IMFTransform *iface)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);
+
+    if (!refcount)
+        free(decoder);
+
+    return refcount;
+}
+
+static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_size,
+        DWORD *inputs, DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %lu, inputs %p, output_size %lu, outputs %p stub!\n", iface,
+            input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %#lx, info %p stub!\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %#lx, info %p stub!\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %#lx stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %lu, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, index %#lx, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id,
+        DWORD index, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, index %#lx, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("iface %p, id %#lx, type %p, flags %#lx stub!\n", iface, id, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("iface %p, id %#lx, type %p, flags %#lx stub!\n", iface, id, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %I64d, upper %I64d stub!\n", iface, lower, upper);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %#lx, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %Ix stub!\n", iface, message, param);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("iface %p, id %#lx, sample %p, flags %#lx stub!\n", iface, id, sample, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("iface %p, flags %#lx, count %lu, samples %p, status %p stub!\n", iface, flags, count, samples, status);
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl transform_vtbl =
+{
+    transform_QueryInterface,
+    transform_AddRef,
+    transform_Release,
+    transform_GetStreamLimits,
+    transform_GetStreamCount,
+    transform_GetStreamIDs,
+    transform_GetInputStreamInfo,
+    transform_GetOutputStreamInfo,
+    transform_GetAttributes,
+    transform_GetInputStreamAttributes,
+    transform_GetOutputStreamAttributes,
+    transform_DeleteInputStream,
+    transform_AddInputStreams,
+    transform_GetInputAvailableType,
+    transform_GetOutputAvailableType,
+    transform_SetInputType,
+    transform_SetOutputType,
+    transform_GetInputCurrentType,
+    transform_GetOutputCurrentType,
+    transform_GetInputStatus,
+    transform_GetOutputStatus,
+    transform_SetOutputBounds,
+    transform_ProcessEvent,
+    transform_ProcessMessage,
+    transform_ProcessInput,
+    transform_ProcessOutput,
+};
+
+HRESULT h264_decoder_create(REFIID riid, void **ret)
+{
+    struct h264_decoder *decoder;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &transform_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -410,6 +410,7 @@ class_objects[] =
     { &CLSID_VideoProcessorMFT, &video_processor_create },
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
+    { &CLSID_MSH264DecoderMFT, &h264_decoder_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
@@ -459,6 +460,21 @@ static const GUID *const wma_decoder_output_types[] =
     &MFAudioFormat_Float,
 };
 
+static WCHAR h264_decoderW[] = L"Microsoft H264 Video Decoder MFT";
+static const GUID *h264_decoder_input_types[] =
+{
+    &MFVideoFormat_H264,
+    &MFVideoFormat_H264_ES,
+};
+static const GUID *h264_decoder_output_types[] =
+{
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_YV12,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_YUY2,
+};
+
 static const struct mft
 {
     const GUID *clsid;
@@ -495,13 +511,24 @@ mfts[] =
         ARRAY_SIZE(wma_decoder_output_types),
         wma_decoder_output_types,
     },
+    {
+        &CLSID_MSH264DecoderMFT,
+        &MFT_CATEGORY_VIDEO_DECODER,
+        h264_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Video,
+        ARRAY_SIZE(h264_decoder_input_types),
+        h264_decoder_input_types,
+        ARRAY_SIZE(h264_decoder_output_types),
+        h264_decoder_output_types,
+    },
 };
 
 HRESULT mfplat_DllRegisterServer(void)
 {
     unsigned int i, j;
     HRESULT hr;
-    MFT_REGISTER_TYPE_INFO input_types[4], output_types[2];
+    MFT_REGISTER_TYPE_INFO input_types[4], output_types[5];
 
     for (i = 0; i < ARRAY_SIZE(mfts); i++)
     {
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -73,3 +73,9 @@ coclass WINEAudioConverter { }
     uuid(2eeb4adf-4578-4d10-bca7-bb955f56320a)
 ]
 coclass CWMADecMediaObject {};
+
+[
+    threading(both),
+    uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
+]
+coclass CMSH264DecoderMFT {}

