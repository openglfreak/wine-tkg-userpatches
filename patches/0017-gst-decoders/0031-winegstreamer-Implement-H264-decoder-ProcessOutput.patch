From cc6486bc063f03d0d7ace615b5ecbabcafdb48cc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 18 Jan 2022 13:33:36 +0100
Subject: [PATCH 31/36] winegstreamer: Implement H264 decoder ProcessOutput.

For: Call of Duty III, Mortal Kombat 11, Shadow Warrior 2,
Yakuza 4 Remastered, Hard Reset Redux.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 48 +++++++++++++++++++++++++++++--
 1 file changed, 46 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index bf69a21f95d..f930d6160d3 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -537,8 +537,52 @@ done:
 static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("iface %p, flags %#x, count %u, samples %p, status %p stub!\n", iface, flags, count, samples, status);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+        hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    if (FAILED(hr))
+        IMFMediaBuffer_SetCurrentLength(media_buffer, 0);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
 }
 
 static const IMFTransformVtbl h264_decoder_vtbl =
-- 
2.35.1

