From 7eb3b23379ca170089c9f6765ae2cf630f6f3792 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 Jan 2022 14:31:44 +0100
Subject: [PATCH 18/36] winegstreamer: Implement WMA decoder ProcessOutput.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
---
 dlls/winegstreamer/gst_private.h  |  1 +
 dlls/winegstreamer/main.c         | 11 +++++
 dlls/winegstreamer/unix_private.h |  1 +
 dlls/winegstreamer/unixlib.h      | 19 ++++++++
 dlls/winegstreamer/wg_parser.c    |  1 +
 dlls/winegstreamer/wg_transform.c | 76 ++++++++++++++++++++++++++++++-
 dlls/winegstreamer/wma_decoder.c  | 56 ++++++++++++++++++++++-
 7 files changed, 162 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -100,6 +100,7 @@ struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_f
                 const struct wg_format *output_format) DECLSPEC_HIDDEN;
 void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;
 HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size) DECLSPEC_HIDDEN;
+HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample) DECLSPEC_HIDDEN;
 
 unsigned int wg_format_get_max_size(const struct wg_format *format);
 
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -285,6 +285,17 @@ HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data,
     return __wine_unix_call(unix_handle, unix_wg_transform_push_data, &params);
 }
 
+HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample)
+{
+    struct wg_transform_read_data_params params =
+    {
+        .transform = transform,
+        .sample = sample,
+    };
+
+    return __wine_unix_call(unix_handle, unix_wg_transform_read_data, &params);
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     if (reason == DLL_PROCESS_ATTACH)
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -30,5 +30,6 @@ extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDE
 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_push_data(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_read_data(void *args) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -256,6 +256,24 @@ struct wg_transform_push_data_params
     UINT32 size;
 };
 
+enum wg_sample_flags
+{
+    WG_SAMPLE_FLAG_INCOMPLETE = 1,
+};
+
+struct wg_sample
+{
+    UINT32 flags;
+    BYTE *data;
+    UINT32 size;
+};
+
+struct wg_transform_read_data_params
+{
+    struct wg_transform *transform;
+    struct wg_sample *sample;
+};
+
 enum unix_funcs
 {
     unix_wg_parser_create,
@@ -289,6 +307,7 @@ enum unix_funcs
     unix_wg_transform_destroy,
 
     unix_wg_transform_push_data,
+    unix_wg_transform_read_data,
 };
 
 #endif /* __WINE_WINEGSTREAMER_UNIXLIB_H */
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -2058,4 +2058,5 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_transform_destroy),
 
     X(wg_transform_push_data),
+    X(wg_transform_read_data),
 };
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -38,14 +38,24 @@
 
 #include "unix_private.h"
 
+#include "wine/list.h"
+
 GST_DEBUG_CATEGORY_EXTERN(wine);
 #define GST_CAT_DEFAULT wine
 
+struct wg_transform_sample
+{
+    struct list entry;
+    GstSample *sample;
+};
+
 struct wg_transform
 {
     GstElement *container;
     GstPad *my_src, *my_sink;
     GstPad *their_sink, *their_src;
+    pthread_mutex_t mutex;
+    struct list samples;
 };
 
 static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
@@ -99,17 +109,29 @@ static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format
 static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
 {
     struct wg_transform *transform = gst_pad_get_element_private(pad);
+    struct wg_transform_sample *sample;
 
     GST_INFO("transform %p, buffer %p.", transform, buffer);
 
-    gst_buffer_unref(buffer);
+    if (!(sample = malloc(sizeof(*sample))))
+        GST_ERROR("Failed to allocate transform sample entry");
+    else
+    {
+        pthread_mutex_lock(&transform->mutex);
+        if (!(sample->sample = gst_sample_new(buffer, NULL, NULL, NULL)))
+            GST_ERROR("Failed to allocate transform sample");
+        list_add_tail(&transform->samples, &sample->entry);
+        pthread_mutex_unlock(&transform->mutex);
+    }
 
+    gst_buffer_unref(buffer);
     return GST_FLOW_OK;
 }
 
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
+    struct wg_transform_sample *sample, *next;
 
     if (transform->container)
         gst_element_set_state(transform->container, GST_STATE_NULL);
@@ -132,6 +154,13 @@ NTSTATUS wg_transform_destroy(void *args)
     if (transform->my_src)
         g_object_unref(transform->my_src);
 
+    LIST_FOR_EACH_ENTRY_SAFE(sample, next, &transform->samples, struct wg_transform_sample, entry)
+    {
+        gst_sample_unref(sample->sample);
+        list_remove(&sample->entry);
+        free(sample);
+    }
+
     free(transform);
     return S_OK;
 }
@@ -224,6 +253,8 @@ NTSTATUS wg_transform_create(void *args)
     if (!(transform = calloc(1, sizeof(*transform))))
         return E_OUTOFMEMORY;
 
+    list_init(&transform->samples);
+
     src_caps = wg_encoded_format_to_caps(&input_format);
     assert(src_caps);
     sink_caps = wg_format_to_caps(&output_format);
@@ -362,3 +393,46 @@ NTSTATUS wg_transform_push_data(void *args)
     GST_INFO("Pushed %u bytes", params->size);
     return S_OK;
 }
+
+NTSTATUS wg_transform_read_data(void *args)
+{
+    struct wg_transform_read_data_params *params = args;
+    struct wg_transform *transform = params->transform;
+    struct wg_sample *read_sample = params->sample;
+    struct wg_transform_sample *transform_sample;
+    GstBuffer *buffer;
+    struct list *head;
+    GstMapInfo info;
+
+    pthread_mutex_lock(&transform->mutex);
+    if (!(head = list_head(&transform->samples)))
+    {
+        pthread_mutex_unlock(&transform->mutex);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    transform_sample = LIST_ENTRY(head, struct wg_transform_sample, entry);
+    buffer = gst_sample_get_buffer(transform_sample->sample);
+
+    gst_buffer_map(buffer, &info, GST_MAP_READ);
+    if (read_sample->size > info.size)
+        read_sample->size = info.size;
+    memcpy(read_sample->data, info.data, read_sample->size);
+    gst_buffer_unmap(buffer, &info);
+
+    if (info.size > read_sample->size)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_INCOMPLETE;
+        gst_buffer_resize(buffer, read_sample->size, -1);
+    }
+    else
+    {
+        gst_sample_unref(transform_sample->sample);
+        list_remove(&transform_sample->entry);
+        free(transform_sample);
+    }
+    pthread_mutex_unlock(&transform->mutex);
+
+    GST_INFO("Read %u bytes, flags %#x", read_sample->size, read_sample->flags);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -569,8 +569,60 @@ done:
 static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("iface %p, flags %#lx, count %lu, samples %p, status %p stub!\n", iface, flags, count, samples, status);
-    return E_NOTIMPL;
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
 }
 
 static const IMFTransformVtbl transform_vtbl =
-- 
2.35.1

