From a3583720a4b3102dafa5e2dc90e63774ae5bbfdd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 6 Jun 2022 19:19:50 +0200
Subject: [PATCH 03/30] winegstreamer: Use wg_sample to provide data in
 wg_parser_push_data.

---
 dlls/winegstreamer/gst_private.h   |  3 +-
 dlls/winegstreamer/main.c          |  7 ++---
 dlls/winegstreamer/media_source.c  | 18 +++++------
 dlls/winegstreamer/quartz_parser.c | 18 +++++------
 dlls/winegstreamer/unixlib.h       |  3 +-
 dlls/winegstreamer/wg_parser.c     | 50 +++++++++++++-----------------
 dlls/winegstreamer/wg_sample.c     | 36 +++++++++++++++++++++
 dlls/winegstreamer/wm_reader.c     | 20 +++++-------
 8 files changed, 85 insertions(+), 70 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -77,7 +77,7 @@ HRESULT wg_parser_connect(struct wg_parser *parser, uint64_t file_size);
 void wg_parser_disconnect(struct wg_parser *parser);
 
 bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset, uint32_t *size);
-void wg_parser_push_data(struct wg_parser *parser, const void *data, uint32_t size);
+void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample);
 
 uint32_t wg_parser_get_stream_count(struct wg_parser *parser);
 struct wg_parser_stream *wg_parser_get_stream(struct wg_parser *parser, uint32_t index);
@@ -126,6 +126,7 @@ extern HRESULT mfplat_DllRegisterServer(void);
 IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format);
 void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format);
 
+HRESULT wg_sample_create_raw(UINT32 size, struct wg_sample **out);
 HRESULT wg_sample_create_mf(IMFSample *sample, struct wg_sample **out);
 HRESULT wg_sample_create_quartz(IMediaSample *sample, struct wg_sample **out);
 void wg_sample_release(struct wg_sample *wg_sample);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -123,16 +123,15 @@ bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset,
     return true;
 }
 
-void wg_parser_push_data(struct wg_parser *parser, const void *data, uint32_t size)
+void wg_parser_push_data(struct wg_parser *parser, struct wg_sample *sample)
 {
     struct wg_parser_push_data_params params =
     {
         .parser = parser,
-        .data = data,
-        .size = size,
+        .sample = sample,
     };
 
-    TRACE("parser %p, data %p, size %u.\n", parser, data, size);
+    TRACE("parser %p, sample %p.\n", parser, sample);
 
     __wine_unix_call(unix_handle, unix_wg_parser_push_data, &params);
 }
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -596,13 +596,9 @@ static DWORD CALLBACK read_thread(void *arg)
 {
     struct media_source *source = arg;
     IMFByteStream *byte_stream = source->byte_stream;
-    size_t buffer_size = 4096;
-    void *buffer, *data;
+    struct wg_sample *wg_sample;
     uint64_t file_size;
 
-    if (!(buffer = malloc(buffer_size)))
-        return 0;
-
     IMFByteStream_GetLength(byte_stream, &file_size);
 
     TRACE("Starting read thread for media source %p.\n", source);
@@ -622,9 +618,8 @@ static DWORD CALLBACK read_thread(void *arg)
         else if (offset + size >= file_size)
             size = file_size - offset;
 
-        if (!array_reserve(&buffer, &buffer_size, size, 1))
+        if (FAILED(wg_sample_create_raw(size, &wg_sample)))
             break;
-        data = buffer;
 
         /* Some IMFByteStreams (including the standard file-based stream) return
          * an error when reading past the file size. */
@@ -632,12 +627,12 @@ static DWORD CALLBACK read_thread(void *arg)
         if (!size)
             hr = S_OK;
         else if (SUCCEEDED(hr = IMFByteStream_SetCurrentPosition(byte_stream, offset)))
-            hr = IMFByteStream_Read(byte_stream, data, size, &ret_size);
+            hr = IMFByteStream_Read(byte_stream, wg_sample->data, size, &ret_size);
 
         if (FAILED(hr))
         {
             ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
-            data = NULL;
+            wg_sample->data = NULL;
         }
         else if (ret_size != size)
         {
@@ -645,10 +640,11 @@ static DWORD CALLBACK read_thread(void *arg)
             size = ret_size;
         }
 
-        wg_parser_push_data(source->wg_parser, data, size);
+        wg_sample->size = size;
+        wg_parser_push_data(source->wg_parser, wg_sample);
+        wg_sample_release(wg_sample);
     }
 
-    free(buffer);
     TRACE("Media source is shutting down; exiting.\n");
     return 0;
 }
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -868,12 +868,8 @@ static DWORD CALLBACK stream_thread(void *arg)
 static DWORD CALLBACK read_thread(void *arg)
 {
     struct parser *filter = arg;
+    struct wg_sample *wg_sample;
     LONGLONG file_size, unused;
-    size_t buffer_size = 4096;
-    void *buffer, *data;
-
-    if (!(buffer = malloc(buffer_size)))
-        return 0;
 
     IAsyncReader_Length(filter->reader, &file_size, &unused);
 
@@ -893,21 +889,21 @@ static DWORD CALLBACK read_thread(void *arg)
         else if (offset + size >= file_size)
             size = file_size - offset;
 
-        if (!array_reserve(&buffer, &buffer_size, size, 1))
+        if (FAILED(wg_sample_create_raw(size, &wg_sample)))
             break;
-        data = buffer;
 
-        hr = IAsyncReader_SyncRead(filter->reader, offset, size, data);
+        hr = IAsyncReader_SyncRead(filter->reader, offset, size, wg_sample->data);
         if (FAILED(hr))
         {
             ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
-            data = NULL;
+            wg_sample->data = NULL;
         }
 
-        wg_parser_push_data(filter->wg_parser, data, size);
+        wg_sample->size = size;
+        wg_parser_push_data(filter->wg_parser, wg_sample);
+        wg_sample_release(wg_sample);
     }
 
-    free(buffer);
     TRACE("Streaming stopped; exiting.\n");
     return 0;
 }
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -175,8 +175,7 @@ struct wg_parser_get_next_read_offset_params
 struct wg_parser_push_data_params
 {
     struct wg_parser *parser;
-    const void *data;
-    UINT32 size;
+    struct wg_sample *sample;
 };
 
 struct wg_parser_get_stream_count_params
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -153,36 +153,29 @@ static NTSTATUS wg_parser_push_data(void *args)
 {
     const struct wg_parser_push_data_params *params = args;
     struct wg_parser *parser = params->parser;
-    const void *data = params->data;
-    uint32_t size = params->size;
-
-    pthread_mutex_lock(&parser->mutex);
-
-    if (data)
+    struct wg_sample *sample = params->sample;
+    GstFlowReturn result = GST_FLOW_OK;
+    GstBuffer *buffer = NULL;
+
+    if (!sample || !sample->data)
+        result = GST_FLOW_ERROR;
+    else if (!sample->size)
+        result = GST_FLOW_EOS;
+    else
     {
-        if (size)
-        {
-            GstMapInfo map_info;
-
-            /* Note that we don't allocate the buffer until we have a size.
-             * midiparse passes a NULL buffer and a size of UINT_MAX, in an
-             * apparent attempt to read the whole input stream at once. */
-            if (!parser->read_request.buffer)
-                parser->read_request.buffer = gst_buffer_new_and_alloc(size);
-            gst_buffer_map(parser->read_request.buffer, &map_info, GST_MAP_WRITE);
-            memcpy(map_info.data, data, size);
-            gst_buffer_unmap(parser->read_request.buffer, &map_info);
-            parser->read_request.ret = GST_FLOW_OK;
-        }
-        else
+        if (!(buffer = gst_buffer_new_and_alloc(sample->size)))
         {
-            parser->read_request.ret = GST_FLOW_EOS;
+            GST_ERROR("Failed to allocate input buffer");
+            return STATUS_NO_MEMORY;
         }
+        gst_buffer_fill(buffer, 0, sample->data, sample->size);
+        GST_INFO("Copied %u bytes from sample %p to buffer %p", sample->size, sample, buffer);
     }
-    else
-    {
-        parser->read_request.ret = GST_FLOW_ERROR;
-    }
+
+    pthread_mutex_lock(&parser->mutex);
+
+    parser->read_request.buffer = buffer;
+    parser->read_request.ret = result;
     parser->read_request.done = true;
     parser->read_request.size = 0;
 
@@ -886,8 +879,7 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
         /* asfreader occasionally asks for zero bytes. gst_buffer_map() will
          * return NULL in this case. Avoid confusing the read thread by asking
          * it for zero bytes. */
-        if (!*buffer)
-            *buffer = gst_buffer_new_and_alloc(0);
+        *buffer = gst_buffer_new_and_alloc(0);
         gst_buffer_set_size(*buffer, 0);
         GST_LOG("Returning empty buffer.");
         return GST_FLOW_OK;
@@ -896,7 +888,6 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
     pthread_mutex_lock(&parser->mutex);
 
     assert(!parser->read_request.size);
-    parser->read_request.buffer = *buffer;
     parser->read_request.offset = offset;
     parser->read_request.size = size;
     parser->read_request.done = false;
@@ -910,6 +901,7 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
         pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
 
     *buffer = parser->read_request.buffer;
+    parser->read_request.buffer = NULL;
     ret = parser->read_request.ret;
 
     pthread_mutex_unlock(&parser->mutex);
diff --git a/dlls/winegstreamer/wg_sample.c b/dlls/winegstreamer/wg_sample.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_sample.c
+++ b/dlls/winegstreamer/wg_sample.c
@@ -47,6 +47,11 @@ struct sample
 
     union
     {
+        struct
+        {
+            void *__pad[3];
+            BYTE buffer[];
+        } raw;
         struct
         {
             IMFSample *sample;
@@ -84,6 +89,37 @@ static const struct wg_sample_ops mf_sample_ops =
     mf_sample_destroy,
 };
 
+C_ASSERT(sizeof(struct sample) == offsetof(struct sample, u.raw.buffer[0]));
+
+static const struct wg_sample_ops raw_sample_ops;
+
+static void raw_sample_destroy(struct wg_sample *wg_sample)
+{
+    TRACE_(mfplat)("wg_sample %p.\n", wg_sample);
+}
+
+static const struct wg_sample_ops raw_sample_ops =
+{
+    raw_sample_destroy,
+};
+
+HRESULT wg_sample_create_raw(UINT32 size, struct wg_sample **out)
+{
+    struct sample *sample;
+
+    if (!(sample = calloc(1, offsetof(struct sample, u.raw.buffer[size]))))
+        return E_OUTOFMEMORY;
+
+    sample->wg_sample.data = sample->u.raw.buffer;
+    sample->wg_sample.size = 0;
+    sample->wg_sample.max_size = size;
+    sample->ops = &raw_sample_ops;
+
+    TRACE("Created wg_sample %p, size %u.\n", &sample->wg_sample, size);
+    *out = &sample->wg_sample;
+    return S_OK;
+}
+
 HRESULT wg_sample_create_mf(IMFSample *mf_sample, struct wg_sample **out)
 {
     DWORD current_length, max_length;
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -530,14 +530,10 @@ static DWORD CALLBACK read_thread(void *arg)
 {
     struct wm_reader *reader = arg;
     IStream *stream = reader->source_stream;
+    struct wg_sample *wg_sample;
     HANDLE file = reader->file;
-    size_t buffer_size = 4096;
-    void *buffer, *data;
     uint64_t file_size;
 
-    if (!(buffer = malloc(buffer_size)))
-        return 0;
-
     if (file)
     {
         LARGE_INTEGER size;
@@ -571,9 +567,8 @@ static DWORD CALLBACK read_thread(void *arg)
         else if (offset + size >= file_size)
             size = file_size - offset;
 
-        if (!array_reserve(&buffer, &buffer_size, size, 1))
+        if (FAILED(wg_sample_create_raw(size, &wg_sample)))
             break;
-        data = buffer;
 
         large_offset.QuadPart = offset;
         if (!size)
@@ -581,7 +576,7 @@ static DWORD CALLBACK read_thread(void *arg)
         else if (file)
         {
             if (!SetFilePointerEx(file, large_offset, NULL, FILE_BEGIN)
-                    || !ReadFile(file, data, size, &ret_size, NULL))
+                    || !ReadFile(file, wg_sample->data, size, &ret_size, NULL))
                 hr = HRESULT_FROM_WIN32(GetLastError());
             else
                 hr = S_OK;
@@ -589,13 +584,13 @@ static DWORD CALLBACK read_thread(void *arg)
         else
         {
             if (SUCCEEDED(hr = IStream_Seek(stream, large_offset, STREAM_SEEK_SET, NULL)))
-                hr = IStream_Read(stream, data, size, &ret_size);
+                hr = IStream_Read(stream, wg_sample->data, size, &ret_size);
         }
 
         if (FAILED(hr))
         {
             ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
-            data = NULL;
+            wg_sample->data = NULL;
         }
         else if (ret_size != size)
         {
@@ -603,10 +598,11 @@ static DWORD CALLBACK read_thread(void *arg)
             size = ret_size;
         }
 
-        wg_parser_push_data(reader->wg_parser, data, size);
+        wg_sample->size = size;
+        wg_parser_push_data(reader->wg_parser, wg_sample);
+        wg_sample_release(wg_sample);
     }
 
-    free(buffer);
     TRACE("Reader is shutting down; exiting.\n");
     return 0;
 }
-- 
2.37.1

