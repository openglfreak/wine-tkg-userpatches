From 1b00d3b4add0672ebcbd764917dd7277e95c8e22 Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshuiv7@gmail.com>
Date: Wed, 13 Apr 2022 02:09:06 +0100
Subject: [PATCH 2/3] winegstreamer: create media source from uri

Supported by gstreamer's uridecodebin.

Signed-off-by: Yuxuan Shui <yshuiv7@gmail.com>
---
 dlls/winegstreamer/gst_private.h   |  2 +-
 dlls/winegstreamer/main.c          |  3 +-
 dlls/winegstreamer/media_source.c  | 89 ++++++++++++++++++++++--------
 dlls/winegstreamer/quartz_parser.c |  2 +-
 dlls/winegstreamer/unixlib.h       |  2 +
 dlls/winegstreamer/wg_parser.c     | 69 ++++++++++++++++++++---
 dlls/winegstreamer/wm_reader.c     |  2 +-
 7 files changed, 133 insertions(+), 36 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -73,7 +73,7 @@ void wg_sample_queue_flush(struct wg_sample_queue *queue, bool all);
 wg_parser_t wg_parser_create(enum wg_parser_type type);
 void wg_parser_destroy(wg_parser_t parser);
 
-HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size);
+HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size, const WCHAR *uri);
 void wg_parser_disconnect(wg_parser_t parser);
 
 bool wg_parser_get_next_read_offset(wg_parser_t parser, uint64_t *offset, uint32_t *size);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -92,12 +92,13 @@ void wg_parser_destroy(wg_parser_t parser)
     WINE_UNIX_CALL(unix_wg_parser_destroy, &parser);
 }
 
-HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size)
+HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size, const WCHAR *uri)
 {
     struct wg_parser_connect_params params =
     {
         .parser = parser,
         .file_size = file_size,
+        .uri = uri,
     };
 
     TRACE("parser %#I64x, file_size %I64u.\n", parser, file_size);
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -1358,7 +1358,8 @@ static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
     {
         IMFMediaSource_Shutdown(iface);
         IMFMediaEventQueue_Release(source->event_queue);
-        IMFByteStream_Release(source->byte_stream);
+        if (source->byte_stream)
+            IMFByteStream_Release(source->byte_stream);
         wg_parser_destroy(source->wg_parser);
         source->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&source->cs);
@@ -1558,7 +1559,8 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
     CloseHandle(source->read_thread);
 
     IMFMediaEventQueue_Shutdown(source->event_queue);
-    IMFByteStream_Close(source->byte_stream);
+    if (source->byte_stream)
+        IMFByteStream_Close(source->byte_stream);
 
     while (source->stream_count--)
     {
@@ -1613,26 +1615,19 @@ static void media_source_init_descriptors(struct media_source *source)
     }
 }
 
-static HRESULT media_source_create(struct object_context *context, IMFMediaSource **out)
+static HRESULT media_source_init_from_parser(struct wg_parser *parser, QWORD file_size, const WCHAR *uri, struct media_source *object)
 {
     unsigned int stream_count = UINT_MAX;
-    struct media_source *object;
-    wg_parser_t parser;
     unsigned int i;
     HRESULT hr;
 
-    if (!(object = calloc(1, sizeof(*object))))
-        return E_OUTOFMEMORY;
-
     object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
     object->IMFGetService_iface.lpVtbl = &media_source_get_service_vtbl;
     object->IMFRateSupport_iface.lpVtbl = &media_source_rate_support_vtbl;
     object->IMFRateControl_iface.lpVtbl = &media_source_rate_control_vtbl;
     object->async_commands_callback.lpVtbl = &source_async_commands_callback_vtbl;
     object->ref = 1;
-    object->byte_stream = context->stream;
-    IMFByteStream_AddRef(context->stream);
-    object->file_size = context->file_size;
+    object->file_size = file_size;
     object->rate = 1.0f;
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": cs");
@@ -1643,18 +1638,9 @@ static HRESULT media_source_create(struct object_context *context, IMFMediaSourc
     if (FAILED(hr = MFAllocateWorkQueue(&object->async_commands_queue)))
         goto fail;
 
-    if (!(parser = wg_parser_create(WG_PARSER_DECODEBIN)))
-    {
-        hr = E_OUTOFMEMORY;
-        goto fail;
-    }
-    object->wg_parser = parser;
-
-    object->read_thread = CreateThread(NULL, 0, read_thread, object, 0, NULL);
-
     object->state = SOURCE_OPENING;
 
-    if (FAILED(hr = wg_parser_connect(parser, object->file_size)))
+    if (FAILED(hr = wg_parser_connect(parser, file_size, uri)))
         goto fail;
 
     stream_count = wg_parser_get_stream_count(parser);
@@ -1692,8 +1678,7 @@ static HRESULT media_source_create(struct object_context *context, IMFMediaSourc
     media_source_init_descriptors(object);
     object->state = SOURCE_STOPPED;
 
-    *out = &object->IMFMediaSource_iface;
-    TRACE("Created IMFMediaSource %p\n", *out);
+    TRACE("Created IMFMediaSource %p\n", &object->IMFMediaSource_iface);
     return S_OK;
 
 fail:
@@ -1722,6 +1707,64 @@ fail:
         MFUnlockWorkQueue(object->async_commands_queue);
     if (object->event_queue)
         IMFMediaEventQueue_Release(object->event_queue);
+    return hr;
+}
+
+HRESULT winegstreamer_create_media_source_from_uri(const WCHAR *uri, IMFMediaSource **out)
+{
+    struct media_source *object;
+    struct wg_parser *parser;
+    HRESULT hr;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (!(parser = wg_parser_create(WG_PARSER_URIDECODEBIN)))
+    {
+        hr = E_OUTOFMEMORY;
+        goto fail;
+    }
+    object->wg_parser = parser;
+
+    if (FAILED(hr = media_source_init_from_parser(parser, 0, uri, object)))
+        goto fail;
+
+    *out = &object->IMFMediaSource_iface;
+    return S_OK;
+
+fail:
+    free(object);
+    return hr;
+}
+
+static HRESULT media_source_create(struct object_context *context, IMFMediaSource **out)
+{
+    struct wg_parser *parser;
+    struct media_source *object;
+    HRESULT hr;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (!(parser = wg_parser_create(WG_PARSER_DECODEBIN)))
+    {
+        hr = E_OUTOFMEMORY;
+        goto fail;
+    }
+    object->wg_parser = parser;
+
+    object->byte_stream = context->stream;
+    IMFByteStream_AddRef(context->stream);
+
+    object->read_thread = CreateThread(NULL, 0, read_thread, object, 0, NULL);
+
+    if (FAILED(hr = media_source_init_from_parser(parser, context->file_size, NULL, object)))
+        goto fail;
+
+    *out = &object->IMFMediaSource_iface;
+    return S_OK;
+
+fail:
     IMFByteStream_Release(object->byte_stream);
     free(object);
     return hr;
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -1321,7 +1321,7 @@ static HRESULT parser_sink_connect(struct strmbase_sink *iface, IPin *peer, cons
     filter->sink_connected = true;
     filter->read_thread = CreateThread(NULL, 0, read_thread, filter, 0, NULL);
 
-    if (FAILED(hr = wg_parser_connect(filter->wg_parser, file_size)))
+    if (FAILED(hr = wg_parser_connect(filter->wg_parser, file_size, NULL)))
         goto err;
 
     if (!filter->init_gst(filter))
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -201,6 +201,7 @@ typedef UINT32 wg_parser_type;
 enum wg_parser_type
 {
     WG_PARSER_DECODEBIN,
+    WG_PARSER_URIDECODEBIN,
     WG_PARSER_AVIDEMUX,
     WG_PARSER_MPEGAUDIOPARSE,
     WG_PARSER_WAVPARSE,
@@ -222,6 +223,7 @@ struct wg_parser_create_params
 struct wg_parser_connect_params
 {
     wg_parser_t parser;
+    const WCHAR *uri;
     UINT64 file_size;
 };
 
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -72,6 +72,7 @@ struct wg_parser
 
     guint64 file_size, start_offset, next_offset, stop_offset;
     guint64 next_pull_offset;
+    gchar *uri;
 
     pthread_t push_thread;
 
@@ -1542,10 +1543,21 @@ static void query_tags(struct wg_parser_stream *stream)
     gst_object_unref(peer);
 }
 
-static NTSTATUS wg_parser_connect(void *args)
+static void wg_parser_create_my_src(struct wg_parser *parser)
 {
     GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("quartz_src",
             GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
+
+    parser->my_src = gst_pad_new_from_static_template(&src_template, "quartz-src");
+    gst_pad_set_getrange_function(parser->my_src, src_getrange_cb);
+    gst_pad_set_query_function(parser->my_src, src_query_cb);
+    gst_pad_set_activatemode_function(parser->my_src, src_activate_mode_cb);
+    gst_pad_set_event_function(parser->my_src, src_event_cb);
+    gst_pad_set_element_private(parser->my_src, parser);
+}
+
+static NTSTATUS wg_parser_connect(void *args)
+{
     const struct wg_parser_connect_params *params = args;
     struct wg_parser *parser = get_parser(params->parser);
     unsigned int i;
@@ -1553,6 +1565,16 @@ static NTSTATUS wg_parser_connect(void *args)
 
     parser->file_size = params->file_size;
     parser->sink_connected = true;
+    if (params->uri)
+    {
+        size_t len = wcslen(params->uri);
+        parser->uri = malloc(len * 3 + 1);
+        ntdll_wcstoumbs(params->uri, len + 1, parser->uri, len * 3 + 1, FALSE);
+    }
+    else
+    {
+        parser->uri = NULL;
+    }
 
     if (!parser->bus)
     {
@@ -1563,13 +1585,6 @@ static NTSTATUS wg_parser_connect(void *args)
     parser->container = gst_bin_new(NULL);
     gst_element_set_bus(parser->container, parser->bus);
 
-    parser->my_src = gst_pad_new_from_static_template(&src_template, "quartz-src");
-    gst_pad_set_getrange_function(parser->my_src, src_getrange_cb);
-    gst_pad_set_query_function(parser->my_src, src_query_cb);
-    gst_pad_set_activatemode_function(parser->my_src, src_activate_mode_cb);
-    gst_pad_set_event_function(parser->my_src, src_event_cb);
-    gst_pad_set_element_private(parser->my_src, parser);
-
     parser->start_offset = parser->next_offset = parser->stop_offset = 0;
     parser->next_pull_offset = 0;
     parser->error = false;
@@ -1725,7 +1740,8 @@ static NTSTATUS wg_parser_disconnect(void *args)
     pthread_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
-    gst_object_unref(parser->my_src);
+    if (parser->my_src)
+        gst_object_unref(parser->my_src);
     parser->my_src = NULL;
 
     pthread_mutex_lock(&parser->mutex);
@@ -1779,12 +1795,39 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     parser->no_more_pads = false;
     pthread_mutex_unlock(&parser->mutex);
 
+    wg_parser_create_my_src(parser);
+
     if (!link_src_to_element(parser->my_src, element))
         return FALSE;
 
     return TRUE;
 }
 
+static BOOL uridecodebin_parser_init_gst(struct wg_parser *parser)
+{
+    GstElement *element;
+
+    if (!(element = create_element("uridecodebin", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), element);
+    parser->decodebin = element;
+
+    g_object_set(parser->decodebin, "buffer-size", G_MAXINT, NULL);
+    g_object_set(parser->decodebin, "uri", parser->uri, NULL);
+
+    pthread_mutex_lock(&parser->mutex);
+    parser->no_more_pads = false;
+    pthread_mutex_unlock(&parser->mutex);
+
+    g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
+    g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
+    g_signal_connect(element, "autoplug-select", G_CALLBACK(autoplug_select_cb), parser);
+    g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
+
+    return TRUE;
+}
+
 static BOOL avi_parser_init_gst(struct wg_parser *parser)
 {
     GstElement *element;
@@ -1802,6 +1845,8 @@ static BOOL avi_parser_init_gst(struct wg_parser *parser)
     parser->no_more_pads = false;
     pthread_mutex_unlock(&parser->mutex);
 
+    wg_parser_create_my_src(parser);
+
     if (!link_src_to_element(parser->my_src, element))
         return FALSE;
 
@@ -1824,6 +1869,8 @@ static BOOL mpeg_audio_parser_init_gst(struct wg_parser *parser)
     if (!(stream = create_stream(parser)))
         return FALSE;
 
+    wg_parser_create_my_src(parser);
+
     if (!link_element_to_sink(element, stream->my_sink))
         return FALSE;
     gst_pad_set_active(stream->my_sink, 1);
@@ -1843,6 +1890,8 @@ static BOOL wave_parser_init_gst(struct wg_parser *parser)
 
     gst_bin_add(GST_BIN(parser->container), element);
 
+    wg_parser_create_my_src(parser);
+
     if (!link_src_to_element(parser->my_src, element))
         return FALSE;
 
@@ -1863,6 +1912,7 @@ static NTSTATUS wg_parser_create(void *args)
     static const init_gst_cb init_funcs[] =
     {
         [WG_PARSER_DECODEBIN] = decodebin_parser_init_gst,
+        [WG_PARSER_URIDECODEBIN] = uridecodebin_parser_init_gst,
         [WG_PARSER_AVIDEMUX] = avi_parser_init_gst,
         [WG_PARSER_MPEGAUDIOPARSE] = mpeg_audio_parser_init_gst,
         [WG_PARSER_WAVPARSE] = wave_parser_init_gst,
@@ -1901,6 +1951,7 @@ static NTSTATUS wg_parser_destroy(void *args)
     pthread_cond_destroy(&parser->read_cond);
     pthread_cond_destroy(&parser->read_done_cond);
 
+    free(parser->uri);
     free(parser);
     return S_OK;
 }
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1470,7 +1470,7 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
         goto out_destroy_parser;
     }
 
-    if (FAILED(hr = wg_parser_connect(reader->wg_parser, file_size)))
+    if (FAILED(hr = wg_parser_connect(reader->wg_parser, file_size, NULL)))
     {
         ERR("Failed to connect parser, hr %#lx.\n", hr);
         goto out_shutdown_thread;
