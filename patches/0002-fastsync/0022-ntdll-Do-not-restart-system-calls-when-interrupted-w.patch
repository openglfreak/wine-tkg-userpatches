From 1efc7a46b8a70d78b911468598941f8f54374ac0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 12 Mar 2021 17:23:10 -0600
Subject: [PATCH 22/31] ntdll: Do not restart system calls when interrupted
 with SIGUSR1.

---
 dlls/ntdll/unix/signal_arm.c    | 5 +++--
 dlls/ntdll/unix/signal_arm64.c  | 5 +++--
 dlls/ntdll/unix/signal_i386.c   | 5 +++--
 dlls/ntdll/unix/signal_x86_64.c | 5 +++--
 4 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -1068,14 +1068,15 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = segv_handler;
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -1162,8 +1162,6 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = usr2_handler;
     if (sigaction( SIGUSR2, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
@@ -1174,6 +1172,9 @@ void signal_init_process(void)
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = bus_handler;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2378,14 +2378,15 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = segv_handler;
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -3268,14 +3268,15 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = segv_handler;
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     install_bpf(&sig_act);
     return;
 
-- 
2.35.1

