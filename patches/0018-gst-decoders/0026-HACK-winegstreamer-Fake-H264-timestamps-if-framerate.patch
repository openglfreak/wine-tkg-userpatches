From 5f2a8f489390e47b56f8ade062121817271189bd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 21 Feb 2022 12:31:35 +0100
Subject: [PATCH 26/35] HACK: winegstreamer: Fake H264 timestamps if framerate
 cannot be trusted.

Fixes MK11 video framerate.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45988
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47084
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49715
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52183
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362
---
 dlls/winegstreamer/h264_decoder.c | 11 +++++++++++
 dlls/winegstreamer/wg_transform.c | 18 ++++++++++--------
 2 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -51,6 +51,7 @@ struct h264_decoder
 
     struct wg_transform *wg_transform;
     struct wg_format wg_format;
+    LONGLONG last_timestamp;
 };
 
 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -63,6 +64,7 @@ static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
     struct wg_format input_format;
     struct wg_format output_format;
 
+    decoder->last_timestamp = 0;
     memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
@@ -565,6 +567,15 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
     else
         hr = wg_transform_read_data(decoder->wg_transform, wg_sample);
 
+    if (!(wg_sample->flags & (WG_SAMPLE_FLAG_HAS_TIMESTAMP|WG_SAMPLE_FLAG_HAS_DURATION)) &&
+            hr == S_OK)
+    {
+        wg_sample->timestamp = decoder->last_timestamp;
+        wg_sample->duration = (UINT64)10000000 * (UINT32)frame_rate / (frame_rate >> 32);
+        wg_sample->flags |= (WG_SAMPLE_FLAG_HAS_TIMESTAMP|WG_SAMPLE_FLAG_HAS_DURATION);
+        decoder->last_timestamp += wg_sample->duration;
+    }
+
     if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
     {
         decoder->wg_format = wg_sample->format;
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 11111111111..11111111111 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -57,6 +57,7 @@ struct wg_transform
     GstPad *my_src, *my_sink;
     GstPad *their_sink, *their_src;
     GstSegment segment;
+    bool broken_timestamps;
     pthread_mutex_t mutex;
     struct list samples;
     GstCaps *sink_caps;
@@ -280,12 +281,13 @@ NTSTATUS wg_transform_create(void *args)
     switch (input_format.major_type)
     {
         case WG_MAJOR_TYPE_H264:
-            if (!(element = create_element("h264parse", "base"))
-                    || !transform_append_element(transform, element, &first, &last))
+            if ((element = create_element("h264parse", "base"))
+                    && !transform_append_element(transform, element, &first, &last))
             {
                 gst_caps_unref(sink_caps);
                 goto out;
             }
+            transform->broken_timestamps = !element;
             /* fallthrough */
         case WG_MAJOR_TYPE_WMA:
             if (!(element = transform_find_element(GST_ELEMENT_FACTORY_TYPE_DECODER, src_caps, sink_caps))
@@ -456,23 +458,23 @@ static void release_sample_entry(struct wg_sample *sample, struct sample_entry *
     }
 }
 
-static void copy_sample_meta_data(struct wg_sample *sample, struct sample_entry *entry)
+static void copy_sample_meta_data(struct wg_transform *transform, struct wg_sample *sample, struct sample_entry *entry)
 {
     GstBuffer *buffer = gst_sample_get_buffer(entry->sample);
 
-    if (GST_BUFFER_PTS_IS_VALID(buffer))
+    if (GST_BUFFER_PTS_IS_VALID(buffer) && !transform->broken_timestamps)
     {
         sample->flags |= WG_SAMPLE_FLAG_HAS_TIMESTAMP;
         sample->timestamp = GST_BUFFER_PTS(buffer) / 100;
     }
-    if (GST_BUFFER_DURATION_IS_VALID(buffer))
+    if (GST_BUFFER_DURATION_IS_VALID(buffer) && !transform->broken_timestamps)
     {
         sample->flags |= WG_SAMPLE_FLAG_HAS_DURATION;
         sample->duration = GST_BUFFER_DURATION(buffer) / 100;
     }
 }
 
-static NTSTATUS copy_from_sample_entry(struct wg_sample *sample, struct sample_entry *entry, HRESULT *result)
+static NTSTATUS copy_from_sample_entry(struct wg_transform *transform, struct wg_sample *sample, struct sample_entry *entry, HRESULT *result)
 {
     GstBuffer *buffer = gst_sample_get_buffer(entry->sample);
     GstCaps *caps = gst_sample_get_caps(entry->sample);
@@ -505,7 +507,7 @@ static NTSTATUS copy_from_sample_entry(struct wg_sample *sample, struct sample_e
     memcpy(sample->data, info.data, sample->size);
     gst_buffer_unmap(buffer, &info);
 
-    copy_sample_meta_data(sample, entry);
+    copy_sample_meta_data(transform, sample, entry);
 
     GST_INFO("Copied %u bytes, flags %#x", sample->size, (UINT32)sample->flags);
 
@@ -526,7 +528,7 @@ NTSTATUS wg_transform_read_data(void *args)
     if ((head = list_head(&transform->samples)))
     {
         entry = LIST_ENTRY(head, struct sample_entry, entry);
-        status = copy_from_sample_entry(sample, entry, &params->result);
+        status = copy_from_sample_entry(transform, sample, entry, &params->result);
         release_sample_entry(sample, entry);
     }
     else

